/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { Pipe } from '@angular/core';
import { isNumberFinite, toDecimal } from 'ng-zorro-antd/core/util';
export class NzBytesPipe {
    transform(input, decimal = 0, from = 'B', to) {
        if (!(isNumberFinite(input) && isNumberFinite(decimal) && decimal % 1 === 0 && decimal >= 0)) {
            return input;
        }
        let bytes = input;
        let unit = from;
        while (unit !== 'B') {
            bytes *= 1024;
            unit = NzBytesPipe.formats[unit].prev;
        }
        if (to) {
            const format = NzBytesPipe.formats[to];
            const result = toDecimal(NzBytesPipe.calculateResult(format, bytes), decimal);
            return NzBytesPipe.formatResult(result, to);
        }
        for (const key in NzBytesPipe.formats) {
            if (NzBytesPipe.formats.hasOwnProperty(key)) {
                const format = NzBytesPipe.formats[key];
                if (bytes < format.max) {
                    const result = toDecimal(NzBytesPipe.calculateResult(format, bytes), decimal);
                    return NzBytesPipe.formatResult(result, key);
                }
            }
        }
    }
    static formatResult(result, unit) {
        return `${result} ${unit}`;
    }
    static calculateResult(format, bytes) {
        const prev = format.prev ? NzBytesPipe.formats[format.prev] : undefined;
        return prev ? bytes / prev.max : bytes;
    }
}
NzBytesPipe.formats = {
    B: { max: 1024 },
    kB: { max: Math.pow(1024, 2), prev: 'B' },
    KB: { max: Math.pow(1024, 2), prev: 'B' },
    MB: { max: Math.pow(1024, 3), prev: 'kB' },
    GB: { max: Math.pow(1024, 4), prev: 'MB' },
    TB: { max: Number.MAX_SAFE_INTEGER, prev: 'GB' }
};
NzBytesPipe.decorators = [
    { type: Pipe, args: [{
                name: 'nzBytes'
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnotYnl0ZXMucGlwZS5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS92c3RzL3dvcmsvMS9zL2NvbXBvbmVudHMvcGlwZXMvIiwic291cmNlcyI6WyJuei1ieXRlcy5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7R0FHRztBQUVILE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRXBELE9BQU8sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFPcEUsTUFBTSxPQUFPLFdBQVc7SUFVdEIsU0FBUyxDQUFDLEtBQWdCLEVBQUUsVUFBa0IsQ0FBQyxFQUFFLE9BQWlCLEdBQUcsRUFBRSxFQUFhO1FBQ2xGLElBQUksQ0FBQyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxFQUFFO1lBQzVGLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFFRCxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ2hCLE9BQU8sSUFBSSxLQUFLLEdBQUcsRUFBRTtZQUNuQixLQUFLLElBQUksSUFBSSxDQUFDO1lBQ2QsSUFBSSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSyxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxFQUFFLEVBQUU7WUFDTixNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRXZDLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUU5RSxPQUFPLFdBQVcsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsS0FBSyxNQUFNLEdBQUcsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFO1lBQ3JDLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQzNDLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3hDLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEVBQUU7b0JBQ3RCLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxXQUFXLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztvQkFFOUUsT0FBTyxXQUFXLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztpQkFDOUM7YUFDRjtTQUNGO0lBQ0gsQ0FBQztJQUVELE1BQU0sQ0FBQyxZQUFZLENBQUMsTUFBYyxFQUFFLElBQVk7UUFDOUMsT0FBTyxHQUFHLE1BQU0sSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsTUFBTSxDQUFDLGVBQWUsQ0FBQyxNQUF3QyxFQUFFLEtBQWE7UUFDNUUsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUN4RSxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUN6QyxDQUFDOztBQWhETSxtQkFBTyxHQUF3RDtJQUNwRSxDQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFO0lBQ2hCLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0lBQ3pDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0lBQ3pDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0lBQzFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0lBQzFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtDQUNqRCxDQUFDOztZQVhILElBQUksU0FBQztnQkFDSixJQUFJLEVBQUUsU0FBUzthQUNoQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE56U2FmZUFueSB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS90eXBlcyc7XG5pbXBvcnQgeyBpc051bWJlckZpbml0ZSwgdG9EZWNpbWFsIH0gZnJvbSAnbmctem9ycm8tYW50ZC9jb3JlL3V0aWwnO1xuXG5leHBvcnQgdHlwZSBCeXRlVW5pdCA9ICdCJyB8ICdrQicgfCAnS0InIHwgJ01CJyB8ICdHQicgfCAnVEInO1xuXG5AUGlwZSh7XG4gIG5hbWU6ICduekJ5dGVzJ1xufSlcbmV4cG9ydCBjbGFzcyBOekJ5dGVzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICBzdGF0aWMgZm9ybWF0czogeyBba2V5OiBzdHJpbmddOiB7IG1heDogbnVtYmVyOyBwcmV2PzogQnl0ZVVuaXQgfSB9ID0ge1xuICAgIEI6IHsgbWF4OiAxMDI0IH0sXG4gICAga0I6IHsgbWF4OiBNYXRoLnBvdygxMDI0LCAyKSwgcHJldjogJ0InIH0sXG4gICAgS0I6IHsgbWF4OiBNYXRoLnBvdygxMDI0LCAyKSwgcHJldjogJ0InIH0sXG4gICAgTUI6IHsgbWF4OiBNYXRoLnBvdygxMDI0LCAzKSwgcHJldjogJ2tCJyB9LFxuICAgIEdCOiB7IG1heDogTWF0aC5wb3coMTAyNCwgNCksIHByZXY6ICdNQicgfSxcbiAgICBUQjogeyBtYXg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBwcmV2OiAnR0InIH1cbiAgfTtcblxuICB0cmFuc2Zvcm0oaW5wdXQ6IE56U2FmZUFueSwgZGVjaW1hbDogbnVtYmVyID0gMCwgZnJvbTogQnl0ZVVuaXQgPSAnQicsIHRvPzogQnl0ZVVuaXQpOiBOelNhZmVBbnkge1xuICAgIGlmICghKGlzTnVtYmVyRmluaXRlKGlucHV0KSAmJiBpc051bWJlckZpbml0ZShkZWNpbWFsKSAmJiBkZWNpbWFsICUgMSA9PT0gMCAmJiBkZWNpbWFsID49IDApKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgbGV0IGJ5dGVzID0gaW5wdXQ7XG4gICAgbGV0IHVuaXQgPSBmcm9tO1xuICAgIHdoaWxlICh1bml0ICE9PSAnQicpIHtcbiAgICAgIGJ5dGVzICo9IDEwMjQ7XG4gICAgICB1bml0ID0gTnpCeXRlc1BpcGUuZm9ybWF0c1t1bml0XS5wcmV2ITtcbiAgICB9XG5cbiAgICBpZiAodG8pIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IE56Qnl0ZXNQaXBlLmZvcm1hdHNbdG9dO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSB0b0RlY2ltYWwoTnpCeXRlc1BpcGUuY2FsY3VsYXRlUmVzdWx0KGZvcm1hdCwgYnl0ZXMpLCBkZWNpbWFsKTtcblxuICAgICAgcmV0dXJuIE56Qnl0ZXNQaXBlLmZvcm1hdFJlc3VsdChyZXN1bHQsIHRvKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBOekJ5dGVzUGlwZS5mb3JtYXRzKSB7XG4gICAgICBpZiAoTnpCeXRlc1BpcGUuZm9ybWF0cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IE56Qnl0ZXNQaXBlLmZvcm1hdHNba2V5XTtcbiAgICAgICAgaWYgKGJ5dGVzIDwgZm9ybWF0Lm1heCkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRvRGVjaW1hbChOekJ5dGVzUGlwZS5jYWxjdWxhdGVSZXN1bHQoZm9ybWF0LCBieXRlcyksIGRlY2ltYWwpO1xuXG4gICAgICAgICAgcmV0dXJuIE56Qnl0ZXNQaXBlLmZvcm1hdFJlc3VsdChyZXN1bHQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZm9ybWF0UmVzdWx0KHJlc3VsdDogbnVtYmVyLCB1bml0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtyZXN1bHR9ICR7dW5pdH1gO1xuICB9XG5cbiAgc3RhdGljIGNhbGN1bGF0ZVJlc3VsdChmb3JtYXQ6IHsgbWF4OiBudW1iZXI7IHByZXY/OiBCeXRlVW5pdCB9LCBieXRlczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBwcmV2ID0gZm9ybWF0LnByZXYgPyBOekJ5dGVzUGlwZS5mb3JtYXRzW2Zvcm1hdC5wcmV2XSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcHJldiA/IGJ5dGVzIC8gcHJldi5tYXggOiBieXRlcztcbiAgfVxufVxuIl19