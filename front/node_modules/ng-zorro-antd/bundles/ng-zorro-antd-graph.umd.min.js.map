{"version":3,"sources":["../../components/graph/interface.ts","../../node_modules/tslib/tslib.es6.js","../../components/graph/data-source/graph-data-source.ts","../../components/graph/graph-defs.component.ts","../../components/graph/graph-edge.component.ts","../../components/graph/graph-edge.directive.ts","../../components/graph/core/minimap.ts","../../components/graph/graph-minimap.component.ts","../../components/graph/graph-node.component.ts","../../components/graph/graph-node.directive.ts","../../components/graph/core/utils.ts","../../components/graph/graph-zoom.directive.ts","../../components/graph/graph.component.ts","../../components/graph/graph.module.ts"],"names":["nzTypeDefinition","item","NZ_GRAPH_LAYOUT_SETTING","animation","duration","graph","meta","nodeSep","rankSep","edgeSep","padding","paddingTop","paddingLeft","subscene","paddingBottom","paddingRight","labelHeight","extractXOffset","extractYOffset","nodeSize","radius","width","maxLabelWidth","height","expandButtonRadius","op","labelOffset","bridge","shortcutSize","series","annotations","inboxWidth","outboxWidth","xOffset","yOffset","constant","size","minimap","__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__metadata","metadataKey","metadataValue","metadata","create","__values","o","s","Symbol","iterator","m","call","next","value","done","TypeError","__read","n","e","ar","push","error","__spread","concat","NzGraphData","source","this","_data","BehaviorSubject","expansionModel","SelectionModel","_a","clear","dataSource","prototype","toggle","nodeName","expand","select","collapse","deselect","isExpanded","isSelected","collapseAll","expandAll","_b","apply","keys","compound","setData","data","connect","_this","changes","changed","merge","pipe","map","disconnect","Component","args","selector","template","NzGraphEdgeComponent","elementRef","ngZone","cdr","line","x","y","curve","curveBasis","el","nativeElement","edge","id","v","w","ngOnInit","initElementStyle","ngOnChanges","customTemplate","onStable","take","subscribe","setLine","markForCheck","path","querySelector","setElementData","adjoiningPath","getAdjoiningEdgeElement","adjoiningPoint","getPointAtLength","inbound","getTotalLength","matrixTransform","getCTM","inverse","points","index","setPath","setAttribute","adjoiningEdge","document","changeDetection","ChangeDetectionStrategy","OnPush","ElementRef","NgZone","ChangeDetectorRef","Input","Directive","exportAs","Minimap","svg","zoomG","mainZoom","maxWidth","labelPadding","minimapElement","minimapSvgElement","viewpointElement","canvas","node","canvasRect","getBoundingClientRect","handleEvent","event","minimapOffset","Number","attr","clickCoords","pointer","viewpointCoord","updateViewpoint","dragEvent","drag","subject","on","datum","defaultPrevented","viewpoint","minimapSvg","canvasBuffer","update","minimapSize","mainX","scaleMain","scaleMinimap","mainY","transform","zoomIdentity","translate","scale","sceneSize","getBBox","svgSelection","stylesText","_c","Array","styleSheets","_d","k","cssRules","rules","_e","e_2","_f","cssText","replace","name","svgStyle","append","text","zoomGSelection","zoomTransform","Math","max","zoom","requestAnimationFrame","svgXml","XMLSerializer","serializeToString","remove","image","Image","onload","context","getContext","clearRect","drawImage","style","src","encodeURIComponent","svgRect","viewpointSelection","viewpointWidth","viewpointHeight","mapWidth","mapHeight","min","classList","add","NzGraphMinimapComponent","init","containerEle","zoomBehavior","svgEle","zoomEle","host","[class.nz-graph-minimap]","NzGraphNodeComponent","builder","renderer2","nodeClick","EventEmitter","animationInfo","initialState","animationPlayer","triggerClick","preventDefault","emit","makeAnimation","animationFactory","cur","getAnimationInfo","destroy","pre","assign","build","query","group","animate","play","done$","Subject","onDone","complete","asObservable","makeNoAnimation","nodeTransform","computeCXPositionOfNodeShape","expanded","coreBox","[id]","[class.nz-graph-node-expanded]","[class.nz-graph-group-node]","[class.nz-graph-base-node]","(click)","AnimationBuilder","Renderer2","Output","InputBoolean","calculateTransform","targetEle","containerEleSize","targetEleSize","scaleUnit","Selection","bind","d3Transition","NzGraphZoomDirective","element","nzMinZoom","nzMaxZoom","nzTransformEvent","nzZoomChange","destroy$","ngAfterViewInit","ngOnDestroy","unbind","svgElement","gZoomElement","extent","scaleExtent","zoomed","nzZoom","reScale","interrupt","selectAll","fitCenter","focus","getElementById","position","getRelativePositionInfo","svgTransform","centerX","topLeft","bottomRight","centerY","dx","left","dy","top","transition","translateBy","zTransform","nodeBox","nodeCtm","getScreenCTM","pointTL","createSVGPoint","pointBR","isDataSource","NzGraphComponent","noAnimation","nzRankDirection","nzAutoSize","nzGraphInitialized","nzGraphRendered","nzNodeClick","requestId","transformStyle","graphRenderedSubject$","ReplaySubject","renderInfo","mapOfNodeAttr","mapOfEdgeAttr","typedNodes","layoutSetting","nodeTrackByFun","_","edgeTrackByFun","subGraphTransform","coreTransform","parentNodeName","skip","takeUntil","nzAutoFit","nzGraphData","nzGraphLayoutSettings","_switchDataSource","firstChange","drawGraph","rankDirection","selected","then","ngAfterContentChecked","_dataSubscription","observeRenderChanges","unsubscribe","cancelRequestAnimationFrame","clickNode","options","needResize","Promise","resolve","buildGraphInfo","drawNodes","nzNoAnimation","resizeNodeSize","makeNodesAnimation","listOfNodeComponent","getScale","listOfNodeElement","forEach","nodeEle","contentEle","clientRect","bBoxRect","nodes","find","dataStream","graphOptions","Error","detectChanges","getAttribute","match","exec","parseFloat","parseInfo","buildGraph","dig","type","hasOwnProperty","edges","forkJoin","finalize","encapsulation","ViewEncapsulation","None","[class.nz-graph]","[class.nz-graph-auto-size]","NzNoAnimationDirective","Host","Optional","ViewChildren","read","ContentChild","NzGraphNodeDirective","static","TemplateRef","NzGraphEdgeDirective","COMPONENTS","NzGraphDefsComponent","NgModule","declarations","imports","CommonModule","NzIconModule","NzSpinModule","NzNoAnimationModule","exports"],"mappings":"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","sourcesContent":["/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport {\n  HierarchyBaseEdgeInfo,\n  HierarchyBaseNodeInfo,\n  HierarchyGraphDef,\n  HierarchyGraphEdgeDef,\n  HierarchyGraphNodeDef,\n  HierarchyGraphNodeInfo,\n  HierarchyGraphOption\n} from '@nx-component/hierarchy-graph';\nimport { LayoutSetting } from '@nx-component/hierarchy-graph/dist/types';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\n\nexport interface NzGraphDataDef extends HierarchyGraphDef {\n  nodes: NzGraphNodeDef[];\n  edges: NzGraphEdgeDef[];\n}\n\nexport interface NzGraphNodeDef extends HierarchyGraphNodeDef {\n  label?: string;\n}\n\nexport interface NzGraphEdgeDef extends HierarchyGraphEdgeDef {\n  label?: string;\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface NzGraphOption extends HierarchyGraphOption {}\nexport declare type NzRankDirection = 'TB' | 'BT' | 'LR' | 'RL';\n\nexport interface NzGraphGroupNode extends HierarchyGraphNodeInfo {\n  nodes: Array<NzGraphNode | NzGraphGroupNode>;\n  edges: NzGraphEdge[];\n  [key: string]: NzSafeAny;\n}\n\nexport interface NzGraphNode extends HierarchyBaseNodeInfo {\n  id: NzSafeAny;\n  // TODO\n  name: NzSafeAny;\n  label?: string;\n  [key: string]: NzSafeAny;\n}\n\nexport interface NzGraphEdge extends HierarchyBaseEdgeInfo {\n  id: NzSafeAny;\n  v: NzSafeAny;\n  w: NzSafeAny;\n  label?: string;\n}\n\n// tslint:disable-next-line:no-empty-interface\nexport interface NzLayoutSetting extends LayoutSetting {}\n\nexport function nzTypeDefinition<T>(): (item: unknown) => T {\n  return item => item as T;\n}\n\n// tslint:disable:no-shadowed-variable\nexport type NzDeepPartial<T> = {\n  [P in keyof T]?: T[P] extends Array<infer U>\n    ? Array<NzDeepPartial<U>>\n    : T[P] extends ReadonlyArray<infer U>\n    ? ReadonlyArray<NzDeepPartial<U>>\n    : NzDeepPartial<T[P]>;\n};\n\nexport type NzGraphLayoutSetting = NzDeepPartial<NzLayoutSetting>;\nexport const NZ_GRAPH_LAYOUT_SETTING: NzLayoutSetting = {\n  animation: {\n    /** Default duration for graph animations in ms. */\n    duration: 250\n  },\n  graph: {\n    /** Graph parameter for metanode. */\n    meta: {\n      /**\n       * Dagre's nodesep param - number of pixels that\n       * separate nodes horizontally in the layout.\n       *\n       * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout\n       */\n      nodeSep: 50,\n      /**\n       * Dagre's ranksep param - number of pixels\n       * between each rank in the layout.\n       *\n       * See https://github.com/cpettitt/dagre/wiki#configuring-the-layout\n       */\n      rankSep: 40,\n      /**\n       * Dagre's edgesep param - number of pixels that separate\n       * edges horizontally in the layout.\n       */\n      edgeSep: 5\n    },\n    /**\n     * Padding is used to correctly position the graph SVG inside of its parent\n     * element. The padding amounts are applied using an SVG transform of X and\n     * Y coordinates.\n     */\n    padding: { paddingTop: 10, paddingLeft: 0 }\n  },\n  subscene: {\n    meta: {\n      paddingTop: 20,\n      paddingBottom: 20,\n      paddingLeft: 20,\n      paddingRight: 20,\n      /**\n       * Used to leave room for the label on top of the highest node in\n       * the groupCore graph.\n       */\n      labelHeight: 20,\n      /** X-space between each extracted node and the groupCore graph. */\n      extractXOffset: 0,\n      /** Y-space between each extracted node. */\n      extractYOffset: 0\n    }\n  },\n  nodeSize: {\n    /** Size of meta nodes. */\n    meta: {\n      radius: 2,\n      width: 160,\n      maxLabelWidth: 0,\n      /** A scale for the node's height based on number of nodes inside */\n      // Hack - set this as an any type to avoid issues in exporting a type\n      // from an external module.\n      height: 100,\n      /** The radius of the circle denoting the expand button. */\n      expandButtonRadius: 3\n    },\n    /** Size of op nodes. */\n    op: {\n      width: 160,\n      height: 100,\n      radius: 1, // for making annotation touching ellipse\n      labelOffset: 10,\n      maxLabelWidth: 40\n    },\n    /** Size of bridge nodes. */\n    bridge: {\n      // NOTE: bridge nodes will normally be invisible, but they must\n      // take up some space so that the layout step leaves room for\n      // their edges.\n      width: 10,\n      height: 10,\n      radius: 2,\n      labelOffset: 0\n    }\n  },\n  shortcutSize: {\n    /** Size of shortcuts for op nodes */\n    op: { width: 10, height: 4 },\n    /** Size of shortcuts for meta nodes */\n    meta: { width: 12, height: 4, radius: 1 },\n    /** Size of shortcuts for series nodes */\n    series: {\n      width: 14,\n      height: 4\n    }\n  },\n  annotations: {\n    /** Maximum possible width of the bounding box for in annotations */\n    inboxWidth: 50,\n    /** Maximum possible width of the bounding box for out annotations */\n    outboxWidth: 50,\n    /** X-space between the shape and each annotation-node. */\n    xOffset: 10,\n    /** Y-space between each annotation-node. */\n    yOffset: 3,\n    /** X-space between each annotation-node and its label. */\n    labelOffset: 2,\n    /** Defines the max width for annotation label */\n    maxLabelWidth: 120\n  },\n  constant: { size: { width: 4, height: 4 } },\n  minimap: {\n    /** The maximum width/height the minimap can have. */\n    size: 150\n  }\n};\n\n// Zoom interface\n\nexport interface NzZoomTransform {\n  x: number;\n  y: number;\n  k: number;\n}\n\nexport interface RelativePositionInfo {\n  topLeft: { x: number; y: number };\n  bottomRight: { x: number; y: number };\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { BehaviorSubject, merge, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { NzGraphDataDef } from '../interface';\nimport { NzGraphBaseSource } from './base-graph-source';\n\nexport class NzGraphData implements NzGraphBaseSource<NzGraphDataDef, string> {\n  private _data = new BehaviorSubject<NzGraphDataDef>({} as NzGraphDataDef);\n  dataSource!: NzGraphDataDef;\n  /** A selection model with multi-selection to track expansion status. */\n  expansionModel: SelectionModel<string> = new SelectionModel<string>(true);\n\n  /** Toggles one single data node's expanded/collapsed state. */\n  toggle(nodeName: string): void {\n    this.expansionModel.toggle(nodeName);\n  }\n\n  /** Expands one single data node. */\n  expand(nodeName: string): void {\n    this.expansionModel.select(nodeName);\n  }\n\n  /** Collapses one single data node. */\n  collapse(nodeName: string): void {\n    this.expansionModel.deselect(nodeName);\n  }\n\n  /** Whether a given data node is expanded or not. Returns true if the data node is expanded. */\n  isExpanded(nodeName: string): boolean {\n    return this.expansionModel.isSelected(nodeName);\n  }\n\n  /** Collapse all dataNodes in the tree. */\n  collapseAll(): void {\n    this.expansionModel.clear();\n  }\n\n  expandAll(): void {\n    this.expansionModel.select(...Object.keys(this._data.value.compound || {}));\n  }\n\n  setData(data: NzGraphDataDef): void {\n    this.expansionModel?.clear();\n    this.dataSource = data;\n    this._data.next(data);\n  }\n\n  constructor(source?: NzGraphDataDef) {\n    if (source) {\n      this.expansionModel?.clear();\n      this.dataSource = source;\n      this._data.next(source);\n    }\n  }\n\n  connect(): Observable<NzGraphDataDef> {\n    const changes = [this._data, this.expansionModel.changed];\n    return merge(...changes).pipe(map(() => this._data.value));\n  }\n\n  disconnect(): void {\n    // do nothing for now\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'svg:defs[nz-graph-defs]',\n  template: `\n    <svg:marker\n      class=\"nz-graph-edge-marker\"\n      id=\"edge-end-arrow\"\n      viewBox=\"1 0 20 20\"\n      refX=\"8\"\n      refY=\"3.5\"\n      markerWidth=\"10\"\n      markerHeight=\"10\"\n      orient=\"auto\"\n    >\n      <svg:polygon points=\"0 0, 10 3.5, 0 7\"></svg:polygon>\n    </svg:marker>\n  `\n})\nexport class NzGraphDefsComponent {\n  constructor() {}\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  Input,\n  NgZone,\n  OnChanges,\n  OnInit,\n  SimpleChanges,\n  TemplateRef\n} from '@angular/core';\nimport { curveBasis, line } from 'd3-shape';\nimport { take } from 'rxjs/operators';\nimport { NzGraphEdge } from './interface';\n\n@Component({\n  selector: '[nz-graph-edge]',\n  template: `\n    <ng-container *ngIf=\"customTemplate\" [ngTemplateOutlet]=\"customTemplate\" [ngTemplateOutletContext]=\"{ $implicit: edge }\"></ng-container>\n    <svg:g *ngIf=\"!customTemplate\">\n      <path class=\"nz-graph-edge-line\" [attr.marker-end]=\"'url(#edge-end-arrow)'\"></path>\n      <svg:text class=\"nz-graph-edge-text\" text-anchor=\"middle\" dy=\"10\" *ngIf=\"edge.label\">\n        <textPath [attr.href]=\"'#' + id\" startOffset=\"50%\">{{ edge.label }}</textPath>\n      </svg:text>\n    </svg:g>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class NzGraphEdgeComponent implements OnInit, OnChanges {\n  @Input() edge!: NzGraphEdge;\n  @Input() customTemplate?: TemplateRef<{\n    $implicit: NzGraphEdge;\n  }>;\n\n  public get id(): string {\n    return this.edge?.id || `${this.edge.v}--${this.edge.w}`;\n  }\n  private el!: SVGGElement;\n  private path!: SVGPathElement;\n\n  private readonly line = line<{ x: number; y: number }>()\n    .x(d => d.x)\n    .y(d => d.y)\n    .curve(curveBasis);\n\n  constructor(private elementRef: ElementRef<SVGGElement>, private ngZone: NgZone, private cdr: ChangeDetectorRef) {\n    this.el = this.elementRef.nativeElement;\n  }\n\n  ngOnInit(): void {\n    this.initElementStyle();\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const { edge, customTemplate } = changes;\n    if (edge) {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        // Update path element if customTemplate set\n        if (customTemplate) {\n          this.initElementStyle();\n        }\n\n        this.setLine();\n        this.cdr.markForCheck();\n      });\n    }\n  }\n\n  initElementStyle(): void {\n    this.path = this.el.querySelector('path')!;\n    this.setElementData();\n  }\n\n  setLine(): void {\n    // TODO\n    // Need to move it to hierarchy graph\n    const adjoiningPath = this.getAdjoiningEdgeElement();\n    if (adjoiningPath) {\n      const adjoiningPoint = adjoiningPath\n        .getPointAtLength(this.edge.inbound ? adjoiningPath.getTotalLength() : 0)\n        .matrixTransform(adjoiningPath.getCTM()!)\n        .matrixTransform(this.path.getCTM()!.inverse());\n      const points = [...this.edge.points];\n      const index = this.edge.inbound ? 0 : points.length - 1;\n      points[index].x = adjoiningPoint.x;\n      points[index].y = adjoiningPoint.y;\n      this.setPath(this.line(points)!);\n    } else {\n      this.setPath(this.line(this.edge.points)!);\n    }\n  }\n\n  setPath(d: string): void {\n    this.path.setAttribute('d', d);\n  }\n\n  setElementData(): void {\n    if (!this.path) {\n      return;\n    }\n    this.path.setAttribute('id', this.id);\n    this.path.setAttribute('data-edge', this.id);\n    this.path.setAttribute('data-v', `${this.edge.v}`);\n    this.path.setAttribute('data-w', `${this.edge.w}`);\n  }\n\n  getAdjoiningEdgeElement(): SVGPathElement | null {\n    const adjoiningEdge = this.edge.adjoiningEdge;\n    if (adjoiningEdge) {\n      return document.querySelector(`path[data-edge=\"${adjoiningEdge.v}--${adjoiningEdge.w}\"]`) as SVGPathElement;\n    } else {\n      return null;\n    }\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[nzGraphEdge]',\n  exportAs: 'nzGraphEdge'\n})\nexport class NzGraphEdgeDirective {}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { drag } from 'd3-drag';\nimport { pointer, select } from 'd3-selection';\nimport { ZoomBehavior, zoomIdentity, ZoomTransform } from 'd3-zoom';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { NzZoomTransform } from '../interface';\n\nconst FRAC_VIEWPOINT_AREA = 0.8;\n\nexport class Minimap {\n  private minimap: HTMLElement;\n  private canvas: HTMLCanvasElement;\n  private canvasRect: ClientRect;\n  private canvasBuffer: HTMLCanvasElement;\n  private minimapSvg: SVGSVGElement;\n  private viewpoint: SVGRectElement;\n  private scaleMinimap!: number;\n  private scaleMain!: number;\n  private maxWidth: number;\n  private translate!: [number, number];\n  private viewpointCoord: { x: number; y: number };\n  private minimapSize!: { width: number; height: number };\n  private labelPadding: number;\n\n  private svg: SVGSVGElement;\n  private zoomG: SVGGElement;\n  private mainZoom: ZoomBehavior<NzSafeAny, NzSafeAny>;\n\n  constructor(\n    svg: SVGSVGElement,\n    zoomG: SVGGElement,\n    mainZoom: ZoomBehavior<NzSafeAny, NzSafeAny>,\n    minimap: HTMLElement,\n    maxWidth: number,\n    labelPadding: number\n  ) {\n    this.svg = svg;\n    this.labelPadding = labelPadding;\n    this.zoomG = zoomG;\n    this.mainZoom = mainZoom;\n    this.maxWidth = maxWidth;\n    const minimapElement = select(minimap);\n    const minimapSvgElement = minimapElement.select('svg');\n    const viewpointElement = minimapSvgElement.select('rect');\n    this.canvas = minimapElement.select('canvas.viewport').node() as HTMLCanvasElement;\n    this.canvasRect = this.canvas.getBoundingClientRect();\n\n    const handleEvent = (event: NzSafeAny): void => {\n      const minimapOffset = this.minimapOffset();\n      const width = Number(viewpointElement.attr('width'));\n      const height = Number(viewpointElement.attr('height'));\n      const clickCoords = pointer(event, minimapSvgElement.node() as NzSafeAny);\n      this.viewpointCoord.x = clickCoords[0] - width / 2 - minimapOffset.x;\n      this.viewpointCoord.y = clickCoords[1] - height / 2 - minimapOffset.y;\n      this.updateViewpoint();\n    };\n    this.viewpointCoord = { x: 0, y: 0 };\n    const dragEvent = drag().subject(Object).on('drag', handleEvent);\n    viewpointElement.datum(this.viewpointCoord as NzSafeAny).call(dragEvent as NzSafeAny);\n\n    // Make the minimap clickable.\n    minimapSvgElement.on('click', event => {\n      if ((event as Event).defaultPrevented) {\n        // This click was part of a drag event, so suppress it.\n        return;\n      }\n      handleEvent(event);\n    });\n    this.viewpoint = viewpointElement.node() as SVGRectElement;\n    this.minimapSvg = minimapSvgElement.node() as SVGSVGElement;\n    this.minimap = minimap;\n    this.canvasBuffer = minimapElement.select('canvas.buffer').node() as HTMLCanvasElement;\n    this.update();\n  }\n\n  private minimapOffset(): { x: number; y: number } {\n    return {\n      x: (this.canvasRect.width - this.minimapSize.width) / 2,\n      y: (this.canvasRect.height - this.minimapSize.height) / 2\n    };\n  }\n\n  private updateViewpoint(): void {\n    // Update the coordinates of the viewpoint rectangle.\n    select(this.viewpoint).attr('x', this.viewpointCoord.x).attr('y', this.viewpointCoord.y);\n    // Update the translation vector of the main svg to reflect the\n    // new viewpoint.\n    const mainX = (-this.viewpointCoord.x * this.scaleMain) / this.scaleMinimap;\n    const mainY = (-this.viewpointCoord.y * this.scaleMain) / this.scaleMinimap;\n    select(this.svg).call(this.mainZoom.transform, zoomIdentity.translate(mainX, mainY).scale(this.scaleMain));\n  }\n\n  update(): void {\n    let sceneSize = null;\n    try {\n      // Get the size of the entire scene.\n      sceneSize = this.zoomG.getBBox();\n      if (sceneSize.width === 0) {\n        // There is no scene anymore. We have been detached from the dom.\n        return;\n      }\n    } catch (e) {\n      // Firefox produced NS_ERROR_FAILURE if we have been\n      // detached from the dom.\n      return;\n    }\n\n    const svgSelection = select(this.svg);\n    // Read all the style rules in the document and embed them into the svg.\n    // The svg needs to be self contained, i.e. all the style rules need to be\n    // embedded so the canvas output matches the origin.\n    let stylesText = '';\n\n    for (const k of new Array(document.styleSheets.length).keys()) {\n      try {\n        const cssRules = (document.styleSheets[k] as NzSafeAny).cssRules || (document.styleSheets[k] as NzSafeAny).rules;\n        if (cssRules == null) {\n          continue;\n        }\n        for (const i of new Array(cssRules.length).keys()) {\n          // Remove tf-* selectors from the styles.\n          stylesText += cssRules[i].cssText.replace(/ ?tf-[\\w-]+ ?/g, '') + '\\n';\n        }\n      } catch (e) {\n        if (e.name !== 'SecurityError') {\n          throw e;\n        }\n      }\n    }\n\n    // Temporarily add the css rules to the main svg.\n    const svgStyle = svgSelection.append('style');\n    svgStyle.text(stylesText);\n\n    // Temporarily remove the zoom/pan transform from the main svg since we\n    // want the minimap to show a zoomed-out and centered view.\n    const zoomGSelection = select(this.zoomG);\n    const zoomTransform = zoomGSelection.attr('transform');\n    zoomGSelection.attr('transform', null);\n\n    // Since we add padding, account for that here.\n    sceneSize.height += this.labelPadding * 2;\n    sceneSize.width += this.labelPadding * 2;\n\n    // Temporarily assign an explicit width/height to the main svg, since\n    // it doesn't have one (uses flex-box), but we need it for the canvas\n    // to work.\n    svgSelection.attr('width', sceneSize.width).attr('height', sceneSize.height);\n\n    // Since the content inside the svg changed (e.g. a node was expanded),\n    // the aspect ratio have also changed. Thus, we need to update the scale\n    // factor of the minimap. The scale factor is determined such that both\n    // the width and height of the minimap are <= maximum specified w/h.\n    this.scaleMinimap = this.maxWidth / Math.max(sceneSize.width, sceneSize.height);\n    this.minimapSize = {\n      width: sceneSize.width * this.scaleMinimap,\n      height: sceneSize.height * this.scaleMinimap\n    };\n\n    const minimapOffset = this.minimapOffset();\n\n    // Update the size of the minimap's svg, the buffer canvas and the\n    // viewpoint rect.\n    select(this.minimapSvg).attr(this.minimapSize as NzSafeAny);\n    select(this.canvasBuffer).attr(this.minimapSize as NzSafeAny);\n\n    if (this.translate != null && this.zoom != null) {\n      // Update the viewpoint rectangle shape since the aspect ratio of the\n      // map has changed.\n      requestAnimationFrame(() => this.zoom());\n    }\n\n    // Serialize the main svg to a string which will be used as the rendering\n    // content for the canvas.\n    const svgXml = new XMLSerializer().serializeToString(this.svg);\n\n    // Now that the svg is serialized for rendering, remove the temporarily\n    // assigned styles, explicit width and height and bring back the pan/zoom\n    // transform.\n    svgStyle.remove();\n    svgSelection.attr('width', '100%').attr('height', '100%');\n\n    zoomGSelection.attr('transform', zoomTransform);\n\n    const image = new Image();\n    image.onload = () => {\n      // Draw the svg content onto the buffer canvas.\n      const context = this.canvasBuffer.getContext('2d');\n      context!.clearRect(0, 0, this.canvasBuffer.width, this.canvasBuffer.height);\n\n      context!.drawImage(image, minimapOffset.x, minimapOffset.y, this.minimapSize.width, this.minimapSize.height);\n      requestAnimationFrame(() => {\n        // Hide the old canvas and show the new buffer canvas.\n        select(this.canvasBuffer).style('display', 'block');\n        select(this.canvas).style('display', 'none');\n        // Swap the two canvases.\n        [this.canvas, this.canvasBuffer] = [this.canvasBuffer, this.canvas];\n      });\n    };\n    image.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgXml);\n  }\n\n  /**\n   * Handles changes in zooming/panning. Should be called from the main svg\n   * to notify that a zoom/pan was performed and this minimap will update it's\n   * viewpoint rectangle.\n   * @param transform\n   */\n  zoom(transform?: ZoomTransform | NzZoomTransform): void {\n    if (this.scaleMinimap == null) {\n      // Scene is not ready yet.\n      return;\n    }\n    // Update the new translate and scale params, only if specified.\n    if (transform) {\n      this.translate = [transform.x, transform.y];\n      this.scaleMain = transform.k;\n    }\n\n    // Update the location of the viewpoint rectangle.\n    const svgRect = this.svg.getBoundingClientRect();\n    const minimapOffset = this.minimapOffset();\n    const viewpointSelection = select(this.viewpoint);\n    this.viewpointCoord.x = (-this.translate[0] * this.scaleMinimap) / this.scaleMain;\n    this.viewpointCoord.y = (-this.translate[1] * this.scaleMinimap) / this.scaleMain;\n    const viewpointWidth = (svgRect.width * this.scaleMinimap) / this.scaleMain;\n    const viewpointHeight = (svgRect.height * this.scaleMinimap) / this.scaleMain;\n    viewpointSelection\n      .attr('x', this.viewpointCoord.x + minimapOffset.x)\n      .attr('y', this.viewpointCoord.y + minimapOffset.y)\n      .attr('width', viewpointWidth)\n      .attr('height', viewpointHeight);\n    // Show/hide the minimap depending on the viewpoint area as fraction of the\n    // whole minimap.\n    const mapWidth = this.minimapSize.width;\n    const mapHeight = this.minimapSize.height;\n    const x = this.viewpointCoord.x;\n    const y = this.viewpointCoord.y;\n    const w = Math.min(Math.max(0, x + viewpointWidth), mapWidth) - Math.min(Math.max(0, x), mapWidth);\n    const h = Math.min(Math.max(0, y + viewpointHeight), mapHeight) - Math.min(Math.max(0, y), mapHeight);\n    const fracIntersect = (w * h) / (mapWidth * mapHeight);\n    if (fracIntersect < FRAC_VIEWPOINT_AREA) {\n      this.minimap.classList.remove('hidden');\n    } else {\n      this.minimap.classList.add('hidden');\n    }\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { ChangeDetectionStrategy, Component, ElementRef, OnInit } from '@angular/core';\nimport { ZoomBehavior } from 'd3-zoom';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { Minimap } from './core/minimap';\nimport { NzZoomTransform, NZ_GRAPH_LAYOUT_SETTING } from './interface';\n\n@Component({\n  selector: 'nz-graph-minimap',\n  template: `\n    <svg>\n      <defs>\n        <filter id=\"minimapDropShadow\" x=\"-20%\" y=\"-20%\" width=\"150%\" height=\"150%\">\n          <feOffset result=\"offOut\" in=\"SourceGraphic\" dx=\"1\" dy=\"1\"></feOffset>\n          <feColorMatrix\n            result=\"matrixOut\"\n            in=\"offOut\"\n            type=\"matrix\"\n            values=\"0.1 0 0 0 0 0 0.1 0 0 0 0 0 0.1 0 0 0 0 0 0.5 0\"\n          ></feColorMatrix>\n          <feGaussianBlur result=\"blurOut\" in=\"matrixOut\" stdDeviation=\"2\"></feGaussianBlur>\n          <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\"></feBlend>\n        </filter>\n      </defs>\n      <rect></rect>\n    </svg>\n    <canvas class=\"viewport\"></canvas>\n    <!-- Additional canvas to use as buffer to avoid flickering between updates -->\n    <canvas class=\"buffer\"></canvas>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[class.nz-graph-minimap]': 'true'\n  }\n})\nexport class NzGraphMinimapComponent implements OnInit {\n  minimap?: Minimap;\n  constructor(private elementRef: ElementRef<HTMLElement>) {}\n\n  ngOnInit(): void {}\n\n  init(containerEle: ElementRef, zoomBehavior: ZoomBehavior<NzSafeAny, NzSafeAny>): void {\n    const svgEle = containerEle.nativeElement.querySelector('svg');\n    const zoomEle = containerEle.nativeElement.querySelector('svg > g');\n    this.minimap = new Minimap(svgEle, zoomEle, zoomBehavior, this.elementRef.nativeElement, NZ_GRAPH_LAYOUT_SETTING.minimap.size, 0);\n  }\n\n  zoom(transform: NzZoomTransform): void {\n    if (this.minimap) {\n      this.minimap.zoom(transform);\n    }\n  }\n\n  update(): void {\n    if (this.minimap) {\n      this.minimap.update();\n    }\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { animate, AnimationBuilder, AnimationFactory, AnimationPlayer, group, query, style } from '@angular/animations';\nimport { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2, TemplateRef } from '@angular/core';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport { Observable, Subject } from 'rxjs';\nimport { NzGraphGroupNode, NzGraphNode } from './interface';\n\ninterface Info {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n@Component({\n  selector: '[nz-graph-node]',\n  template: `\n    <svg:g [attr.width]=\"node.width\" [attr.height]=\"node.height\">\n      <ng-container\n        *ngIf=\"customTemplate\"\n        [ngTemplateOutlet]=\"customTemplate\"\n        [ngTemplateOutletContext]=\"{ $implicit: node }\"\n      ></ng-container>\n      <ng-container *ngIf=\"!customTemplate\">\n        <svg:rect class=\"nz-graph-node-rect\" [attr.width]=\"node.width\" [attr.height]=\"node.height\"></svg:rect>\n        <svg:text x=\"10\" y=\"20\">{{ node.id || node.name }}</svg:text>\n      </ng-container>\n    </svg:g>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  host: {\n    '[id]': 'node.id || node.name',\n    '[class.nz-graph-node-expanded]': 'node.expanded',\n    '[class.nz-graph-group-node]': 'node.type===0',\n    '[class.nz-graph-base-node]': 'node.type===1',\n    '(click)': 'triggerClick($event)'\n  }\n})\nexport class NzGraphNodeComponent {\n  @Input() node!: NzGraphNode | NzGraphGroupNode;\n  @Input() @InputBoolean() noAnimation?: boolean;\n  @Input() customTemplate?: TemplateRef<{\n    $implicit: NzGraphNode | NzGraphGroupNode;\n  }>;\n\n  @Output() readonly nodeClick: EventEmitter<NzGraphNode | NzGraphGroupNode> = new EventEmitter();\n\n  triggerClick(event: MouseEvent): void {\n    event.preventDefault();\n    this.nodeClick.emit(this.node);\n  }\n\n  animationInfo: Info | null = null;\n  initialState = true;\n\n  private animationPlayer: AnimationPlayer | null = null;\n\n  constructor(private el: ElementRef, private builder: AnimationBuilder, private renderer2: Renderer2) {}\n\n  makeAnimation(): Observable<void> {\n    const cur = this.getAnimationInfo();\n    if (this.animationPlayer) {\n      this.animationPlayer.destroy();\n    }\n    let animationFactory: AnimationFactory;\n    const pre = { ...this.animationInfo } as Info;\n\n    if (this.initialState) {\n      animationFactory = this.builder.build([\n        style({ transform: `translate(${cur.x}px, ${cur.y}px)` }),\n        query('g', [\n          style({\n            width: `${cur.width}px`,\n            height: `${cur.height}px`\n          })\n        ])\n      ]);\n      this.initialState = false;\n    } else {\n      animationFactory = this.builder.build([\n        style({ transform: `translate(${pre!.x}px, ${pre!.y}px)` }),\n        query('g', [\n          style({\n            width: `${pre!.width}px`,\n            height: `${pre!.height}px`\n          })\n        ]),\n        group([\n          query('g', [\n            animate(\n              '150ms ease-out',\n              style({\n                width: `${cur.width}px`,\n                height: `${cur.height}px`\n              })\n            )\n          ]),\n          animate('150ms ease-out', style({ transform: `translate(${cur.x}px, ${cur.y}px)` }))\n        ])\n      ]);\n    }\n    this.animationInfo = cur;\n    this.animationPlayer = animationFactory.create(this.el.nativeElement);\n    this.animationPlayer.play();\n    const done$ = new Subject<void>();\n    this.animationPlayer.onDone(() => {\n      // Need this for canvas for now.\n      this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);\n      done$.next();\n      done$.complete();\n    });\n    return done$.asObservable();\n  }\n\n  makeNoAnimation(): void {\n    const cur = this.getAnimationInfo();\n    // Need this for canvas for now.\n    this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);\n  }\n\n  getAnimationInfo(): Info {\n    const { x, y } = this.nodeTransform();\n    return {\n      width: this.node.width,\n      height: this.node.height,\n      x,\n      y\n    };\n  }\n\n  nodeTransform(): { x: number; y: number } {\n    const x = this.computeCXPositionOfNodeShape() - this.node.width / 2;\n    const y = this.node.y - this.node.height / 2;\n    return { x, y };\n  }\n\n  computeCXPositionOfNodeShape(): number {\n    if ((this.node as NzGraphGroupNode).expanded) {\n      return this.node.x;\n    }\n    return this.node.x - this.node.width / 2 + this.node.coreBox.width / 2;\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[nzGraphNode]',\n  exportAs: 'nzGraphNode'\n})\nexport class NzGraphNodeDirective {}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { NzZoomTransform } from '../interface';\n\n/**\n * Calculate position and scale\n * @param containerEle\n * @param targetEle\n * @param scale: if scale is set, skip calculate scale value\n */\nexport const calculateTransform = (containerEle: SVGSVGElement, targetEle: SVGGElement, scale?: number): NzZoomTransform | null => {\n  const containerEleSize = containerEle.getBoundingClientRect();\n  const targetEleSize = targetEle.getBBox();\n  if (!targetEleSize.width) {\n    // There is no g element anymore.\n    return null;\n  }\n\n  // TODO\n  // leave some place when re-scale\n  const scaleUnit = (containerEleSize.width - 48) / containerEleSize.width;\n  const k = scale || Math.min(containerEleSize.width / targetEleSize.width, containerEleSize.height / targetEleSize.height, 1) * scaleUnit;\n  const x = (containerEleSize.width - targetEleSize.width * k) / 2;\n  const y = (containerEleSize.height - targetEleSize.height * k) / 2;\n  return {\n    x,\n    y,\n    k\n  };\n};\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { AfterViewInit, ChangeDetectorRef, Directive, ElementRef, EventEmitter, Input, OnDestroy, Output } from '@angular/core';\nimport { select, Selection } from 'd3-selection';\nimport { transition as d3Transition } from 'd3-transition';\nimport { zoom, ZoomBehavior, zoomIdentity, zoomTransform } from 'd3-zoom';\nimport { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { Subject } from 'rxjs';\nimport { calculateTransform } from './core/utils';\nimport { NzZoomTransform, RelativePositionInfo } from './interface';\nSelection.bind('transition', d3Transition);\n\n@Directive({\n  selector: '[nz-graph-zoom]'\n})\nexport class NzGraphZoomDirective implements OnDestroy, AfterViewInit {\n  @Input() nzZoom?: number;\n  @Input() nzMinZoom = 0.1;\n  @Input() nzMaxZoom = 10;\n\n  @Output() readonly nzTransformEvent: EventEmitter<NzZoomTransform> = new EventEmitter();\n  @Output() readonly nzZoomChange: EventEmitter<number> = new EventEmitter();\n\n  svgSelection!: Selection<NzSafeAny, NzSafeAny, NzSafeAny, NzSafeAny>;\n  zoomBehavior!: ZoomBehavior<NzSafeAny, NzSafeAny>;\n\n  // TODO\n  // Support svg element only now\n  svgElement!: SVGSVGElement;\n  gZoomElement!: SVGGElement;\n\n  private destroy$ = new Subject<void>();\n\n  constructor(private element: ElementRef, private cdr: ChangeDetectorRef) {}\n\n  ngAfterViewInit(): void {\n    this.bind();\n  }\n\n  ngOnDestroy(): void {\n    this.unbind();\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n\n  bind(): void {\n    this.svgElement = this.element.nativeElement.querySelector('svg') as SVGSVGElement;\n    this.gZoomElement = this.element.nativeElement.querySelector('svg > g') as SVGGElement;\n    const { width, height } = this.element.nativeElement.getBoundingClientRect();\n    this.svgSelection = select(this.svgElement);\n    this.zoomBehavior = zoom()\n      .extent([\n        [0, 0],\n        [width, height]\n      ])\n      .scaleExtent([this.nzMinZoom, this.nzMaxZoom])\n      .on('zoom', e => {\n        this.zoomed(e);\n      });\n    this.svgSelection.call(this.zoomBehavior, zoomIdentity.translate(0, 0).scale(this.nzZoom || 1));\n    // Init with nzZoom\n    this.reScale(0, this.nzZoom);\n  }\n\n  unbind(): void {\n    // Destroy listener\n    this.svgSelection?.interrupt().selectAll('*').interrupt();\n    if (this.zoomBehavior) {\n      this.zoomBehavior.on('end', null).on('zoom', null);\n    }\n  }\n\n  // Methods\n  fitCenter(duration: number = 0): void {\n    this.reScale(duration);\n  }\n\n  focus(id: NzSafeAny, duration: number = 0): void {\n    // Make sure this node is under SVG container\n    if (!this.svgElement.getElementById(`${id}`)) {\n      return;\n    }\n\n    const node = this.svgElement.getElementById(`${id}`) as SVGGElement;\n    const svgRect = this.svgElement.getBoundingClientRect();\n    const position = this.getRelativePositionInfo(node);\n    const svgTransform = zoomTransform(this.svgElement);\n\n    const centerX = (position.topLeft.x + position.bottomRight.x) / 2;\n    const centerY = (position.topLeft.y + position.bottomRight.y) / 2;\n    const dx = svgRect.left + svgRect.width / 2 - centerX;\n    const dy = svgRect.top + svgRect.height / 2 - centerY;\n\n    this.svgSelection\n      .transition()\n      .duration(duration)\n      .call(this.zoomBehavior.translateBy, dx / svgTransform.k, dy / svgTransform.k);\n  }\n\n  /**\n   * Handle zoom event\n   * @param transform\n   */\n  private zoomed({ transform }: NzSafeAny): void {\n    const { x, y, k } = transform;\n    // Update g element transform\n    (this.gZoomElement as SVGGElement).setAttribute('transform', `translate(${x}, ${y})scale(${k})`);\n    this.nzZoom = k;\n    this.nzZoomChange.emit(this.nzZoom);\n    this.nzTransformEvent.emit(transform);\n    this.cdr.markForCheck();\n  }\n\n  /**\n   * Scale with zoom and duration\n   * @param duration\n   * @param scale\n   * @private\n   */\n  private reScale(duration: number, scale?: number): void {\n    const transform = calculateTransform(this.svgElement, this.gZoomElement, scale);\n    if (!transform) {\n      return;\n    }\n    const { x, y, k } = transform;\n    const zTransform = zoomIdentity.translate(x, y).scale(Math.max(k, this.nzMinZoom));\n    this.svgSelection\n      .transition()\n      .duration(duration)\n      .call(this.zoomBehavior.transform, zTransform)\n      .on('end.fitted', () => {\n        this.zoomBehavior.on('end.fitted', null);\n      });\n  }\n\n  private getRelativePositionInfo(node: SVGGElement): RelativePositionInfo {\n    const nodeBox = node.getBBox();\n    const nodeCtm = node.getScreenCTM();\n    let pointTL = this.svgElement.createSVGPoint();\n    let pointBR = this.svgElement.createSVGPoint();\n\n    pointTL.x = nodeBox.x;\n    pointTL.y = nodeBox.y;\n    pointBR.x = nodeBox.x + nodeBox.width;\n    pointBR.y = nodeBox.y + nodeBox.height;\n    pointTL = pointTL.matrixTransform(nodeCtm!);\n    pointBR = pointBR.matrixTransform(nodeCtm!);\n    return {\n      topLeft: pointTL,\n      bottomRight: pointBR\n    };\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport {\n  AfterContentChecked,\n  AfterViewInit,\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ElementRef,\n  EventEmitter,\n  Host,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  QueryList,\n  SimpleChanges,\n  TemplateRef,\n  ViewChildren,\n  ViewEncapsulation\n} from '@angular/core';\nimport { buildGraph } from '@nx-component/hierarchy-graph';\nimport { NzNoAnimationDirective } from 'ng-zorro-antd/core/no-animation';\nimport { cancelRequestAnimationFrame } from 'ng-zorro-antd/core/polyfill';\nimport { BooleanInput, NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport { forkJoin, Observable, ReplaySubject, Subject, Subscription } from 'rxjs';\nimport { finalize, skip, take, takeUntil } from 'rxjs/operators';\nimport { calculateTransform } from './core/utils';\nimport { NzGraphData } from './data-source/graph-data-source';\nimport { NzGraphEdgeDirective } from './graph-edge.directive';\nimport { NzGraphNodeComponent } from './graph-node.component';\nimport { NzGraphNodeDirective } from './graph-node.directive';\nimport {\n  NzGraphDataDef,\n  NzGraphEdge,\n  NzGraphEdgeDef,\n  NzGraphGroupNode,\n  NzGraphLayoutSetting,\n  NzGraphNode,\n  NzGraphNodeDef,\n  NzGraphOption,\n  NzLayoutSetting,\n  NzRankDirection,\n  nzTypeDefinition,\n  NZ_GRAPH_LAYOUT_SETTING\n} from './interface';\n\n/** Checks whether an object is a data source. */\nexport function isDataSource(value: NzSafeAny): value is NzGraphData {\n  // Check if the value is a DataSource by observing if it has a connect function. Cannot\n  // be checked as an `instanceof DataSource` since people could create their own sources\n  // that match the interface, but don't extend DataSource.\n  return value && typeof value.connect === 'function';\n}\n\n@Component({\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  encapsulation: ViewEncapsulation.None,\n  selector: 'nz-graph',\n  exportAs: 'nzGraph',\n  template: `\n    <ng-content></ng-content>\n    <svg width=\"100%\" height=\"100%\">\n      <svg:defs nz-graph-defs></svg:defs>\n      <svg:g [attr.transform]=\"transformStyle\">\n        <ng-container\n          [ngTemplateOutlet]=\"groupTemplate\"\n          [ngTemplateOutletContext]=\"{ renderNode: renderInfo, type: 'root' }\"\n        ></ng-container>\n      </svg:g>\n    </svg>\n\n    <ng-template #groupTemplate let-renderNode=\"renderNode\" let-type=\"type\">\n      <svg:g [attr.transform]=\"type === 'sub' ? subGraphTransform(renderNode) : null\">\n        <svg:g class=\"core\" [attr.transform]=\"coreTransform(renderNode)\">\n          <svg:g class=\"nz-graph-edges\">\n            <ng-container *ngFor=\"let edge of renderNode.edges; trackBy: edgeTrackByFun\">\n              <g class=\"nz-graph-edge\" nz-graph-edge [edge]=\"edge\" [customTemplate]=\"customGraphEdgeTemplate\"></g>\n            </ng-container>\n          </svg:g>\n\n          <svg:g class=\"nz-graph-nodes\">\n            <ng-container *ngFor=\"let node of typedNodes(renderNode.nodes); trackBy: nodeTrackByFun\">\n              <g\n                *ngIf=\"node.type !== 2\"\n                class=\"nz-graph-node\"\n                nz-graph-node\n                [node]=\"node\"\n                [customTemplate]=\"customGraphNodeTemplate\"\n                (nodeClick)=\"clickNode($event)\"\n              ></g>\n\n              <ng-container\n                *ngIf=\"node.expanded\"\n                [ngTemplateOutlet]=\"groupTemplate\"\n                [ngTemplateOutletContext]=\"{ renderNode: node, type: 'sub' }\"\n              ></ng-container>\n            </ng-container>\n          </svg:g>\n        </svg:g>\n      </svg:g>\n    </ng-template>\n  `,\n  host: {\n    '[class.nz-graph]': 'true',\n    '[class.nz-graph-auto-size]': 'nzAutoSize'\n  }\n})\nexport class NzGraphComponent implements OnInit, OnChanges, AfterViewInit, AfterContentChecked, OnDestroy {\n  static ngAcceptInputType_nzAutoSize: BooleanInput;\n\n  @ViewChildren(NzGraphNodeComponent, { read: ElementRef }) listOfNodeElement!: QueryList<ElementRef>;\n  @ViewChildren(NzGraphNodeComponent) listOfNodeComponent!: QueryList<NzGraphNodeComponent>;\n\n  @ContentChild(NzGraphNodeDirective, { static: true, read: TemplateRef }) customGraphNodeTemplate?: TemplateRef<{\n    $implicit: NzGraphNode | NzGraphGroupNode;\n  }>;\n  @ContentChild(NzGraphEdgeDirective, { static: true, read: TemplateRef }) customGraphEdgeTemplate?: TemplateRef<{\n    $implicit: NzGraphEdge;\n  }>;\n  /**\n   * Provides a stream containing the latest data array to render.\n   * Data source can be an observable of NzGraphData, or a NzGraphData to render.\n   */\n  @Input() nzGraphData!: NzGraphData;\n  @Input() nzRankDirection: NzRankDirection = 'LR';\n  @Input() nzGraphLayoutSettings?: NzGraphLayoutSetting;\n  @Input() @InputBoolean() nzAutoSize = false;\n\n  @Output() readonly nzGraphInitialized = new EventEmitter<NzGraphComponent>();\n  @Output() readonly nzGraphRendered = new EventEmitter<NzGraphComponent>();\n  @Output() readonly nzNodeClick: EventEmitter<NzGraphNode | NzGraphGroupNode> = new EventEmitter();\n\n  requestId: number = -1;\n  transformStyle = '';\n  graphRenderedSubject$ = new ReplaySubject<void>(1);\n  renderInfo: NzGraphGroupNode = { labelHeight: 0 } as NzGraphGroupNode;\n  mapOfNodeAttr: { [key: string]: NzGraphNodeDef } = {};\n  mapOfEdgeAttr: { [key: string]: NzGraphEdgeDef } = {};\n\n  public readonly typedNodes = nzTypeDefinition<Array<NzGraphNode | NzGraphGroupNode>>();\n  private dataSource?: NzGraphData;\n  private layoutSetting: NzLayoutSetting = NZ_GRAPH_LAYOUT_SETTING;\n  /** Data subscription */\n  private _dataSubscription?: Subscription | null;\n  private destroy$ = new Subject<void>();\n\n  nodeTrackByFun = (_: number, node: NzGraphNode | NzGraphGroupNode) => node.name;\n  edgeTrackByFun = (_: number, edge: NzGraphEdge) => `${edge.v}-${edge.w}`;\n\n  subGraphTransform = (node: NzGraphGroupNode) => {\n    const x = node.x - node.coreBox.width / 2.0;\n    const y = node.y - node.height / 2.0 + node.paddingTop / 2.0;\n    return `translate(${x}, ${y})`;\n  };\n\n  coreTransform = (node: NzGraphGroupNode) => {\n    return `translate(0, ${node.parentNodeName ? node.labelHeight : 0})`;\n  };\n\n  constructor(\n    private cdr: ChangeDetectorRef,\n    private ngZone: NgZone,\n    private elementRef: ElementRef,\n    @Host() @Optional() public noAnimation?: NzNoAnimationDirective\n  ) {}\n\n  ngOnInit(): void {\n    this.graphRenderedSubject$.pipe(skip(this.nzAutoSize ? 1 : 0), take(1), takeUntil(this.destroy$)).subscribe(() => {\n      this.fitCenter();\n      this.nzGraphInitialized.emit(this);\n    });\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    const { nzAutoFit, nzRankDirection, nzGraphData, nzGraphLayoutSettings } = changes;\n    if (nzGraphLayoutSettings) {\n      Object.assign(this.layoutSetting, this.nzGraphLayoutSettings || {});\n    }\n\n    if (nzGraphData) {\n      if (this.dataSource !== this.nzGraphData) {\n        this._switchDataSource(this.nzGraphData);\n      }\n    }\n\n    if ((nzAutoFit && !nzAutoFit.firstChange) || (nzRankDirection && !nzRankDirection.firstChange)) {\n      // Render graph\n      if (this.dataSource!.dataSource) {\n        this.drawGraph(this.dataSource!.dataSource, {\n          rankDirection: this.nzRankDirection,\n          expanded: this.dataSource!.expansionModel.selected || []\n        }).then();\n      }\n    }\n\n    this.cdr.markForCheck();\n  }\n\n  ngAfterViewInit(): void {}\n\n  ngAfterContentChecked(): void {\n    if (this.dataSource && !this._dataSubscription) {\n      this.observeRenderChanges();\n    }\n  }\n\n  ngOnDestroy(): void {\n    this.destroy$.next();\n    this.destroy$.complete();\n\n    if (this.dataSource && typeof this.dataSource.disconnect === 'function') {\n      this.dataSource.disconnect();\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n    cancelRequestAnimationFrame(this.requestId);\n  }\n\n  /**\n   * Emit event\n   */\n  clickNode(node: NzGraphNode | NzGraphGroupNode): void {\n    this.nzNodeClick.emit(node);\n  }\n\n  /**\n   * Move graph to center and scale automatically\n   */\n  fitCenter(): void {\n    const { x, y, k } = calculateTransform(\n      this.elementRef.nativeElement.querySelector('svg'),\n      this.elementRef.nativeElement.querySelector('svg > g')\n    )!;\n    this.transformStyle = `translate(${x}, ${y})scale(${k})`;\n    this.cdr.markForCheck();\n  }\n\n  /**\n   * re-Draw graph\n   * @param data\n   * @param options\n   * @param needResize\n   */\n  drawGraph(data: NzGraphDataDef, options: NzGraphOption, needResize: boolean = false): Promise<void> {\n    return new Promise(resolve => {\n      this.requestId = requestAnimationFrame(() => {\n        const renderInfo = this.buildGraphInfo(data, options);\n        // TODO\n        // Need better performance\n        this.renderInfo = renderInfo;\n        this.cdr.markForCheck();\n        this.drawNodes(!this.noAnimation?.nzNoAnimation).then(() => {\n          // Update element\n          this.cdr.markForCheck();\n          this.graphRenderedSubject$.next();\n          this.nzGraphRendered.emit(this);\n        });\n\n        if (needResize) {\n          this.resizeNodeSize().then(() => {\n            const dataSource: NzGraphDataDef = this.dataSource!.dataSource!;\n            return this.drawGraph(dataSource, options, false);\n          });\n        } else {\n          resolve();\n        }\n      });\n      this.cdr.markForCheck();\n    });\n  }\n\n  /**\n   * Redraw all nodes\n   * @param animate\n   */\n  drawNodes(animate: boolean = true): Promise<void> {\n    return new Promise(resolve => {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        if (animate) {\n          this.makeNodesAnimation().subscribe(() => {\n            resolve();\n          });\n        } else {\n          this.listOfNodeComponent.map(node => {\n            node.makeNoAnimation();\n          });\n          resolve();\n        }\n      });\n    });\n  }\n\n  private resizeNodeSize(): Promise<void> {\n    return new Promise(resolve => {\n      this.ngZone.onStable.pipe(take(1)).subscribe(() => {\n        const dataSource: NzGraphDataDef = this.dataSource!.dataSource!;\n        let scale = this.getScale();\n\n        this.listOfNodeElement.forEach(nodeEle => {\n          const contentEle = nodeEle.nativeElement;\n          if (contentEle) {\n            let width: number;\n            let height: number;\n            // Check if foreignObject is set\n            const clientRect = contentEle.querySelector('foreignObject > :first-child')?.getBoundingClientRect();\n            if (clientRect) {\n              width = clientRect.width;\n              height = clientRect.height;\n            } else {\n              const bBoxRect = contentEle.getBBox();\n              width = bBoxRect.width;\n              height = bBoxRect.height;\n              // getBBox will return actual value\n              scale = 1;\n            }\n            // Element id type is string\n            const node = dataSource.nodes.find(n => `${n.id}` === nodeEle.nativeElement.id);\n\n            if (node && width && height) {\n              node.height = height / scale;\n              node.width = width / scale;\n            }\n          }\n        });\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Switch to the provided data source by resetting the data and unsubscribing from the current\n   * render change subscription if one exists. If the data source is null, interpret this by\n   * clearing the node outlet. Otherwise start listening for new data.\n   */\n  private _switchDataSource(dataSource: NzGraphData): void {\n    if (this.dataSource && typeof this.dataSource.disconnect === 'function') {\n      this.nzGraphData.disconnect();\n    }\n\n    if (this._dataSubscription) {\n      this._dataSubscription.unsubscribe();\n      this._dataSubscription = null;\n    }\n\n    this.dataSource = dataSource;\n    this.observeRenderChanges();\n  }\n\n  /** Set up a subscription for the data provided by the data source. */\n  private observeRenderChanges(): void {\n    let dataStream: Observable<NzGraphDataDef> | undefined;\n    let graphOptions: NzGraphOption = {\n      rankDirection: this.nzRankDirection\n    };\n    if (isDataSource(this.dataSource)) {\n      dataStream = this.dataSource.connect();\n    }\n\n    if (dataStream) {\n      this._dataSubscription = dataStream.pipe(takeUntil(this.destroy$)).subscribe(data => {\n        graphOptions = {\n          rankDirection: this.nzRankDirection,\n          expanded: this.nzGraphData.expansionModel.selected\n        };\n        this.drawGraph(data, graphOptions, this.nzAutoSize).then(() => {\n          this.cdr.detectChanges();\n        });\n      });\n    } else {\n      throw Error(`A valid data source must be provided.`);\n    }\n  }\n\n  // TODO\n  // A better way?\n  private getScale(): number {\n    const transform = (this.elementRef.nativeElement.querySelector('svg > g') as SVGGElement)?.getAttribute('transform') || '';\n    // Get current scale\n    const regex = /scale\\(([0-9\\.]+)\\)/g;\n    const match = regex.exec(transform);\n    if (match && match[1]) {\n      return parseFloat(match[1]);\n    }\n    return 1;\n  }\n\n  /**\n   * Get renderInfo and prepare some data\n   * @param data\n   * @param options\n   * @private\n   */\n  private buildGraphInfo(data: NzGraphDataDef, options: NzGraphOption): NzGraphGroupNode {\n    this.parseInfo(data);\n    const renderInfo = buildGraph(data, options, this.layoutSetting) as NzGraphGroupNode;\n    const dig = (nodes: Array<NzGraphNode | NzGraphGroupNode>): void => {\n      nodes.forEach(node => {\n        if (node.type === 1 && this.mapOfNodeAttr.hasOwnProperty(node.name)) {\n          Object.assign(node, this.mapOfNodeAttr[node.name]);\n        } else if (node.type === 0) {\n          (node as NzGraphGroupNode).edges.forEach(edge => {\n            if (this.mapOfEdgeAttr.hasOwnProperty(`${edge.v}-${edge.w}`)) {\n              Object.assign(edge, this.mapOfEdgeAttr[`${edge.v}-${edge.w}`]);\n            }\n          });\n          dig(node.nodes);\n        }\n      });\n    };\n    dig(renderInfo.nodes);\n    // Assign data to edges of root graph\n    renderInfo.edges.forEach(edge => {\n      if (this.mapOfEdgeAttr.hasOwnProperty(`${edge.v}-${edge.w}`)) {\n        Object.assign(edge, this.mapOfEdgeAttr[`${edge.v}-${edge.w}`]);\n      }\n    });\n    return renderInfo;\n  }\n\n  /**\n   * Play with animation\n   * @private\n   */\n  private makeNodesAnimation(): Observable<void> {\n    return forkJoin(...this.listOfNodeComponent.map(node => node.makeAnimation())).pipe(\n      finalize(() => {\n        this.cdr.detectChanges();\n      })\n    );\n  }\n\n  private parseInfo(data: NzGraphDataDef): void {\n    data.nodes.forEach(n => {\n      this.mapOfNodeAttr[n.id] = n;\n    });\n    data.edges.forEach(e => {\n      this.mapOfEdgeAttr[`${e.v}-${e.w}`] = e;\n    });\n  }\n}\n","/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { NzNoAnimationModule } from 'ng-zorro-antd/core/no-animation';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport { NzSpinModule } from 'ng-zorro-antd/spin';\nimport { NzGraphDefsComponent } from './graph-defs.component';\nimport { NzGraphEdgeComponent } from './graph-edge.component';\nimport { NzGraphEdgeDirective } from './graph-edge.directive';\nimport { NzGraphMinimapComponent } from './graph-minimap.component';\nimport { NzGraphNodeComponent } from './graph-node.component';\nimport { NzGraphNodeDirective } from './graph-node.directive';\nimport { NzGraphZoomDirective } from './graph-zoom.directive';\nimport { NzGraphComponent } from './graph.component';\n\nconst COMPONENTS = [\n  NzGraphComponent,\n  NzGraphMinimapComponent,\n  NzGraphDefsComponent,\n  NzGraphNodeDirective,\n  NzGraphZoomDirective,\n  NzGraphNodeComponent,\n  NzGraphEdgeComponent,\n  NzGraphEdgeDirective\n];\n\n@NgModule({\n  declarations: [...COMPONENTS],\n  imports: [CommonModule, NzIconModule, NzSpinModule, NzNoAnimationModule],\n  exports: [...COMPONENTS]\n})\nexport class NzGraphModule {}\n"]}