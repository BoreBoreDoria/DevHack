{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","ng://@datorama/akita/lib/actions.ts","ng://@datorama/akita/lib/hasEntity.ts","ng://@datorama/akita/lib/isArray.ts","ng://@datorama/akita/lib/activeState.ts","ng://@datorama/akita/lib/addEntities.ts","ng://@datorama/akita/lib/isNil.ts","ng://@datorama/akita/lib/coerceArray.ts","ng://@datorama/akita/lib/arrayAdd.ts","ng://@datorama/akita/lib/isFunction.ts","ng://@datorama/akita/lib/isEmpty.ts","ng://@datorama/akita/lib/arrayFind.ts","ng://@datorama/akita/lib/isObject.ts","ng://@datorama/akita/lib/arrayToggle.ts","ng://@datorama/akita/lib/arrayUpdate.ts","ng://@datorama/akita/lib/defaultIDKey.ts","ng://@datorama/akita/lib/config.ts","ng://@datorama/akita/lib/isDefined.ts","ng://@datorama/akita/lib/dispatchers.ts","ng://@datorama/akita/lib/root.ts","ng://@datorama/akita/lib/stores.ts","ng://@datorama/akita/lib/capitalize.ts","ng://@datorama/akita/lib/devtools.ts","ng://@datorama/akita/lib/sort.ts","ng://@datorama/akita/lib/entityActions.ts","ng://@datorama/akita/lib/entitiesToArray.ts","ng://@datorama/akita/lib/entitiesToMap.ts","ng://@datorama/akita/lib/entityService.ts","ng://@datorama/akita/lib/env.ts","ng://@datorama/akita/lib/getActiveEntities.ts","ng://@datorama/akita/lib/getInitialEntitiesState.ts","ng://@datorama/akita/lib/isUndefined.ts","ng://@datorama/akita/lib/removeEntities.ts","ng://@datorama/akita/lib/toEntitiesObject.ts","ng://@datorama/akita/lib/setEntities.ts","ng://@datorama/akita/lib/deepFreeze.ts","ng://@datorama/akita/lib/errors.ts","ng://@datorama/akita/lib/toBoolean.ts","ng://@datorama/akita/lib/isPlainObject.ts","ng://@datorama/akita/lib/transaction.ts","ng://@datorama/akita/lib/store.ts","ng://@datorama/akita/lib/updateEntities.ts","ng://@datorama/akita/lib/entityStore.ts","ng://@datorama/akita/lib/filterNil.ts","ng://@datorama/akita/lib/isString.ts","ng://@datorama/akita/lib/query.ts","ng://@datorama/akita/lib/compareKeys.ts","ng://@datorama/akita/lib/getEntity.ts","ng://@datorama/akita/lib/sortByOptions.ts","ng://@datorama/akita/lib/queryEntity.ts","ng://@datorama/akita/lib/mapSkipUndefined.ts","ng://@datorama/akita/lib/getValueByString.ts","ng://@datorama/akita/lib/setValueByString.ts","ng://@datorama/akita/lib/persistState.ts","ng://@datorama/akita/lib/plugins/plugin.ts","ng://@datorama/akita/lib/plugins/dirtyCheck/dirtyCheckPlugin.ts","ng://@datorama/akita/lib/plugins/entityCollectionPlugin.ts","ng://@datorama/akita/lib/plugins/dirtyCheck/entityDirtyCheckPlugin.ts","ng://@datorama/akita/lib/plugins/paginator/paginatorPlugin.ts","ng://@datorama/akita/lib/plugins/persistForm/persistNgFormPlugin.ts","ng://@datorama/akita/lib/plugins/stateHistory/stateHistoryPlugin.ts","ng://@datorama/akita/lib/plugins/stateHistory/entityStateHistoryPlugin.ts","ng://@datorama/akita/lib/runStoreAction.ts","ng://@datorama/akita/lib/snapshotManager.ts","ng://@datorama/akita/lib/trackIdChanges.ts","ng://@datorama/akita/lib/queryConfig.ts","ng://@datorama/akita/lib/storeConfig.ts","ng://@datorama/akita/lib/arrayRemove.ts","ng://@datorama/akita/lib/not.ts","ng://@datorama/akita/lib/arrayUpsert.ts","ng://@datorama/akita/lib/cacheable.ts","ng://@datorama/akita/lib/combineQueries.ts","ng://@datorama/akita/lib/fp.ts","ng://@datorama/akita/lib/guid.ts","ng://@datorama/akita/lib/isNumber.ts","ng://@datorama/akita/lib/resetStores.ts","ng://@datorama/akita/lib/setLoading.ts","ng://@datorama/akita/lib/setLoadingAndError.ts","ng://@datorama/akita/lib/toEntitiesIds.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__rest","e","indexOf","getOwnPropertySymbols","propertyIsEnumerable","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","ar","push","error","__spread","concat","currentAction","type","entityIds","skip","payload","customActionActive","resetCustomAction","logAction","setAction","setSkipAction","action","propertyKey","descriptor","originalMethod","args","_i","hasEntity","entities","id","isArray","hasActiveState","state","isMultiActiveState","active","resolveActiveEntity","_a","ids","getExitingActives","currentActivesIds","newIds","filtered","filter","addEntities","idKey","_c","options","preAddEntity","newEntities","hasNewEntities","entities_1","entities_1_1","entity","current","entityId","prepend","unshift","newState","isNil","v","coerceArray","arrayAdd","arr","newEntity","toArr","isFunction","isEmpty","find","collection","idsOrPredicate","result","collection_1","collection_1_1","toSet","reduce","acc","add","Set","collection_2","collection_2_1","has","distinctUntilArrayItemChanged","distinctUntilChanged","prevCollection","currentCollection","hasChange","first","second","some","currentItem","undefined","prevItem","isObject","byKey","prop","a","arrayUpdate","predicateOrIds","obj","condition","ids_1","item","includes","map","index","CONFIG","resettable","ttl","producerFn","getAkitaConfig","isDefined","val","$$deleteStore","Subject","$$addStore","ReplaySubject","$$updateStore","dispatchDeleted","storeName","dispatchAdded","dispatchUpdate","isBrowser","window","isNotBrowser","hasLocalStorage","localStorage","__stores__","__queries__","capitalize","charAt","toUpperCase","slice","$$stores","$$queries","Order","EntityActions","subs","compareValues","order","ASC","varA","varB","comparison","DESC","entitiesToArray","filterBy","limitTo","sortBy","sortByOrder","every","fn","_sortBy_1","sort","Math","min","entitiesToMap","hasLimit","count","length_1","finalLength","isDev","__DEV__","getActiveEntities","idOrOptions","currentActive","wrap","currentIdIndex","prev","isFirst","isLast","getInitialEntitiesState","loading","isUndefined","removeEntities","removeAllEntities","_d","toEntitiesObject","isEntityState","applyMiddleware","mapped","_b","keys","setEntities","isNativePreAdd","resolve","isNaN","Number","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","isFrozen","AkitaError","_super","message","Error","toBoolean","isPlainObject","name","transactionFinished","transactionInProcess","BehaviorSubject","transactionManager","activeTransactions","batchTransaction","startBatch","isTransactionInProcess","endBatch","complete","commit","asObservable","of","applyTransaction","thisArg","transaction","_this","Store","initialState","inTransaction","cache","onInit","setLoading","_value","_setState","setHasCache","hasCache","restartTTL","ttlConfig","getCacheTTL","clearTimeout","setTimeout","getValue","storeValue","setError","_select","project","store","pipe","snapshot","_cache","config","deepFreezeFn","_dispatchAction","_newState","subscribe","handleTransaction","dispatch","reset","isResettable","_initialState","console","warn","update","stateOrCallback","currentState","_producerFn","withHook","akitaPreUpdate","resolved","updateStoreConfig","newOptions","_","nextState","ngOnDestroy","destroy","hmrEnabled","className","watchTransaction","cacheConfig","updateEntities","idToUpdate","newStateOrFn","preUpdateEntity","onEntityIdChanges","updatedEntities","isUpdatingIdKey","ids_1_1","oldEntity","isIdChanged","merged","updatedIds","stateEntities","id_1","_e","EntityStore","entityActions","entityIdChanges","set","akitaPreAddEntity","activeId","hasInitialUIState","handleUICreation","data","Add","idsOrFnOrState","entityIdChanged","akitaPreUpdateEntity","oldId","newId","pending","Update","upsert","onCreate","toArray","predicate","isUpdate","baseClass","isClassBased","updateIds","newStateObj","withId","upsertMany","addedIds","withPreCheckHook","akitaPreCheckEntity","nextId","hasUIStore","replace","replaced","toArray_1","toArray_1_1","move","from","to","splice","remove","idsOrFn","idPassed","handleUIRemove","Remove","updateActive","newStateOrCallback","setActive","_setActive","addActive","uniques","removeActive","currentId","toggleActive","filterExists","createUIStore","storeConfig","defaults","ui","EntityUIStore","nextEntity","uiEntities","isFunc","_akitaCreateEntityFn","createFn","T","setInitialEntityState","filterNilValue","isString","Query","__store__","select","mapFn","keysOrFuncs","prevState","currState","isFns","keyOrFunc","func","k","selectLoading","selectError","selectHasCache","getHasCache","getEntity","sortByOptions","QueryEntity","selectAll","asObject","getAll","selectMany","callbackFn","array","selectEntity","idOrPredicate","findEntityByPredicate","selectActiveId","getActiveId","selectActive","getActive","switchMap","selectCount","getCount","selectLast","selectAt","selectFirst","selectEntityAction","actionOrActions","selectEntityAction$","actions","projectOrIds","hasActive","isIdProvided","createUIQuery","EntityUIQuery","split","join","part","setValue","lastIndex","skipStorageUpdate","_persistStateInit","setSkipStorageUpdate","getSkipStorageUpdate","observify","asyncOrValue","then","isObservable","AkitaPlugin","query","resetFn","onReset","getQuery","getStore","isEntityBased","selectSource","property","withStoreName","getSource","updateStore","original","params","dirtyCheckDefaultParams","comparator","head","JSON","stringify","getNestedPath","nestedObj","path","DirtyCheckPlugin","_entityId","dirty","_reset","isDirty$","reset$","watchProperty","watchProp","currentValue","updateFn","setHead","_getHead","activate","updateDirtiness","isDirty","hasHead","getHead","subscription","unsubscribe","isPathDirty","currentPathValue","headPathValue","source","__akitaKey","combineLatest","isChange","compareTo","getWatchedValues","watched","EntityCollectionPlugin","Map","get","removeEntity","delete","createEntity","plugin","getIds","resolvedIds","rebase","len","beforeAdd","instantiatePlugin","afterAdd","beforeRemove","_ids","selectIds","forEachId","cb","EntityDirtyCheckPlugin","_someDirty","someDirty$","merge","auditTime","checkSomeDirty","someDirty","entitiesIds","entitiesIds_1","entitiesIds_1_1","paginatorDefaults","pagesControls","range","startWith","cacheTimeout","clearStoreWithCache","PaginatorPlugin","initial","clearCache","currentPage","pages","pagination","perPage","total","lastPage","isLoading$","delay","page","clearCacheSubscription","withControls","withRange","response","addPage","clearStore","clearPage","setPage","isPageActive","hasPage","nextPage","prevPage","setLastPage","setFirstPage","getPage","req","selectPage","refreshCurrentPage","getFrom","getTo","take","pageControls","ceil","generatePages","Paginator","PersistNgFormPlugin","factoryFnOrPath","debounceTime","formKey","emitEvent","arrControlFactory","builder","control","isRootKeys","isKeyBased","setForm","form","initialValue","stateKey","formArray","controls","cleanArray","insert","patchValue","removeAt","resolveInitialValue","formValue","root","factory_1","formChanges","valueChanges","StateHistoryPlugin","clear","history","past","present","future","skipUpdate","maxAge","_hasPast$","_hasFuture$","updateHasHistory","hasFutureSubject","hasFuture","hasPastSubject","hasPast","pairwise","shouldUpdate","undo","previous","redo","newFuture","jumpToPast","newPast","newPresent","jumpToFuture","jump","customUpdateFn","clearHistory","ignoreNext","EntityStateHistoryPlugin","StoreAction","EntityStoreAction","StoreActionMapping","EntityStoreActionMapping","AddEntities","SetEntities","UpdateEntities","RemoveEntities","UpsertEntities","UpsertManyEntities","storeClass","getStoreByName","getEntityStore","getEntityStoreByName","SnapshotManager","getStoresSnapshot","stores","setStoresSnapshot","mergedOptions","lazy","normalizedStores","parse","size","snapshotManager","TrackIdChanges","subscriber","currId","selectEntityIdChanges$","change","tap","ngZoneOrOptions","__REDUX_DEVTOOLS_EXTENSION__","run","shallow","storesWhitelist","devTools","connect","appState","isAllowed","send","normalize","msg","logTrace","group","trace","groupEnd","sortAlphabetically","sortedAppState","init","rootState_1","identifier","identifiers","filterFn","pred","newValue","compare","findIndex","oldValue","entityIsObject","request$","emitNext","EMPTY","observables","random","toString","parseFloat","enableInNonBrowser","storage","deserialize","serialize","include","persistOnDestroy","preStorageUpdate","preStoreUpdate","preStorageUpdateOperator","includeStores","selectStores","hasInclude","hasSelect","fns","selectFn","subscriptions","buffer","isLocalStorage","sessionStorage","hasSessionStorage","getItem","storageState","save","storeCache","setItem","_save","shift","Promise","setInitial","exclude","stores_1","stores_1_1","storeClassOrName","operation","bind","defer","finalize","err","lift"],"mappings":";;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,MAC3EN,EAAGC,IAGrB,SAASS,EAAUV,EAAGC,GAEzB,SAASU,IAAOC,KAAKC,YAAcb,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOY,OAAOb,IAAMU,EAAGJ,UAAYN,EAAEM,UAAW,IAAII,GAG5E,IAAII,EAAW,WAQlB,OAPAA,EAAWb,OAAOc,QAAU,SAAkBC,GAC1C,IAAK,IAAIC,EAAGC,EAAI,EAAGC,EAAIC,UAAUC,OAAQH,EAAIC,EAAGD,IAE5C,IAAK,IAAIb,KADTY,EAAIG,UAAUF,GACOjB,OAAOK,UAAUC,eAAeC,KAAKS,EAAGZ,KAAIW,EAAEX,GAAKY,EAAEZ,IAE9E,OAAOW,IAEKM,MAAMX,KAAMS,YAGzB,SAASG,EAAON,EAAGO,GACtB,IAAIR,EAAI,GACR,IAAK,IAAIX,KAAKY,EAAOhB,OAAOK,UAAUC,eAAeC,KAAKS,EAAGZ,IAAMmB,EAAEC,QAAQpB,GAAK,IAC9EW,EAAEX,GAAKY,EAAEZ,IACb,GAAS,MAALY,GAAqD,mBAAjChB,OAAOyB,sBACtB,CAAA,IAAIR,EAAI,EAAb,IAAgBb,EAAIJ,OAAOyB,sBAAsBT,GAAIC,EAAIb,EAAEgB,OAAQH,IAC3DM,EAAEC,QAAQpB,EAAEa,IAAM,GAAKjB,OAAOK,UAAUqB,qBAAqBnB,KAAKS,EAAGZ,EAAEa,MACvEF,EAAEX,EAAEa,IAAMD,EAAEZ,EAAEa,KAE1B,OAAOF,EAGJ,SAASY,EAAWC,EAAYC,EAAQC,EAAKC,GAChD,IAA2HjC,EAAvHkC,EAAIb,UAAUC,OAAQa,EAAID,EAAI,EAAIH,EAAkB,OAATE,EAAgBA,EAAO/B,OAAOkC,yBAAyBL,EAAQC,GAAOC,EACrH,GAAuB,iBAAZI,SAAoD,mBAArBA,QAAQC,SAAyBH,EAAIE,QAAQC,SAASR,EAAYC,EAAQC,EAAKC,QACpH,IAAK,IAAId,EAAIW,EAAWR,OAAS,EAAGH,GAAK,EAAGA,KAASnB,EAAI8B,EAAWX,MAAIgB,GAAKD,EAAI,EAAIlC,EAAEmC,GAAKD,EAAI,EAAIlC,EAAE+B,EAAQC,EAAKG,GAAKnC,EAAE+B,EAAQC,KAASG,GAChJ,OAAOD,EAAI,GAAKC,GAAKjC,OAAOqC,eAAeR,EAAQC,EAAKG,GAAIA,EAOzD,SAASK,EAAWC,EAAaC,GACpC,GAAuB,iBAAZL,SAAoD,mBAArBA,QAAQM,SAAyB,OAAON,QAAQM,SAASF,EAAaC,GAyCvFxC,OAAOY,OAY7B,SAAS8B,EAASC,GACrB,IAAI3B,EAAsB,mBAAX4B,QAAyBA,OAAOC,SAAUC,EAAI9B,GAAK2B,EAAE3B,GAAIC,EAAI,EAC5E,GAAI6B,EAAG,OAAOA,EAAEvC,KAAKoC,GACrB,GAAIA,GAAyB,iBAAbA,EAAEvB,OAAqB,MAAO,CAC1C2B,KAAM,WAEF,OADIJ,GAAK1B,GAAK0B,EAAEvB,SAAQuB,OAAI,GACrB,CAAEK,MAAOL,GAAKA,EAAE1B,KAAMgC,MAAON,KAG5C,MAAM,IAAIO,UAAUlC,EAAI,0BAA4B,mCAGjD,SAASmC,EAAOR,EAAGzB,GACtB,IAAI4B,EAAsB,mBAAXF,QAAyBD,EAAEC,OAAOC,UACjD,IAAKC,EAAG,OAAOH,EACf,IAAmBV,EAAYV,EAA3BN,EAAI6B,EAAEvC,KAAKoC,GAAOS,EAAK,GAC3B,IACI,WAAc,IAANlC,GAAgBA,KAAM,MAAQe,EAAIhB,EAAE8B,QAAQE,MAAMG,EAAGC,KAAKpB,EAAEe,OAExE,MAAOM,GAAS/B,EAAI,CAAE+B,MAAOA,GACjC,QACQ,IACQrB,IAAMA,EAAEgB,OAASH,EAAI7B,EAAU,SAAI6B,EAAEvC,KAAKU,GAE1D,QAAkB,GAAIM,EAAG,MAAMA,EAAE+B,OAE7B,OAAOF,EAGJ,SAASG,IACZ,IAAK,IAAIH,EAAK,GAAInC,EAAI,EAAGA,EAAIE,UAAUC,OAAQH,IAC3CmC,EAAKA,EAAGI,OAAOL,EAAOhC,UAAUF,KACpC,OAAOmC,EA8CcpD,OAAOY,WC1LnB6C,EAAqC,CAChDC,KAAM,KACNC,UAAW,KACXC,MAAM,EACNC,QAAS,MAGPC,GAAqB,WAETC,IACdD,GAAqB,WAIPE,EAAUN,EAAcC,EAAYE,GAClDI,EAAUP,EAAMC,EAAWE,GAC3BC,GAAqB,WAGPG,EAAUP,EAAcC,EAAYE,IACvB,IAAvBC,IACFL,EAAcC,KAAOA,EACrBD,EAAcE,UAAYA,EAC1BF,EAAcI,QAAUA,YAIZK,EAAcN,QAAA,IAAAA,IAAAA,GAAA,GAC5BH,EAAcG,KAAOA,WAGPO,EAAOA,EAAgBR,GACrC,OAAO,SAAU9B,EAAauC,EAAqBC,GACjD,IAAMC,EAAiBD,EAAWrB,MAMlC,OALAqB,EAAWrB,MAAQ,eAAU,IAAAuB,EAAA,GAAAC,EAAA,EAAAA,EAAArD,UAAAC,OAAAoD,IAAAD,EAAAC,GAAArD,UAAAqD,GAE3B,OADAR,EAAUG,EAAQR,GACXW,EAAejD,MAAMX,KAAM6D,IAG7BF,YC7CKI,EAAaC,EAA0BC,GACrD,OAAOD,EAASpE,eAAeqE,YCHjBC,EAAW5B,GACzB,OAAO7C,MAAMyE,QAAQ5B,YCGP6B,EAAkBC,GAChC,OAAOA,EAAMxE,eAAe,mBAIdyE,EAAmBC,GACjC,OAAOJ,EAAQI,YAIDC,EAAuBC,OAAEF,EAAME,EAAAF,OAAEG,EAAGD,EAAAC,IAAET,EAAQQ,EAAAR,SAC5D,OAAIK,EAAmBC,GACdI,EAAkBJ,EAAQG,IAGC,IAAhCV,EAAUC,EAAUM,GACf,KAGFA,WAIOI,EAAkBC,EAAyBC,GACzD,IAAMC,EAAWF,EAAkBG,QAAO,SAAAb,GAAM,OAAAW,EAAO9D,QAAQmD,IAAO,KAEtE,OAAIY,EAASnE,SAAWiE,EAAkBjE,OACjCiE,EAGFE,WCrBOE,EAAyCP,WAAEJ,EAAKI,EAAAJ,MAAEJ,EAAQQ,EAAAR,SAAEgB,EAAKR,EAAAQ,MAAEC,EAAAT,EAAAU,QAAAA,OAAO,IAAAD,EAAG,GAAEA,EAAEE,EAAYX,EAAAW,aACvGC,EAAc,GACdR,EAAS,GACTS,GAAiB,MAErB,IAAqB,IAAAC,EAAAtD,EAAAgC,GAAQuB,EAAAD,EAAAjD,QAAAkD,EAAAhD,KAAAgD,EAAAD,EAAAjD,OAAE,CAA1B,IAAMmD,EAAMD,EAAAjD,MACf,IAAiD,IAA7CyB,EAAUK,EAAMJ,SAAUwB,EAAOR,IAAmB,CAEtD,IAAMS,EAAUN,EAAaK,GACvBE,EAAWD,EAAQT,GACzBI,EAAYM,GAAYD,EACpBP,EAAQS,QAASf,EAAOgB,QAAQF,GAC/Bd,EAAOjC,KAAK+C,GAEjBL,GAAiB,qGAIrB,OAAOA,EACH,CACEQ,SAAQ1F,EAAAA,EAAA,GACHiE,GAAK,CACRJ,SAAQ7D,EAAAA,EAAA,GACHiE,EAAMJ,UACNoB,GAELX,IAAKS,EAAQS,QAAO9C,EAAO+B,EAAWR,EAAMK,KAAG5B,EAAQuB,EAAMK,IAAQG,KAEvEA,OAAMA,GAER,cC3CUkB,EAAMC,GACpB,OAAOA,MAAAA,WCCOC,EAAe1D,GAC7B,OAAIwD,EAAMxD,GACD,GAEF7C,MAAMyE,QAAQ5B,GAASA,EAAQ,CAACA,YCSzB2D,EAAwCC,EAAQC,EAA4BjB,QAAA,IAAAA,IAAAA,EAAA,IAC1F,IAAME,EAAcY,EAAYG,GAC1BC,EAAQF,GAAO,GAErB,OAAOhB,EAAQS,QAAO9C,EAAOuC,EAAgBgB,GAAUvD,EAAIuD,EAAUhB,YCnBvDiB,EAAW/D,GACzB,MAAwB,mBAAVA,WCCAgE,EAAWJ,GACzB,QAAIhC,EAAQgC,IACY,IAAfA,EAAIxF,gBCKC6F,EAAQC,EAAiBC,EAAqCzB,eACtE0B,EAAS,GACf,GAAIL,EAAWI,OACb,IAAqB,IAAAE,EAAA3E,EAAAwE,GAAUI,EAAAD,EAAAtE,QAAAuE,EAAArE,KAAAqE,EAAAD,EAAAtE,OAAE,EACA,IAA3BoE,EADKjB,EAAMoB,EAAAtE,QAEboE,EAAO/D,KAAK6C,yGAGX,CACL,IAAMqB,EAAQb,EAAYS,GAAgBK,QAAO,SAACC,EAAKtB,GAAY,OAAAsB,EAAIC,IAAIvB,KAAU,IAAIwB,SAEzF,IAAqB,IAAAC,EAAAlF,EAAAwE,GAAUW,EAAAD,EAAA7E,QAAA8E,EAAA5E,KAAA4E,EAAAD,EAAA7E,OAAE,CAA5B,IAAMmD,EAAM2B,EAAA7E,MACXuE,EAAMO,IAAI5B,EAAOR,KACnB0B,EAAO/D,KAAK6C,sGAKlB,OAAOkB,WAIOW,IACd,OAAOC,EAAAA,sBAAqB,SAACC,EAAqBC,GAChD,OAAID,IAAmBC,IAIS,IAA5BtD,EAAQqD,KAA4D,IAA/BrD,EAAQsD,QAI7ClB,EAAQiB,KAAmBjB,EAAQkB,MAKpBC,EAAUD,EAAmBD,KAST,IAHHE,EAAUF,EAAgBC,OAQlE,SAASC,EAAaC,EAAYC,GAMhC,OALkBA,EAAOC,MAAK,SAAAC,GAE5B,YAAmBC,IADHJ,EAAMnB,MAAK,SAAAwB,GAAY,OAAAA,IAAaF,iBC9DxCG,EAAS1F,GACvB,IAAMU,SAAcV,EACpB,OAAgB,MAATA,IAA0B,UAARU,GAA4B,YAARA,YCC/BiF,EAASC,GACvB,OAAO,SAACC,EAAM9I,GAAS,OAAA8I,EAAED,KAAU7I,EAAE6I,aCWvBE,EAA2ClC,EAAQmC,EAA6CC,EAAsBtD,GACpI,IAAIuD,EAEJ,QAHoI,IAAAvD,IAAAA,EChBxG,MDmBxBqB,EAAWgC,GACbE,EAAYF,MACP,CACL,IAAMG,EAAMxC,EAAYqC,GACxBE,EAAY,SAACE,GAAS,OAAsD,IAAtDD,EAAIE,SAASV,EAASS,GAAQA,EAAKzD,GAASyD,IAiBpE,OAAgBvC,EAbRyC,KAAI,SAACnD,EAAQoD,GACjB,OAAiC,IAA7BL,EAAU/C,EAAQoD,GACbZ,EAASxC,UAEPA,GACA8C,GAELA,EAGC9C,KE5Bb,IAAIqD,EAAsB,CACxBC,YAAY,EACZC,IAAK,KACLC,gBAAYlB,YAQEmB,IACd,OAAOJ,WClBOK,EAAUC,GACxB,OAAsB,IAAfrD,EAAMqD,OCAFC,EAAgB,IAAIC,EAAAA,QAEpBC,EAAa,IAAIC,EAAAA,cAAsB,GAAI,KAE3CC,EAAgB,IAAIH,EAAAA,iBAGjBI,EAAgBC,GAC9BN,EAAc/G,KAAKqH,YAILC,EAAcD,GAC5BJ,EAAWjH,KAAKqH,YAIFE,EAAeF,EAAmBjG,GAChD+F,EAAcnH,KAAK,CAAEqH,UAASA,EAAEjG,OAAMA,QCtB3BoG,EAA8B,oBAAXC,OACnBC,GAAgBF,EAEhBG,EAAkB,WAC7B,IACE,MAA+B,oBAAjBC,aACd,MAAAzF,GACA,OAAO,ICFE0F,EAAkD,GAGlDC,EAAmD,YCPhDC,EAAW9H,GACzB,OAAOA,GAASA,EAAM+H,OAAO,GAAGC,cAAgBhI,EAAMiI,MAAM,GDQ1DV,IACDC,OAAeU,SAAWN,EAC1BJ,OAAeW,UAAYN,GEU9B,ICtBYO,ECAAC,GFsBRC,GAAO,YChBKC,GAAczJ,EAAK0J,GACjC,YADiC,IAAAA,IAAAA,EAAeJ,EAAAA,MAAMK,KAC/C,SAAS5C,EAAG9I,GACjB,IAAK8I,EAAEvI,eAAewB,KAAS/B,EAAEO,eAAewB,GAC9C,OAAO,EAGT,IAAM4J,EAAyB,iBAAX7C,EAAE/G,GAAoB+G,EAAE/G,GAAKkJ,cAAgBnC,EAAE/G,GAC7D6J,EAAyB,iBAAX5L,EAAE+B,GAAoB/B,EAAE+B,GAAKkJ,cAAgBjL,EAAE+B,GAE/D8J,EAAa,EAMjB,OALIF,EAAOC,EACTC,EAAa,EACJF,EAAOC,IAChBC,GAAc,GAETJ,GAASJ,EAAAA,MAAMS,MAAqB,EAAdD,EAAkBA,YEfnCE,GAA0ChH,EAAUc,GAKlE,IAJA,IAAIgB,EAAM,GACFzB,EAAkBL,EAAKK,IAAlBT,EAAaI,EAAKJ,SACvBqH,EAA2CnG,EAAOmG,SAAxCC,EAAiCpG,EAAOoG,QAA/BC,EAAwBrG,EAAOqG,OAAvBC,EAAgBtG,EAAOsG,uBAEjDjL,GACP,IAAMiF,EAASxB,EAASS,EAAIlE,IAC5B,IAAK8K,SACHnF,EAAIvD,KAAK6C,cAIKQ,EAAYqF,GACJI,OAAM,SAAAC,GAAM,OAAAA,EAAGlG,EAAQjF,OAE7C2F,EAAIvD,KAAK6C,IAVJjF,EAAI,EAAGA,EAAIkE,EAAI/D,OAAQH,MAAvBA,GAcT,GAAIgL,EAAQ,CACV,IAAII,EAAetF,EAAWkF,GAAUA,EAASV,GAAcU,EAAQC,GACvEtF,EAAMA,EAAI0F,MAAK,SAACzD,EAAG9I,GAAM,OAAAsM,EAAQxD,EAAG9I,EAAG+E,MAGzC,IAAM1D,EAASmL,KAAKC,IAAIR,GAAWpF,EAAIxF,OAAQwF,EAAIxF,QAEnD,OAAOA,IAAWwF,EAAIxF,OAASwF,EAAMA,EAAIqE,MAAM,EAAG7J,YC3BpCqL,GAA2C3H,EAAUc,GACnE,IAAMyD,EAAM,GACJ0C,EAAsBnG,EAAOmG,SAAnBC,EAAYpG,EAAOoG,QAC7B7G,EAAkBL,EAAKK,IAAlBT,EAAaI,EAAKJ,SAE/B,IAAKqH,IAAaC,EAChB,OAAOtH,EAET,IAAMgI,GAA8B,IAAnBlG,EAAMwF,GAEvB,GAAID,GAAYW,EAEd,IADA,IAAIC,EAAQ,aACH1L,EAAO2L,GACd,GAAID,IAAUX,gBACd,IAAMrH,EAAKQ,EAAIlE,GACTiF,EAASxB,EAASC,GACR+B,EAAYqF,GAAUI,OAAM,SAAAC,GAAM,OAAAA,EAAGlG,EAAQjF,QAE3DoI,EAAI1E,GAAMuB,EACVyG,MAPK1L,EAAI,EAAG2L,EAASzH,EAAI/D,OAAQH,EAAI2L,EAAQ3L,IAAG,gBAA3CA,aAWT,CAAA,IAAM4L,EAAcN,KAAKC,IAAIR,GAAW7G,EAAI/D,OAAQ+D,EAAI/D,mBAE/CH,GACP,IAAM0D,EAAKQ,EAAIlE,GACTiF,EAASxB,EAASC,GAExB,IAAKoH,SACH1C,EAAI1E,GAAMuB,aAIIQ,EAAYqF,GAAUI,OAAM,SAAAC,GAAM,OAAAA,EAAGlG,EAAQjF,QAE3DoI,EAAI1E,GAAMuB,IAXd,IAASjF,EAAI,EAAGA,EAAI4L,EAAa5L,MAAxBA,GAgBX,OAAOoI,GH9CG+B,EAAAA,EAAAA,QAAAA,EAAAA,MAAK,KACf,IAAA,MACAA,EAAA,KAAA,QCFUC,GAAAA,EAAAA,gBAAAA,EAAAA,cAAa,KACvB,IAAA,MACAA,GAAA,IAAA,MACAA,GAAA,OAAA,SACAA,GAAA,OAAA,gBGDF,sBCUgByB,KACd,OAAOC,EAAAA,iBCNOC,GAAkBC,EAA4C9H,EAAW+H,GACvF,IAAI9F,EAEJ,GAAIxC,EAAQqI,GACV7F,EAAS6F,OAET,GAAIvE,EAASuE,GAAc,CACzB,GAAIzG,EAAM0G,GAAgB,OACzBD,EAAmCjN,OAAOc,OAAO,CAAEqM,MAAM,GAAQF,GAClE,IAAMG,EAAiBjI,EAAI3D,QAAQ0L,GACnC,GAAKD,EAAiCI,KAAM,CAC1C,IAAMC,EAA6B,IAAnBF,EAChB,GAAIE,IAAaL,EAAiCE,KAAM,OACxD/F,EAASkG,EAAUnI,EAAIA,EAAI/D,OAAS,GAAM+D,EAAIiI,EAAiB,QAC1D,GAAKH,EAAiClK,KAAM,CACjD,IAAMwK,EAASpI,EAAI/D,SAAWgM,EAAiB,EAC/C,GAAIG,IAAYN,EAAiCE,KAAM,OACvD/F,EAASmG,EAASpI,EAAI,GAAMA,EAAIiI,EAAiB,QAE9C,CACL,GAAIH,IAAgBC,EAAe,OACnC9F,EAAS6F,EAIb,OAAO7F,ED/BE2F,EAAAA,SAAU,MECRS,GAA0B,WACrC,MAAA,CACE9I,SAAU,GACVS,IAAK,GACLsI,SAAS,EACTnK,MAAO,gBCPKoK,GAAY1K,GAC1B,YAAiBwF,IAAVxF,WCQO2K,GAA4CzI,WAAEJ,EAAKI,EAAAJ,MAAEK,EAAGD,EAAAC,IACtE,GAAIqB,EAAMrB,GAAM,OAAOyI,GAAkB9I,GACzC,IAAMJ,EAAWI,EAAMJ,SACnBoB,EAAc,OAElB,IAAiB,IAAAH,EAAAjD,EAAAoC,EAAMK,KAAG0I,EAAAlI,EAAA5C,QAAA8K,EAAA5K,KAAA4K,EAAAlI,EAAA5C,OAAE,CAAvB,IAAM4B,EAAEkJ,EAAA7K,OACc,IAArBmC,EAAIiE,SAASzE,KACfmB,EAAYnB,GAAMD,EAASC,sGAI/B,IAAM4B,EAAQ1F,EAAAA,EAAA,GACTiE,GAAK,CACRJ,SAAUoB,EACVX,IAAKL,EAAMK,IAAIK,QAAO,SAAAW,GAAW,OAA0B,IAA1BhB,EAAIiE,SAASjD,QAOhD,OAJItB,EAAeC,KACjByB,EAASvB,OAASC,EAAoBsB,IAGjCA,WAIOqH,GAAqB9I,GACnC,OAAAjE,EAAAA,EAAA,GACKiE,GAAK,CACRJ,SAAU,GACVS,IAAK,GACLH,OAAQD,EAAmBD,EAAME,QAAU,GAAK,gBCrCpC8I,GAAoBpJ,EAAegB,EAAeG,WAC1D4B,EAAM,CACV/C,SAAU,GACVS,IAAK,QAGP,IAAqB,IAAAa,EAAAtD,EAAAgC,GAAQuB,EAAAD,EAAAjD,QAAAkD,EAAAhD,KAAAgD,EAAAD,EAAAjD,OAAE,CAA1B,IAEGoD,EAAUN,EAFDI,EAAAjD,OAGfyE,EAAI/C,SAASyB,EAAQT,IAAUS,EAC/BsB,EAAItC,IAAI9B,KAAK8C,EAAQT,sGAGvB,OAAO+B,WCAOsG,GAAsBjJ,GACpC,OAAOA,EAAMJ,UAAYI,EAAMK,IAIjC,SAAS6I,GAAmBtJ,EAAsBmB,WAC5CoI,EAAS,OACb,IAAiB,IAAAC,EAAAxL,EAAA1C,OAAOmO,KAAKzJ,IAASiB,EAAAuI,EAAAnL,QAAA4C,EAAA1C,KAAA0C,EAAAuI,EAAAnL,OAAE,CAAnC,IAAM4B,EAAEgB,EAAA3C,MACXiL,EAAOtJ,GAAMkB,EAAanB,EAASC,sGAGrC,OAAOsJ,WAIOG,GAAyClJ,OACnDY,EACAR,EAFqDR,EAAKI,EAAAJ,MAAEJ,EAAQQ,EAAAR,SAAEgB,EAAKR,EAAAQ,MAAEG,EAAYX,EAAAW,aAAEwI,EAAcnJ,EAAAmJ,eAI7G,GAAIzJ,EAAQF,GAAW,CACrB,IAAM4J,EAAUR,GAAiBpJ,EAAUgB,EAAOG,GAClDC,EAAcwI,EAAQ5J,SACtBY,EAASgJ,EAAQnJ,SACR4I,GAAcrJ,IACvBoB,EAAcuI,EAAiB3J,EAASA,SAAWsJ,GAAgBtJ,EAASA,SAAUmB,GACtFP,EAASZ,EAASS,MAGlBW,EAAcuI,EAAiB3J,EAAWsJ,GAAgBtJ,EAAUmB,GACpEP,EAAStF,OAAOmO,KAAKrI,GAAauD,KAAI,SAAA1E,GAAM,OAAC4J,MAAM5J,GAAaA,EAAK6J,OAAO7J,OAG9E,IAAM4B,EAAQ1F,EAAAA,EAAA,GACTiE,GAAK,CACRJ,SAAUoB,EACVX,IAAKG,EACLmI,SAAS,IAOX,OAJI5I,EAAeC,KAChByB,EAAiBvB,OAASC,EAAoBsB,IAG1CA,WC1DOkI,GAAW9L,GACzB3C,OAAO0O,OAAO/L,GAEd,IAAMgM,EAA2B,mBAANhM,EACrBiM,EAAa5O,OAAOK,UAAUC,eAcpC,OAZAN,OAAO6O,oBAAoBlM,GAAGmM,SAAQ,SAASlG,IAE3CgG,EAAWrO,KAAKoC,EAAGiG,IAClB+F,IAAuB,WAAT/F,GAA8B,WAATA,GAA8B,cAATA,IAC7C,OAAZjG,EAAEiG,IACkB,iBAAZjG,EAAEiG,IAAyC,mBAAZjG,EAAEiG,IACxC5I,OAAO+O,SAASpM,EAAEiG,KAEnB6F,GAAW9L,EAAEiG,OAIVjG,EClBT,IAAAqM,GAAA,SAAAC,GACE,SAAAD,EAAYE,UACVD,EAAA1O,KAAAG,KAAMwO,IAAQxO,KAElB,OAJgCF,EAAAwO,EAAAC,GAIhCD,EAJA,CAAgCG,gBCAhBC,GAAUpM,GACxB,OAAgB,MAATA,GAAiB,GAAGA,GAAY,iBCCzBqM,GAAcrM,GAC5B,OAAOoM,GAAUpM,IAAqC,WAA3BA,EAAMrC,YAAY2O,KCC/C,IAAMC,GAAsB,IAAIxF,EAAAA,QAG1ByF,GAAuB,IAAIC,EAAAA,iBAAgB,GAQpCC,GAAyC,CACpDC,mBAAoB,EACpBC,iBAAkB,eAIJC,KACTC,OACHJ,GAAmBE,iBAAmB,IAAI7F,EAAAA,SAE5C2F,GAAmBC,qBACnBH,GAAqBzM,MAAK,YAIZgN,KACkC,KAA1CL,GAAmBC,qBACvBD,GAAmBE,iBAAiB7M,MAAK,GACzC2M,GAAmBE,iBAAiBI,WACpCR,GAAqBzM,MAAK,GAC1BwM,GAAoBxM,MAAK,aAKb+M,KACd,OAAOJ,GAAmBC,mBAAqB,WAIjCM,KACd,OAAOP,GAAmBE,iBAAmBF,GAAmBE,iBAAiBM,eAAiBC,EAAAA,IAAG,YAevFC,GAAoBjM,EAAiBkM,QAAA,IAAAA,IAAAA,OAAA7H,GACnDqH,KACA,IACE,OAAO1L,EAAO9C,MAAMgP,WAEpBrM,EAAU,gBACV+L,eAmBYO,KACd,OAAO,SAASzO,EAAauC,EAAqBC,GAChD,IAAMC,EAAiBD,EAAWrB,MAQlC,OANAqB,EAAWrB,MAAQ,eAAA,IAAAuN,EAAA7P,KAAS6D,EAAA,GAAAC,EAAA,EAAAA,EAAArD,UAAAC,OAAAoD,IAAAD,EAAAC,GAAArD,UAAAqD,GAC1B,OAAO4L,IAAiB,WACtB,OAAO9L,EAAejD,MAAMkP,EAAMhM,KACjC7D,OAGE2D,qBCxCT,SAAAmM,EAAYC,EAAoC7K,QAAA,IAAAA,IAAAA,EAAA,IAAAlF,KAAAkF,QAAAA,EAPxClF,KAAAgQ,eAAgB,EAEdhQ,KAAAiQ,MAAoB,CAC5B3L,OAAQ,IAAIyK,EAAAA,iBAAyB,GACrChG,IAAK,MAIL/I,KAAKkQ,OAAOH,GAwRhB,OA7QED,EAAAnQ,UAAAwQ,WAAA,SAAWpD,QAAA,IAAAA,IAAAA,GAAA,GACLA,IAAa/M,KAAKoQ,SAAsCrD,UAC1DX,MAAW7I,EAAU,eACrBvD,KAAKqQ,WAAU,SAACjM,GAAU,OAACjE,EAAAA,EAAA,GAAKiE,GAAK,CAAE2I,QAAOA,SAelD+C,EAAAnQ,UAAA2Q,YAAA,SAAYC,EAAmBrL,GAA/B,IAAA2K,EAAA7P,KAKE,QAL6B,IAAAkF,IAAAA,EAAA,CAAqCsL,YAAY,IAC1ED,IAAavQ,KAAKiQ,MAAM3L,OAAOhC,OACjCtC,KAAKiQ,MAAM3L,OAAOjC,KAAKkO,GAGrBrL,EAAQsL,WAAY,CACtB,IAAMC,EAAYzQ,KAAK0Q,cACnBD,IACqB,OAAnBzQ,KAAKiQ,MAAMlH,KACb4H,aAAa3Q,KAAKiQ,MAAMlH,KAE1B/I,KAAKiQ,MAAMlH,IAAW6H,YAAW,WAAM,OAAAf,EAAKS,aAAY,KAAQG,MAYtEX,EAAAnQ,UAAAkR,SAAA,WACE,OAAO7Q,KAAK8Q,YAWdhB,EAAAnQ,UAAAoR,SAAA,SAAYnO,GACNA,IAAW5C,KAAKoQ,SAAgCxN,QAClDwJ,MAAW7I,EAAU,aACrBvD,KAAKqQ,WAAU,SAACjM,GAAU,OAACjE,EAAAA,EAAA,GAAKiE,GAAK,CAAExB,MAAKA,SAKhDkN,EAAAnQ,UAAAqR,QAAA,SAAWC,GACT,OAAOjR,KAAKkR,MAAM1B,eAAe2B,KAC/BxI,EAAAA,KAAI,SAACyI,GAAa,OAAAH,EAAQG,EAAShN,UACnCkD,EAAAA,yBAKJwI,EAAAnQ,UAAAyQ,OAAA,WACE,OAAOpQ,KAAK8Q,YAIdhB,EAAAnQ,UAAA0R,OAAA,WACE,OAAOrR,KAAKiQ,MAAM3L,QAIpBhF,OAAAqC,eAAImO,EAAAnQ,UAAA,SAAM,KAAV,WACE,OAAOK,KAAKC,YAAqB,aAAK,oCAIxCX,OAAAqC,eAAImO,EAAAnQ,UAAA,YAAS,KAAb,WACE,OAAQK,KAAKsR,OAAsD5H,WAAc1J,KAAKkF,QAAuDwE,WAAa1J,KAAKkF,QAAQ0J,sCAIzKtP,OAAAqC,eAAImO,EAAAnQ,UAAA,aAAU,KAAd,WACE,OAAOK,KAAKsR,OAAOC,cAAgBvR,KAAKkF,QAAQqM,cAAgBxD,oCAIlEzO,OAAAqC,eAAImO,EAAAnQ,UAAA,cAAW,KAAf,WACE,OAAOK,KAAKsR,OAAOrB,OAASjQ,KAAKkF,QAAQ+K,uCAG3C3Q,OAAAqC,eAAImO,EAAAnQ,UAAA,cAAW,KAAf,WACE,OAAOK,KAAKsR,OAAOtI,YAAchJ,KAAKkF,QAAQ8D,YxB/IzCH,EAAOG,4CwBmJd1J,OAAAqC,eAAImO,EAAAnQ,UAAA,aAAU,KAAd,WACE,OAAOuJ,EAAUlJ,KAAKsR,OAAOxI,YAAc9I,KAAKsR,OAAOxI,WAAa9I,KAAKkF,QAAQ4D,4CAInFgH,EAAAnQ,UAAA0Q,UAAA,SAAUxK,EAA2C2L,GAArD,IAAA3B,EAAA7P,KACE,QADmD,IAAAwR,IAAAA,GAAA,GAC/CnL,EAAWR,GAAW,CACxB,IAAM4L,EAAY5L,EAAS7F,KAAKoQ,UAChCpQ,KAAK8Q,WAAazE,EAAAA,QAAUrM,KAAK+N,WAAW0D,GAAaA,OAEzDzR,KAAK8Q,WAAajL,EAGpB,IAAK7F,KAAKkR,MAWR,OAVAlR,KAAKkR,MAAQ,IAAInC,EAAAA,gBAAgB,CAAE3K,MAAOpE,KAAK8Q,kBAE3C1E,MACFpM,KAAKkR,MAAMQ,WAAU,SAAClN,OAAEf,EAAMe,EAAAf,OACxBA,GACFmG,EAAeiG,EAAKnG,UAAWjG,OAQnC2L,KACFpP,KAAK2R,oBAIP3R,KAAK4R,SAAS5R,KAAK8Q,WAAYU,IAYjC1B,EAAAnQ,UAAAkS,MAAA,WAAA,IAAAhC,EAAA7P,KACMA,KAAK8R,gBACP1F,MAAW7I,EAAU,SACrBvD,KAAKqQ,WAAU,WAAM,OAAA/Q,OAAOc,OAAO,GAAIyP,EAAKkC,kBAC5C/R,KAAKsQ,aAAY,IAEjBlE,MAAW4F,QAAQC,KAAK,+CAsB5BnC,EAAAnQ,UAAAuS,OAAA,SAAOC,GAGL,IAAItM,EAFJuG,MAAW7I,EAAU,UAGrB,IAAM6O,EAAepS,KAAKoQ,SAExBvK,EADEQ,EAAW8L,GACF9L,EAAWrG,KAAKqS,aAAerS,KAAKqS,YAAYD,EAAcD,GAAmBA,EAAgBC,GAEjGD,EAGb,IAAMG,EAAWtS,KAAKuS,eAAeH,EAAcjS,EAAAA,EAAA,GAAKiS,GAAiBvM,IACnE2M,EAAW7D,GAAcyD,GAAgBE,EAAW,IAAKF,EAAqBnS,YAAYqS,GAChGtS,KAAKqQ,UAAUmC,IAGjB1C,EAAAnQ,UAAA8S,kBAAA,SAAkBC,GAChB1S,KAAKkF,QAAO/E,EAAAA,EAAA,GAAQH,KAAKkF,SAAYwN,IAIvC5C,EAAAnQ,UAAA4S,eAAA,SAAeI,EAAgBC,GAC7B,OAAOA,GAGT9C,EAAAnQ,UAAAkT,YAAA,WACE7S,KAAK8S,WAYPhD,EAAAnQ,UAAAmT,QAAA,aACqBjJ,GAAaC,OAAeiJ,YAC5B/S,OAASkK,EAAWlK,KAAK0J,oBACnCQ,EAAWlK,KAAK0J,WACvBD,EAAgBzJ,KAAK0J,WACrB1J,KAAKsQ,aAAY,GACjBtQ,KAAKiQ,MAAM3L,OAAOgL,WAClBtP,KAAKkR,MAAM5B,aAIPQ,EAAAnQ,UAAAuQ,OAAR,SAAeH,OJ7RkBnB,EAAcoE,EI8R7C9I,EAAWlK,KAAK0J,WAAa1J,KAC7BA,KAAKqQ,WAAU,WAAM,OAAAN,KACrBpG,EAAc3J,KAAK0J,WACf1J,KAAK8R,iBACP9R,KAAK+R,cAAgBhC,GAEvB3D,OJpS+BwC,EIoSD5O,KAAK0J,UJpSUsJ,EIoSChT,KAAKC,YAAY2O,KJnS5DA,GACHoD,QAAQpP,MAAM,wCAAwCoQ,KIqShDlD,EAAAnQ,UAAAiS,SAAR,SAAiBxN,EAAUoN,QAAA,IAAAA,IAAAA,GAAA,GACzB,IAAI/N,OAA0CqE,EAE1C0J,IACF/N,EAASV,EACTM,KAGFrD,KAAKkR,MAAM7O,KAAK,CAAE+B,MAAKA,EAAEX,OAAMA,KAGzBqM,EAAAnQ,UAAAsT,iBAAR,WAAA,IAAApD,EAAA7P,KACEuP,KAASmC,WAAU,WACjB7B,EAAKG,eAAgB,EACrBH,EAAK+B,SAAS/B,EAAKO,cAIfN,EAAAnQ,UAAAmS,aAAR,WACE,OAAwB,IAApB9R,KAAK8I,aAGF9I,KAAK8I,YAAcG,IAAiBH,aAGrCgH,EAAAnQ,UAAAgS,kBAAR,WACO3R,KAAKgQ,gBACRhQ,KAAKiT,mBACLjT,KAAKgQ,eAAgB,IAIjBF,EAAAnQ,UAAA+Q,YAAR,WACE,OAAQ1Q,KAAKkT,aAAelT,KAAKkT,YAAYnK,KAAQE,IAAiBF,KAE1E+G,cCjUgBqD,GAA4C3O,WAItD4O,EAJwDhP,EAAKI,EAAAJ,MAAEK,EAAGD,EAAAC,IAAEO,EAAKR,EAAAQ,MAAEqO,EAAY7O,EAAA6O,aAAEC,EAAe9O,EAAA8O,gBAAEtK,EAAUxE,EAAAwE,WAAEuK,EAAiB/O,EAAA+O,kBACrIC,EAAkB,GAEpBC,GAAkB,MAGtB,IAAiB,IAAAjL,EAAAxG,EAAAyC,GAAGiP,EAAAlL,EAAAnG,QAAAqR,EAAAnR,KAAAmR,EAAAlL,EAAAnG,OAAE,CAAjB,IAAM4B,EAAEyP,EAAApR,MAEX,IAAsC,IAAlCyB,EAAUK,EAAMJ,SAAUC,GAA9B,CAIA,IAAM0P,EAAYvP,EAAMJ,SAASC,GAC7B4B,OAAQ,EAON+N,GALJ/N,EADEQ,EAAWgN,GACFhN,EAAW2C,GAAcA,EAAW2K,EAAWN,GAAgBA,EAAaM,GAE5EN,GAGgBzT,eAAeoF,IAAUa,EAASb,KAAW2O,EAAU3O,GAChFmB,OAAS,EACbiN,EAAanP,EAET2P,IACFH,GAAkB,EAClBL,EAAavN,EAASb,IAGxB,IAAM6O,EAAM1T,EAAAA,EAAA,GACPwT,GACA9N,GAIHM,EADEwI,GAAcgF,GACJE,EAYRlF,GAAc9I,GACJ,IAAK8N,EAAkB1T,YAAY4T,GAEnC,IAAKhO,EAAiB5F,YAAY4T,GAIlDL,EAAgBJ,GAAcE,EAAgBK,EAAWxN,sGAG3D,IAAI2N,EAAa1P,EAAMK,IACnBsP,EAAgB3P,EAAMJ,SAE1B,GAAIyP,EAAiB,CACb,IAACO,EAADvR,EAAOgC,EAAG,GAAP,GACgC0I,EAAA/I,EAAMJ,SAAvCiQ,EAACD,EAAkB7G,EAAA8G,GAC3BF,EADoCnT,EAAAuM,EAA9B,CAAA,iBAAA8G,EAAAA,EAAAA,EAAA,KAENH,EAAa1P,EAAMK,IAAIkE,KAAI,SAAClD,GAAY,OAACA,IAAYuO,EAAKZ,EAAa3N,KACvE8N,EAAkBS,EAAIZ,GAGxB,OAAAjT,EAAAA,EAAA,GACKiE,GAAK,CACRJ,SAAQ7D,EAAAA,EAAA,GACH4T,GACAP,GAEL/O,IAAKqP,uBCjCP,SAAAI,EAAYnE,EAAyC7K,QAAzC,IAAA6K,IAAAA,EAAA,SAAyC,IAAA7K,IAAAA,EAAA,IAArD,IAAA2K,EACEtB,EAAA1O,KAAAG,KAAAG,EAAAA,EAAA,GZvDF,CACE6D,SAAU,GACVS,IAAK,GACLsI,SAAS,EACTnK,MAAO,OYmDkCmN,GAAgB7K,IAAQlF,YADd6P,EAAA3K,QAAAA,EAH7C2K,EAAAsE,cAAgB,IAAI9K,EAAAA,QACpBwG,EAAAuE,gBAAkB,IAAI/K,EAAAA,gBA8lBhC,OAjmBoHvJ,EAAAoU,EAAA3F,GAUlHjP,OAAAqC,eAAIuS,EAAAvU,UAAA,sBAAmB,KAAvB,WACE,OAAOK,KAAKmU,cAAc3E,gDAI5BlQ,OAAAqC,eAAIuS,EAAAvU,UAAA,yBAAsB,KAA1B,WACE,OAAOK,KAAKoU,gBAAgB5E,gDAI9BlQ,OAAAqC,eAAIuS,EAAAvU,UAAA,QAAK,KAAT,WACE,OAAQK,KAAKsR,OAA8BtM,OAAShF,KAAKkF,QAAQF,O3B1EvC,sC2BwF5BkP,EAAAvU,UAAA0U,IAAA,SAAIrQ,EAAmCkB,GAAvC,IAAA2K,EAAA7P,KACE,QADqC,IAAAkF,IAAAA,EAAA,KACjCY,EAAM9B,GAAV,CAEAoI,MAAW7I,EAAU,cAErB,IAAMoK,EAAiB3N,KAAKsU,oBAAsBJ,EAAYvU,UAAU2U,kBACxEtU,KAAKsQ,aAAY,EAAM,CAAEE,YAAY,IAErCxQ,KAAKqQ,WAAU,SAACjM,GACd,IAAMyB,EAAW6H,GAAY,CAC3BtJ,MAAKA,EACLJ,SAAQA,EACRgB,MAAO6K,EAAK7K,MACZG,aAAc0K,EAAKyE,kBACnB3G,eAAcA,IAOhB,OAJsC,IAAlCX,GAAY9H,EAAQqP,YACrB1O,EAAiBvB,OAASY,EAAQqP,UAG9B1O,KAGL7F,KAAKwU,qBACPxU,KAAKyU,mBAGPzU,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAc1D,IAAKxC,IAAKzE,KAAKyE,QAc/DyP,EAAAvU,UAAAqH,IAAA,SAAIhD,EAA+BkB,QAAA,IAAAA,IAAAA,EAAA,CAAgC6H,SAAS,IAC1E,IAAMvG,EAAaR,EAAYhC,GAE/B,IAAIsC,EAAQE,GAAZ,CAEA,IAAMkO,EAAO3P,EAAY,CACvBX,MAAOpE,KAAKoQ,SACZjL,aAAcnF,KAAKsU,kBACnBtQ,SAAUwC,EACVxB,MAAOhF,KAAKgF,MACZE,QAAOA,IAGLwP,IACFtI,MAAW7I,EAAU,cACrBmR,EAAK7O,SAASkH,QAAU7H,EAAQ6H,QAEhC/M,KAAKqQ,WAAU,WAAM,OAAAqE,EAAK7O,YAEtB7F,KAAKwU,qBACPxU,KAAKyU,kBAAiB,GAGxBzU,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAcgK,IAAKlQ,IAAKiQ,EAAK9P,YA8BjEsP,EAAAvU,UAAAuS,OAAA,SACE0C,EACAvB,GAFF,IAAAxD,EAAA7P,KAIE,GAAIgN,GAAYqG,GACd9E,EAAA5O,UAAMuS,OAAMrS,KAAAG,KAAC4U,OADf,CAIA,IAcIC,EAdApQ,EAAgB,GAUpB,IAAI6B,EANF7B,EAFE4B,EAAWuO,GAEP5U,KAAKyE,IAAIK,QAAO,SAACb,GAAO,OAAC2Q,EAAqD/E,EAAK7L,SAASC,OAG5F6B,EAAM8O,GAAkB5U,KAAKyE,IAAMuB,EAAY4O,IAKvDxI,MAAW7I,EAAU,gBAAiBkB,GAStCzE,KAAKqQ,WAAU,SAACjM,GACd,OAAA+O,GAAe,CACbnO,MAAO6K,EAAK7K,MACZP,IAAGA,EACH6O,gBAAiBzD,EAAKiF,qBACtB1Q,MAAKA,EACLiP,aAAYA,EACZrK,WAAY6G,EAAKwC,YACjBkB,kBAAmB,SAACwB,EAAeC,GACjCH,EAAkB,CAAEE,MAAKA,EAAEC,MAAKA,GAChCnF,EAAKuE,gBAAgB/R,KAAIlC,EAAAA,EAAA,GAAM0U,GAAe,CAAEI,SAAS,WAK3DJ,GACF7U,KAAKoU,gBAAgB/R,KAAIlC,EAAAA,EAAA,GAAM0U,GAAe,CAAEI,SAAS,KAG3DjV,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAcuK,OAAQzQ,IAAGA,MAmC3DyP,EAAAvU,UAAAwV,OAAA,SACE1Q,EACAoB,EACAuP,EACAlQ,GALF,IAAA2K,EAAA7P,UAKE,IAAAkF,IAAAA,EAAA,IAEA,IAAMmQ,EAAUrP,EAAYvB,GACtB6Q,EAAY,SAACC,GAAa,OAAA,SAACtR,GAAO,OAAAF,EAAU8L,EAAK7L,SAAUC,KAAQsR,IACnEC,EAAYnP,EAAW+O,GAAYlQ,EAAQsQ,UAAYJ,EAAWA,EAASI,eAAY1N,EACvF2N,EAAepP,EAAWmP,GAE1BE,EAAYL,EAAQvQ,OAAOwQ,GAAU,IACrClQ,EAAciQ,EAAQvQ,OAAOwQ,GAAU,IAAQ3M,KAAI,SAAC1E,SAClD0R,EAAkC,mBAAb9P,EAA0BA,EAAS,IAAMA,EAC9DL,EAASa,EAAW+O,GAAYA,EAASnR,EAAI0R,GAAeA,EAC5DC,EAAMzV,EAAAA,EAAA,GAAQqF,KAAMhB,EAAA,IAAGqL,EAAK7K,OAAQf,EAAEO,IAC5C,OAAIiR,EACK,IAAID,EAAUI,GAEhBA,KAIT5V,KAAKkS,OAAOwD,EAAW7P,GACvB7F,KAAKgH,IAAI5B,GACTgH,MAAW9I,EAAU,kBAevB4Q,EAAAvU,UAAAkW,WAAA,SAAW7R,EAAwBkB,gBAAA,IAAAA,IAAAA,EAAA,IACjC,IAAM4Q,EAAW,GACXhC,EAAa,GACbN,EAAkB,OAGxB,IAAqB,IAAAlO,EAAAtD,EAAAgC,GAAQuB,EAAAD,EAAAjD,QAAAkD,EAAAhD,KAAAgD,EAAAD,EAAAjD,OAAE,CAA1B,IAAMmD,EAAMD,EAAAjD,MACTyT,EAAmB/V,KAAKgW,oBAAoBxQ,GAC5CvB,EAAK8R,EAAiB/V,KAAKgF,OACjC,GAAIjB,EAAU/D,KAAKgE,SAAUC,GAAK,CAChC,IAAM0I,EAAO3M,KAAKoQ,SAASpM,SAASC,GAC9B4P,EAAM1T,EAAAA,EAAA,GAAQH,KAAKoQ,SAASpM,SAASC,IAAQ8R,GAC7C1T,EAAO6C,EAAQsQ,UAAY,IAAItQ,EAAQsQ,UAAU3B,GAAUA,EAE3DoC,GADA3D,EAAWtS,KAAK8U,qBAAqBnI,EAAMtK,IACzBrC,KAAKgF,OAC7BwO,EAAgByC,GAAU3D,EAC1BwB,EAAWnR,KAAKsT,OACX,CACL,IACM3D,EADAnM,EAAYjB,EAAQsQ,UAAY,IAAItQ,EAAQsQ,UAAUO,GAAoBA,EAE1EE,GADA3D,EAAWtS,KAAKsU,kBAAkBnO,IAChBnG,KAAKgF,OAC7B8Q,EAASnT,KAAKsT,GACdzC,EAAgByC,GAAU3D,qGAI9BlG,MAAW9I,EAAU,eAErBtD,KAAKqQ,WAAU,SAACjM,GAAU,OAAAjE,EAAAA,EAAA,GACrBiE,GAAK,CACRK,IAAKqR,EAASpV,OAAMmC,EAAOuB,EAAMK,IAAQqR,GAAY1R,EAAMK,IAC3DT,SAAQ7D,EAAAA,EAAA,GACHiE,EAAMJ,UACNwP,GAELzG,UAAW7H,EAAQ6H,aAGrB+G,EAAWpT,QAAUV,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAcuK,OAAQzQ,IAAKqP,IAChFgC,EAASpV,QAAUV,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAcgK,IAAKlQ,IAAKqR,IACvEA,EAASpV,QAAUV,KAAKkW,cAC1BlW,KAAKyU,kBAAiB,IAc1BP,EAAAvU,UAAAwW,QAAA,SAAQ1R,EAAUoB,aACVwP,EAAUrP,EAAYvB,GAC5B,IAAI6B,EAAQ+O,GAAZ,CACA,IAAMe,EAAW,OACjB,IAAiB,IAAAC,EAAArU,EAAAqT,GAAOiB,EAAAD,EAAAhU,QAAAiU,EAAA/T,KAAA+T,EAAAD,EAAAhU,OAAE,CAArB,IAAM4B,EAAEqS,EAAAhU,MACX8T,EAASnS,GAAG9D,EAAAA,EAAA,GAAQ0F,KAAQ2H,EAAA,IAAGxN,KAAKgF,OAAQf,EAAEuJ,sGAEhDpB,MAAW7I,EAAU,iBAAkBkB,GACvCzE,KAAKqQ,WAAU,SAACjM,GAAU,OAAAjE,EAAAA,EAAA,GACrBiE,GAAK,CACRJ,SAAQ7D,EAAAA,EAAA,GACHiE,EAAMJ,UACNoS,UAcTlC,EAAAvU,UAAA4W,KAAA,SAAKC,EAAcC,GACjB,IAAMhS,EAAMzE,KAAKyE,IAAI8F,QACrB9F,EAAIiS,OAAOD,EAAK,EAAIhS,EAAI/D,OAAS+V,EAAKA,EAAI,EAAGhS,EAAIiS,OAAOF,EAAM,GAAG,IAEjEpK,MAAW7I,EAAU,eACrBvD,KAAKqQ,WAAU,SAACjM,GAAU,OAAAjE,EAAAA,EAAA,GACrBiE,GAAK,CAERJ,SAAQ7D,EAAA,GACHiE,EAAMJ,UAEXS,IAAGA,QAmBPyP,EAAAvU,UAAAgX,OAAA,SAAOC,GAAP,IAAA/G,EAAA7P,KACE,IAAIsG,EAAQtG,KAAKyE,KAAjB,CAEA,IAAMoS,EAAW3N,EAAU0N,GAGvBnS,EAAuB,GAQvB6B,EALF7B,EADE4B,EAAWuQ,GACP5W,KAAKyE,IAAIK,QAAO,SAACY,GAAa,OAAAkR,EAAQ/G,EAAK7L,SAAS0B,OAEpDmR,EAAW7Q,EAAY4Q,GAAW5W,KAAKyE,OAK/C2H,MAAW7I,EAAU,gBAAiBkB,GACtCzE,KAAKqQ,WAAU,SAACjM,GAA8B,OAAA6I,GAAe,CAAE7I,MAAKA,EAAEK,IAAGA,OAEpEoS,GACH7W,KAAKsQ,aAAY,GAGnBtQ,KAAK8W,eAAerS,GACpBzE,KAAKmU,cAAc9R,KAAK,CAAEW,KAAM2H,EAAAA,cAAcoM,OAAQtS,IAAGA,OAmB3DyP,EAAAvU,UAAAqX,aAAA,SAAaC,GACX,IAAMxS,EAAMuB,EAAYhG,KAAKsE,QAC7B8H,MAAW7I,EAAU,gBAAiBkB,GACtCzE,KAAKkS,OAAOzN,EAAKwS,IAYnB/C,EAAAvU,UAAAuX,UAAA,SAAU3K,GACR,IAAMjI,EAASgI,GAAkBC,EAAavM,KAAKyE,IAAKzE,KAAKsE,aAE9CwD,IAAXxD,IAIJ8H,MAAW7I,EAAU,aAAce,GACnCtE,KAAKmX,WAAW7S,KAWlB4P,EAAAvU,UAAAyX,UAAA,SAA+B3S,GAA/B,IAAAoL,EAAA7P,KACQqV,EAAUrP,EAAYvB,GACxB6B,EAAQ+O,KACOA,EAAQ5J,OAAM,SAACxH,GAAO,OAAA4L,EAAKvL,OAAOxD,QAAQmD,IAAO,OAGpEmI,MAAW7I,EAAU,aAAckB,GACnCzE,KAAKqQ,WAAU,SAACjM,GAEd,IAAMiT,EAAU5X,MAAM+W,KAAK,IAAIvP,IAAGpE,EAAMuB,EAAME,OAAwB+Q,KACtE,OAAAlV,EAAAA,EAAA,GACKiE,GAAK,CACRE,OAAQ+S,UAadnD,EAAAvU,UAAA2X,aAAA,SAAkC7S,GAAlC,IAAAoL,EAAA7P,KACQqV,EAAUrP,EAAYvB,GACxB6B,EAAQ+O,IACMA,EAAQzN,MAAK,SAAC3D,GAAO,OAAA4L,EAAKvL,OAAOxD,QAAQmD,IAAO,OAGlEmI,MAAW7I,EAAU,gBAAiBkB,GACtCzE,KAAKqQ,WAAU,SAACjM,GACd,OAAAjE,EAAAA,EAAA,GACKiE,GAAK,CACRE,OAAQ7E,MAAMyE,QAAQE,EAAME,QAAUF,EAAME,OAAOQ,QAAO,SAACyS,GAAc,OAAgC,IAAhClC,EAAQvU,QAAQyW,MAAqB,YAcpHrD,EAAAvU,UAAA6X,aAAA,SAAkC/S,GADlC,IAAAoL,EAAA7P,KAEQqV,EAAUrP,EAAYvB,GACtBgT,EAAe,SAACd,GAAW,OAAA,SAAC1S,GAAO,OAAA4L,EAAKvL,OAAOoE,SAASzE,KAAQ0S,IAChEA,EAAStB,EAAQvQ,OAAO2S,GAAa,IACrCzQ,EAAMqO,EAAQvQ,OAAO2S,GAAa,IACxCzX,KAAKsX,aAAaX,GAClB3W,KAAKoX,UAAUpQ,GACfoF,MAAW9I,EAAU,kBA0BvB4Q,EAAAvU,UAAA+X,cAAA,SAAc3H,EAAmB4H,QAAnB,IAAA5H,IAAAA,EAAA,SAAmB,IAAA4H,IAAAA,EAAA,IAC/B,IAAMC,EAAwC,CAAEhJ,KAAM,MAAM5O,KAAK0J,UAAa1E,MAAOhF,KAAKgF,OAE1F,OADAhF,KAAK6X,GAAK,IAAIC,GAAc/H,EAAY5P,EAAAA,EAAA,GAAOyX,GAAaD,IACrD3X,KAAK6X,IAId3D,EAAAvU,UAAAmT,QAAA,WACEvE,EAAA5O,UAAMmT,QAAOjT,KAAAG,MACTA,KAAK6X,cAAc3D,GACrBlU,KAAK6X,GAAG/E,UAEV9S,KAAKmU,cAAc7E,YAIrB4E,EAAAvU,UAAAmV,qBAAA,SAAqBnC,EAAyBoF,GAC5C,OAAOA,GAIT7D,EAAAvU,UAAA2U,kBAAA,SAAkBnO,GAChB,OAAOA,GAIT+N,EAAAvU,UAAAqW,oBAAA,SAAoB7P,GAClB,OAAOA,GAGT7G,OAAAqC,eAAYuS,EAAAvU,UAAA,MAAG,KAAf,WACE,OAAOK,KAAKoQ,SAAS3L,qCAGvBnF,OAAAqC,eAAYuS,EAAAvU,UAAA,WAAQ,KAApB,WACE,OAAOK,KAAKoQ,SAASpM,0CAGvB1E,OAAAqC,eAAYuS,EAAAvU,UAAA,SAAM,KAAlB,WACE,OAAOK,KAAKoQ,SAAS9L,wCAGf4P,EAAAvU,UAAAwX,WAAR,SAAmB1S,GACjBzE,KAAKqQ,WAAU,SAACjM,GACd,OAAAjE,EAAAA,EAAA,GACKiE,GAAK,CACRE,OAAQG,QAKNyP,EAAAvU,UAAA8U,iBAAR,SAAyBzN,GAAzB,IAAA6I,EAAA7P,UAAyB,IAAAgH,IAAAA,GAAA,GACvB,IAEIgR,EAFEvT,EAAMzE,KAAKyE,IACXwT,EAAS5R,EAAWrG,KAAK6X,GAAGK,sBAE5BC,EAAW,SAAClU,SACVwB,EAAUoK,EAAK7L,SAASC,GACxB4T,EAAKI,EAASpI,EAAKgI,GAAGK,qBAAqBzS,GAAWoK,EAAKgI,GAAGK,qBACpE,OAAA/X,IAAAqE,EAAA,IACGqL,EAAK7K,OAAQS,EAAQoK,EAAK7K,OAAMR,GAC9BqT,IAKLG,EADEhR,EACWhH,KAAKyE,IAAIK,QAAO,SAACb,GAAO,OAAA+I,GAAY6C,EAAKgI,GAAG7T,SAASC,OAAM0E,IAAIwP,GAE/D1T,EAAIkE,IAAIwP,GAGvBnR,EAAMhH,KAAK6X,GAAG7Q,IAAIgR,GAAchY,KAAK6X,GAAGxD,IAAI2D,IAGtC9D,EAAAvU,UAAA6U,kBAAR,WACE,OAAOxU,KAAKkW,eAA8D,IAA9ClJ,GAAYhN,KAAK6X,GAAGK,uBAG1ChE,EAAAvU,UAAAmX,eAAR,SAAuBrS,GACjBzE,KAAKkW,cACPlW,KAAK6X,GAAGlB,OAAOlS,IAIXyP,EAAAvU,UAAAuW,WAAR,WACE,OAAOlW,KAAK6X,cAAcC,IA1Y5B7W,EAAA,CADC2O,8IAsRD3O,EAAA,CADC2O,sDACuC,qBAAA,oBAADwI,GAAAA,GAAC5K,EAAAlO,yEAuH1C4U,GAjmBoHpE,mBAumBlH,SAAAgI,EAAY/H,EAAmB4H,eAAnB,IAAA5H,IAAAA,EAAA,SAAmB,IAAA4H,IAAAA,EAAA,IAC7BpJ,EAAA1O,KAAAG,KAAM+P,EAAc4H,IAAY3X,KAoBpC,OAxB8DF,EAAAgY,EAAAvJ,GAqB5DuJ,EAAAnY,UAAA0Y,sBAAA,SAAoDF,GAClDnY,KAAKkY,qBAAuBC,GAEhCL,GAxB8D5D,aCxoB9CoE,KACd,OAAOxT,EAAAA,QAAO,SAACxC,GAAsC,OAAAA,MAAAA,cCjBvCiW,GAASjW,GACvB,MAAwB,iBAAVA,oBCad,SAAAkW,EAAsBtH,GAAAlR,KAAAkR,MAAAA,EACpBlR,KAAKyY,UAAYvH,EACb9E,OAEFjC,EAAY+G,EAAMxH,WAAa1J,MAmHrC,OA9FEwY,EAAA7Y,UAAA+Y,OAAA,SAAUzH,GACR,IAAI0H,ECvCuBC,EDwC3B,GAAIvS,EAAW4K,GACb0H,EAAQ1H,OACH,GAAIsH,GAAStH,GAClB0H,EAAQ,SAAAvU,GAAS,OAAAA,EAAM6M,QAClB,CAAA,GAAIxR,MAAMyE,QAAQ+M,GACvB,OAAOjR,KAAKkR,MACTF,SAAQ,SAAA5M,GAAS,OAAAA,KACjB+M,KACC7J,EAAAA,sBChDqBsR,EDgDY3H,EC/ClC,SAAa4H,EAAWC,GAC7B,IAAMC,EAAQ1S,EAAWuS,EAAY,IAErC,OAKO,IALAA,EAAYhR,MAAK,SAAAoR,GACtB,OAAGD,EACMC,EAAUH,KAAeG,EAAUF,GAErCD,EAAUG,KAAeF,EAAUE,SDyCtCrQ,EAAAA,KAAI,SAAAvE,GACF,OAAIiC,EAAW4K,EAAQ,IACbA,EAAkCtI,KAAI,SAAAsQ,GAAQ,OAAAA,EAAK7U,MAGrD6M,EAAwBnK,QAAO,SAACC,EAAKmS,GAE3C,OADAnS,EAAImS,GAAY9U,EAAM8U,GACfnS,IACN,QAIT4R,EAAQ,SAAAvU,GAAS,OAAAA,GAGnB,OAAOpE,KAAKkR,MAAMF,QAAQ2H,IAU5BH,EAAA7Y,UAAAwZ,cAAA,WACE,OAAOnZ,KAAK0Y,QAAO,SAAAtU,GAAS,OAACA,EAAmC2I,YAUlEyL,EAAA7Y,UAAAyZ,YAAA,WACE,OAAOpZ,KAAK0Y,QAAO,SAAAtU,GAAS,OAACA,EAAmCxB,UAWlE4V,EAAA7Y,UAAAkR,SAAA,WACE,OAAO7Q,KAAKkR,MAAMd,UAcpBoI,EAAA7Y,UAAA0Z,eAAA,WACE,OAAOrZ,KAAKkR,MAAMG,SAAS7B,gBAW7BgJ,EAAA7Y,UAAA2Z,YAAA,WACE,OAAOtZ,KAAKkR,MAAMG,SAAS/O,OAI7BhD,OAAAqC,eAAI6W,EAAA7Y,UAAA,SAAM,KAAV,WACE,OAAOK,KAAKC,YAA0B,kDAE1CuY,cEtHgBe,GAAWtV,EAAIgN,GAC7B,OAAO,SAASjN,GACd,IAAMwB,EAASxB,EAASC,GAExB,IAAG+I,GAAYxH,GAIf,OAAIyL,EAIDsH,GAAStH,GACHzL,EAAOyL,GAGRA,EAAqBzL,GAPpBA,YCxBGgU,GAActU,EAASoM,GACrCpM,EAAQqG,OAASrG,EAAQqG,QAAW+F,GAAUA,EAAO/F,OACrDrG,EAAQsG,YAActG,EAAQsG,aAAgB8F,GAAUA,EAAO9F,+BCsC/D,SAAAiO,EAAYvI,EAA+BhM,QAAA,IAAAA,IAAAA,EAAA,IAA3C,IAAA2K,EACEtB,EAAA1O,KAAAG,KAAMkR,IAAMlR,YAD6B6P,EAAA3K,QAAAA,EAEzC2K,EAAK4I,UAAYvH,IAkWrB,OA3W8GpR,EAAA2Z,EAAAlL,GAyC5GkL,EAAA9Z,UAAA+Z,UAAA,SACExU,GADF,IAAA2K,EAAA7P,KAKE,YAJA,IAAAkF,IAAAA,EAAA,CACEyU,UAAU,IAGL3Z,KAAK0Y,QAAO,SAACtU,GAAU,OAAAA,EAAMJ,YAAUmN,KAAKxI,EAAAA,KAAI,WAAM,OAAAkH,EAAK+J,OAAO1U,QA+B3EuU,EAAA9Z,UAAAia,OAAA,SAAO1U,GACL,YADK,IAAAA,IAAAA,EAAA,CAAuCyU,UAAU,EAAOtO,cAAUvD,EAAWwD,aAASxD,IACvF5C,EAAQyU,SACH5N,GAAc/L,KAAK6Q,WAAY3L,IAExCsU,GAActU,EAASlF,KAAKsR,QAAUtR,KAAKkF,SAEpCkG,GAAgBpL,KAAK6Q,WAAY3L,KAa1CuU,EAAA9Z,UAAAka,WAAA,SAAcpV,EAAewM,GAC3B,OAAKxM,GAAQA,EAAI/D,OAEVV,KAAK0Y,QAAO,SAACtU,GAAU,OAAAA,EAAMJ,YAAUmN,KAC5CxI,EAAAA,KAAI,SAAC3E,GAAa,OCrIyB8V,EDqIH,SAAC7V,GAAO,OAAAsV,GAAUtV,EAAIgN,EAAdsI,CAAuBvV,IAApCS,ECpI5BqC,QAAO,SAACJ,EAAQpE,EAAOsG,EAAOmR,GACvC,IAAM5Q,EAAM2Q,EAAWxX,EAAOsG,EAAOmR,GAIrC,YAHYjS,IAARqB,GACFzC,EAAO/D,KAAKwG,GAEPzC,IACN,QAP4CoT,KDsI3CzS,KAJ8BoI,EAAAA,GAAG,KAuBrCgK,EAAA9Z,UAAAqa,aAAA,SAAgBC,EAAmDhJ,GACjE,IAAIhN,EAAKgW,EAOT,OALI5T,EAAW4T,KAEZhW,WF1JkCqR,EAA6BtR,eAClE,IAAsB,IAAAwJ,EAAAxL,EAAA1C,OAAOmO,KAAKzJ,IAASiB,EAAAuI,EAAAnL,QAAA4C,EAAA1C,KAAA0C,EAAAuI,EAAAnL,OAAE,CAAzC,IAAMqD,EAAQT,EAAA3C,MAChB,IAAqC,IAAlCgT,EAAUtR,EAAS0B,IACpB,OAAOA,qGEuJKwU,CAAsBD,EAAeja,KAAK6Q,WAAW7M,WAG9DhE,KAAK0Y,QAAO,SAACtU,GAAU,OAAAA,EAAMJ,YAAUmN,KAAKxI,EAAAA,IAAI4Q,GAAUtV,EAAIgN,IAAW3J,EAAAA,yBAUlFmS,EAAA9Z,UAAA4Z,UAAA,SAAUtV,GACR,OAAOjE,KAAK6Q,WAAW7M,SAASC,IAUlCwV,EAAA9Z,UAAAwa,eAAA,WACE,OAAOna,KAAK0Y,QAAO,SAACtU,GAAU,OAACA,EAAsCE,WAUvEmV,EAAA9Z,UAAAya,YAAA,WACE,OAAOpa,KAAK6Q,WAAWvM,QAazBmV,EAAA9Z,UAAA0a,aAAA,SAAgBpJ,GAAhB,IAAApB,EAAA7P,KACE,OAAIkE,EAAQlE,KAAKsa,aACRta,KAAKma,iBAAiBhJ,KAAKoJ,EAAAA,WAAU,SAAC9V,GAAQ,OAAAoL,EAAKgK,WAAWpV,EAAKwM,OAErEjR,KAAKma,iBAAiBhJ,KAAKoJ,EAAAA,WAAU,SAAC9V,GAAQ,OAAAoL,EAAKmK,aAAavV,EAAKwM,QAW9EwI,EAAA9Z,UAAA2a,UAAA,WAAA,IAAAzK,EAAA7P,KACQuU,EAAWvU,KAAKoa,cACtB,OAAIlW,EAAQqQ,GACHA,EAAS5L,KAAI,SAAC1E,GAAO,OAAA4L,EAAKgB,WAAW7M,SAASC,MAEhDyK,GAAU6F,GAAYvU,KAAKuZ,UAAUhF,QAAYzM,GAW1D2R,EAAA9Z,UAAA6a,YAAA,SAAYlF,GAAZ,IAAAzF,EAAA7P,KACE,OAAOA,KAAK0Y,QAAO,SAACtU,GAAU,OAAAA,EAAMJ,YAAUmN,KAAKxI,EAAAA,KAAI,WAAM,OAAAkH,EAAK4K,SAASnF,QAW7EmE,EAAA9Z,UAAA8a,SAAA,SAASnF,GACP,OAAIjP,EAAWiP,GACNtV,KAAK4Z,SAAS9U,OAAOwQ,GAAW5U,OAElCV,KAAK6Q,WAAWpM,IAAI/D,QAc7B+Y,EAAA9Z,UAAA+a,WAAA,SAAczJ,GACZ,OAAOjR,KAAK2a,UAAS,SAAClW,GAAQ,OAAAA,EAAIA,EAAI/D,OAAS,KAAIuQ,IAcrDwI,EAAA9Z,UAAAib,YAAA,SAAe3J,GACb,OAAOjR,KAAK2a,UAAS,SAAClW,GAAQ,OAAAA,EAAI,KAAIwM,IAmBxCwI,EAAA9Z,UAAAkb,mBAAA,SAAmBC,GACjB,GAAIhV,EAAMgV,GACR,OAAO9a,KAAKkR,MAAM6J,oBAGpB,IAAM9J,EAAU/M,EAAQ4W,GAAmB,SAACrX,GAAiC,OAAAA,GAAS,SAACe,GAAkC,OAA7BA,EAAAC,KACtFuW,EAAUhV,EAAY8U,GAE5B,OAAO9a,KAAKkR,MAAM6J,oBAAoB5J,KACpCrM,EAAAA,QAAO,SAACN,OAAExB,EAAIwB,EAAAxB,KAA6B,OAAAgY,EAAQtS,SAAS1F,MAC5D2F,EAAAA,KAAI,SAAClF,GAAW,OAAAwN,EAAQxN,QAkB5BgW,EAAA9Z,UAAAoE,UAAA,SAAUkX,GAAV,IAAApL,EAAA7P,KACE,OAAI8F,EAAMmV,GACDjb,KAAK6Q,WAAWpM,IAAI/D,OAAS,EAGlC2F,EAAW4U,GACNjb,KAAK4Z,SAAShS,KAAKqT,GAGxB/W,EAAQ+W,GACHA,EAAaxP,OAAM,SAACxH,GAAO,OAACA,KAAc4L,EAAKgB,WAAW7M,YAG3DiX,KAAwBjb,KAAK6Q,WAAW7M,UAYlDyV,EAAA9Z,UAAAub,UAAA,SAAUjX,GACR,IAAMK,EAAStE,KAAK6Q,WAAWvM,OACzB6W,EAAejS,EAAUjF,GAC/B,OAAIxE,MAAMyE,QAAQI,GACZ6W,EACK7W,EAAOoE,SAASzE,GAElBK,EAAO5D,OAAS,EAElBya,EAAe7W,IAAWL,EAAKiF,EAAU5E,IAoBlDmV,EAAA9Z,UAAAyb,cAAA,WACEpb,KAAK6X,GAAK,IAAIwD,GAAcrb,KAAKyY,UAAUZ,KAGrC4B,EAAA9Z,UAAAgb,SAAR,SAAoBhC,EAAkC1H,GAAtD,IAAApB,EAAA7P,KACE,OAAOA,KAAK0Y,QAAO,SAACtU,GAAU,OAAAA,EAAMK,OAAc0M,KAChDxI,EAAAA,IAAIgQ,GACJrR,EAAAA,uBACAiT,EAAAA,WAAU,SAACtW,GAAe,OAAA4L,EAAKmK,aAAa/V,EAAIgN,QAGtDwI,GA3W8GjB,mBA+W5G,SAAA6C,EAAYnK,UACV3C,EAAA1O,KAAAG,KAAMkR,IAAMlR,KAEhB,OAJ8DF,EAAAub,EAAA9M,GAI9D8M,GAJ8D5B,aExY9C5I,GAAUvI,EAAUJ,GAElC,OAA+B,IAA3BA,EAAKoT,MAAM,KAAK5a,OACX4H,EAEeJ,EACrBoT,MAAM,KACN/Q,MAAM,GACNgR,KAAK,KACeD,MAAM,KAAKxU,QAAO,SAAEC,EAAUyU,GAAkB,OAAAzU,GAAOA,EAAIyU,KAAOlT,YCT3EmT,GAASnT,EAAUJ,EAAciB,EAAUgN,QAAA,IAAAA,IAAAA,GAAA,GACzD,IAAMmF,EAAQpT,EAAKoT,MAAM,KAEzB,GAAqB,IAAjBA,EAAM5a,OACR,OAAAP,EAAAA,EAAA,GAAYmI,GAAQa,GAGtBb,EAAGnI,EAAA,GAAQmI,GAEX,IAAMoT,EAAYJ,EAAM5a,OAAS,EAcjC,OAbwBwH,EAAKoT,MAAM,KAAK/Q,MAAM,GAE9BzD,QAAO,SAACC,EAAKyU,EAAM5S,GACjC,OAAIA,IAAU8S,GACZ3U,EAAIyU,GAAKrb,EAAA,GAAQ4G,EAAIyU,IACdzU,GAAOA,EAAIyU,KAGpBzU,EAAIyU,GAAQrF,GAAW1W,MAAMyE,QAAQ6C,EAAIyU,MAAWxT,EAASjB,EAAIyU,IAASrS,EAAGhJ,EAAAA,EAAA,GAAQ4G,EAAIyU,IAAUrS,GAE5FpC,GAAOA,EAAIyU,MACjBlT,GAEIA,EClBT,IAAIqT,IAAoB,EAElBC,GAAoB,IAAIrS,EAAAA,cAAc,YAM5BsS,GAAqB3Y,GACnCyY,GAAoBzY,WAGN4Y,KACd,OAAOH,GAeT,SAASI,GAAUC,GACjB,OALiBjW,EAKHiW,IAJF3V,EAAWN,EAAEkW,OAIMC,EAAAA,aAAaF,GACnCxF,EAAAA,KAAKwF,GAGPvM,EAAAA,GAAGuM,GATZ,IAAmBjW,oBCzBjB,SAAAoW,EAAgCC,EAAuB9K,GAAvBtR,KAAAoc,MAAAA,EAC1B9K,GAAUA,EAAO+K,SACfpT,IAAiBH,YACnB9I,KAAKsc,QAAQhL,EAAO+K,SA4F5B,OAtFYF,EAAAxc,UAAA4c,SAAV,WACE,OAAOvc,KAAKoc,OAIJD,EAAAxc,UAAA6c,SAAV,WACE,OAAOxc,KAAKuc,WAAW9D,WAOf0D,EAAAxc,UAAA8c,cAAV,SAAwB/W,GACtB,OAAOgJ,GAAUhJ,IAITyW,EAAAxc,UAAA+c,aAAV,SAAuBhX,EAAeiX,GAAtC,IAAA9M,EAAA7P,KACE,OAAIA,KAAKyc,cAAc/W,GACb1F,KAAKuc,WAAkCvC,aAAatU,GAAUyL,KAAKmH,MAGzEqE,EACK3c,KAAKuc,WAAW7D,QAAO,SAACtU,GAAU,OAAAyM,GAASzM,EAAOyL,EAAK+M,cAAcD,OAGvE3c,KAAKuc,WAAW7D,UAGfyD,EAAAxc,UAAAkd,UAAV,SAAoBnX,EAAeiX,GACjC,GAAI3c,KAAKyc,cAAc/W,GACrB,OAAQ1F,KAAKuc,WAAkChD,UAAU7T,GAG3D,IAAMtB,EAAQpE,KAAKuc,WAAW1L,WAE9B,OAAI8L,EACK9L,GAASzM,EAAOpE,KAAK4c,cAAcD,IAGrCvY,GAGC+X,EAAAxc,UAAAid,cAAV,SAAwB1U,GACtB,OAAUlI,KAAK0J,UAAS,IAAIxB,GAG9B5I,OAAAqC,eAAcwa,EAAAxc,UAAA,YAAS,KAAvB,WACE,OAAOK,KAAKwc,WAAW9S,2CAIfyS,EAAAxc,UAAAmd,YAAV,SAAsBjX,EAAUH,EAAWiX,EAAmBxG,GAA9D,IAAAtG,EAAA7P,KACE,QAD4D,IAAAmW,IAAAA,GAAA,GACxDnW,KAAKyc,cAAc/W,GAAW,CAChC,IAAMwL,EAAQlR,KAAKwc,WAEnBrG,EAAUjF,EAAMiF,QAAQzQ,EAAUG,GAAYqL,EAAMgB,OAAOxM,EAAUG,OAChE,CACL,GAAI8W,EAKF,YAJA3c,KAAKwc,WAAWnM,WAAU,SAACjM,GACzB,OAAOqX,GAASrX,EAAOyL,EAAK+M,cAAcD,GAAW9W,GAAU,MAMnE,IAAM+M,EAAYuD,EAAUtQ,EAAW,SAACzB,GAAU,OAAAjE,EAAAA,EAAA,GAAMiE,GAAUyB,IAElE7F,KAAKwc,WAAWnM,UAAUuC,KAOtBuJ,EAAAxc,UAAA2c,QAAR,SAAgB5Q,GAAhB,IAAAmE,EAAA7P,KACQ+c,EAAW/c,KAAKwc,WAAW3K,MACjC7R,KAAKwc,WAAW3K,MAAQ,eAAC,IAAAmL,EAAA,GAAAlZ,EAAA,EAAAA,EAAArD,UAAAC,OAAAoD,IAAAkZ,EAAAlZ,GAAArD,UAAAqD,GAEvB8M,YAAW,WACTmM,EAASpc,MAAMkP,EAAK2M,WAAYQ,GAChCtR,SAIRyQ,KCxFac,GAA0B,CACrCC,WAAY,SAACC,EAAM1X,GAAY,OAAA2X,KAAKC,UAAUF,KAAUC,KAAKC,UAAU5X,cAGzD6X,GAAcC,EAAWC,GAEvC,OAD8BA,EAAKlC,MAAM,KACtBxU,QAAO,SAACwB,EAAKlH,GAAQ,OAACkH,GAAoB,cAAbA,EAAIlH,GAAuBkH,EAAIlH,QAAO0G,IAAYyV,sBAiBlG,SAAAE,EAAsBrB,EAA+BY,EAA0CU,GAA/F,IAAA7N,EACEtB,EAAA1O,KAAAG,KAAMoc,IAAMpc,KAEZ,GAHoB6P,EAAAuM,MAAAA,EAA+BvM,EAAAmN,OAAAA,EAA0CnN,EAAA6N,UAAAA,EARvF7N,EAAA8N,MAAQ,IAAI5O,EAAAA,iBAAgB,GAE5Bc,EAAAvL,QAAS,EACTuL,EAAA+N,OAAS,IAAIvU,EAAAA,QAErBwG,EAAAgO,SAAgChO,EAAK8N,MAAMnO,eAAe2B,KAAK7J,EAAAA,wBAC/DuI,EAAAiO,OAASjO,EAAK+N,OAAOpO,eAInBK,EAAKmN,OAAM7c,EAAAA,EAAA,GAAQ8c,IAA4BD,GAC3CnN,EAAKmN,OAAOe,cAAe,CAC7B,IAAMC,EAAYhY,EAAY6J,EAAKmN,OAAOe,eACtC3B,aAAiB3C,IAAeuE,EAAUtV,SAAS,cAAgBsV,EAAUtV,SAAS,QACxFsV,EAAUrb,KAAK,OAEjBkN,EAAKmN,OAAOe,cAAgBC,WAyGlC,OA3HmDle,EAAA2d,EAAAlP,GAsBjDkP,EAAA9d,UAAAkS,MAAA,SAAMmL,QAAA,IAAAA,IAAAA,EAAA,IACJ,IAAIiB,EAAeje,KAAKmd,KACpB9W,EAAW2W,EAAOkB,YAElBD,EADEje,KAAKyc,cAAczc,KAAK0d,WACXV,EAAOkB,SAASle,KAAKmd,KAAOnd,KAAKuc,WAAkChD,UAAUvZ,KAAK0d,YAElFV,EAAOkB,SAASle,KAAKmd,KAAOnd,KAAKuc,WAA4B1L,aAGhFvN,EAAU,wBACVtD,KAAK8c,YAAYmB,EAAcje,KAAK0d,WACpC1d,KAAK4d,OAAOvb,QAGdob,EAAA9d,UAAAwe,QAAA,WAQE,OAPKne,KAAKsE,OAIRtE,KAAKmd,KAAOnd,KAAKoe,YAHjBpe,KAAKqe,WACLre,KAAKsE,QAAS,GAIhBtE,KAAKse,iBAAgB,GACdte,MAGTyd,EAAA9d,UAAA4e,QAAA,WACE,QAASve,KAAK2d,MAAMrb,OAGtBmb,EAAA9d,UAAA6e,QAAA,WACE,QAASxe,KAAKye,WAGhBhB,EAAA9d,UAAAmT,QAAA,WACE9S,KAAKmd,KAAO,KACZnd,KAAK0e,cAAgB1e,KAAK0e,aAAaC,cACvC3e,KAAK4d,QAAU5d,KAAK4d,OAAOtO,YAG7BmO,EAAA9d,UAAAif,YAAA,SAAYpB,GACV,IAAML,EAAOnd,KAAKye,UAEZI,EAAmBvB,GADRtd,KAAKuc,WAA4B1L,WACF2M,GAC1CsB,EAAgBxB,GAAcH,EAAMK,GAE1C,OAAOxd,KAAKgd,OAAOE,WAAW2B,EAAkBC,IAGlDrB,EAAA9d,UAAA8e,QAAA,WACE,OAAOze,KAAKmd,MAGNM,EAAA9d,UAAA0e,SAAR,WAAA,IAAAxO,EAAA7P,KACEA,KAAKmd,KAAOnd,KAAKoe,WAEjB,IAAMW,EAAS/e,KAAKgd,OAAOe,cACtB/d,KAAKgd,OAAOe,cAAkCpV,KAAI,SAACT,GAClD,OAAA2H,EAAKuM,MACF1D,QAAO,SAACtU,GAAU,OAAAA,EAAM8D,MACxBiJ,KACCxI,EAAAA,KAAI,SAACQ,GAAQ,MAAA,CACXA,IAAGA,EACH6V,WAAY9W,UAIpB,CAAClI,KAAK0c,aAAa1c,KAAK0d,YAC5B1d,KAAK0e,aAAeO,EAAAA,cAAate,WAAA,EAAAkC,EAAIkc,IAClC5N,KAAKjO,EAAAA,KAAK,IACVwO,WAAU,SAACU,GACV,IAAIpF,GAAY6C,EAAKsN,MAArB,CAEA,IAAM+B,EAAW9M,EAAaxK,MAAK,SAACxD,GAClC,IAAM+Y,EAAO/Y,EAAM4a,WAAanP,EAAKsN,KAAK/Y,EAAM4a,YAAqBnP,EAAKsN,KACpEgC,EAAY/a,EAAM4a,WAAa5a,EAAM+E,IAAM/E,EAEjD,OAAOyL,EAAKmN,OAAOE,WAAWC,EAAMgC,MAGtCtP,EAAKyO,gBAAgBY,QAInBzB,EAAA9d,UAAA2e,gBAAR,SAAwBC,GACtBve,KAAK2d,MAAMtb,KAAKkc,IAGVd,EAAA9d,UAAAye,SAAR,WACE,IAAIjB,EAAoBnd,KAAK6c,UAAU7c,KAAK0d,WAI5C,OAHI1d,KAAKgd,OAAOe,gBACdZ,EAAOnd,KAAKof,iBAAiBjC,IAExBA,GAGDM,EAAA9d,UAAAyf,iBAAR,SAAyBL,GACvB,OAAQ/e,KAAKgd,OAAOe,cAAkCjX,QAAO,SAACuY,EAASnX,GAErE,OADAmX,EAAQnX,GAAQ6W,EAAO7W,GAChBmX,IACN,KAEP5B,GA3HmDtB,kBCdjD,SAAAmD,EAAgClD,EAAmCnZ,GAAnCjD,KAAAoc,MAAAA,EAAmCpc,KAAAiD,UAAAA,EAFzDjD,KAAAgE,SAAW,IAAIub,IA4J3B,OArJYD,EAAA3f,UAAA4Z,UAAV,SAAoBtV,GAClB,OAAOjE,KAAKgE,SAASwb,IAAIvb,IAMjBqb,EAAA3f,UAAAoE,UAAV,SAAoBE,GAClB,OAAOjE,KAAKgE,SAASoD,IAAInD,IAMjBqb,EAAA3f,UAAA8f,aAAV,SAAuBxb,GAErB,OADAjE,KAAK8S,QAAQ7O,GACNjE,KAAKgE,SAAS0b,OAAOzb,IAMpBqb,EAAA3f,UAAAggB,aAAV,SAAuB1b,EAAsB2b,GAC3C,OAAO5f,KAAKgE,SAASqQ,IAAIpQ,EAAI2b,IAMrBN,EAAA3f,UAAAkgB,OAAV,WACE,OAAO7S,GAAYhN,KAAKiD,WAAajD,KAAKoc,MAAMvL,WAAWpM,IAAMuB,EAAYhG,KAAKiD,YAM1Eqc,EAAA3f,UAAAmgB,YAAV,SAAsBrb,GACpB,OAAOuI,GAAYvI,GAAOzE,KAAK6f,SAAW7Z,EAAYvB,IAU9C6a,EAAA3f,UAAAogB,OAAV,SAAiBtb,EAAyBuW,GAA1C,IAAAnL,EAAA7P,KAOE,QAPwC,IAAAgb,IAAAA,EAAA,IAOpCtM,GAAUjK,GAIZ,GAAIuI,GAAYhN,KAAKiD,WAAY,CAC/B,IAAK,IAAI1C,EAAI,EAAGyf,EAAMvb,EAAI/D,OAAQH,EAAIyf,EAAKzf,IAAK,CAC9C,IAAMmF,EAAWjB,EAAIlE,GACrB,IAAiC,IAA7BP,KAAK+D,UAAU2B,GAAqB,CACtCW,EAAW2U,EAAQiF,YAAcjF,EAAQiF,UAAUva,GACnD,IAAMka,EAAS5f,KAAKkgB,kBAAkBxa,GACtC1F,KAAKgE,SAASqQ,IAAI3O,EAAUka,GAC5BvZ,EAAW2U,EAAQmF,WAAanF,EAAQmF,SAASP,IAIrD5f,KAAKgE,SAASoK,SAAQ,SAACwR,EAAQla,IACE,IAA3BjB,EAAI3D,QAAQ4E,KACdW,EAAW2U,EAAQoF,eAAiBpF,EAAQoF,aAAaR,GACzD/P,EAAK4P,aAAa/Z,WAOtB,CAAA,IAAM2a,EAAOra,EAAYhG,KAAKiD,WAC9B,IAAS1C,EAAI,EAAGyf,EAAMK,EAAK3f,OAAQH,EAAIyf,EAAKzf,IAAK,CACzCmF,EAAW2a,EAAK9f,GAEtB,GAAIkE,EAAI3D,QAAQ4E,IAAa,IAAkC,IAA7B1F,KAAK+D,UAAU2B,GAAqB,CACpEW,EAAW2U,EAAQiF,YAAcjF,EAAQiF,UAAUva,GAC7Cka,EAAS5f,KAAKkgB,kBAAkBxa,GACtC1F,KAAKgE,SAASqQ,IAAI3O,EAAUka,GAC5BvZ,EAAW2U,EAAQmF,WAAanF,EAAQmF,SAASP,QAEjD5f,KAAKgE,SAASoK,SAAQ,SAACwR,EAAQla,IAEE,IAA3BjB,EAAI3D,QAAQ4E,KAAiD,IAA7BmK,EAAK9L,UAAU2B,KACjDW,EAAW2U,EAAQoF,eAAiBpF,EAAQoF,aAAaR,GACzD/P,EAAK4P,aAAa/Z,aAU5B1F,KAAK6f,SAASzR,SAAQ,SAAAnK,GACf4L,EAAK9L,UAAUE,IAAK4L,EAAK8P,aAAa1b,EAAI4L,EAAKqQ,kBAAkBjc,QAQlEqb,EAAA3f,UAAA2gB,UAAV,WACE,OAAOtgB,KAAKoc,MAAM1D,QAAO,SAAAtU,GAAS,OAAAA,EAAMK,QAMhC6a,EAAA3f,UAAA0e,SAAV,SAAmB5Z,GACjBzE,KAAK+f,OAAOtb,IAmBJ6a,EAAA3f,UAAA4gB,UAAV,SAAoB9b,EAAgC+b,GAGlD,IAFA,IAAMH,EAAOrgB,KAAK8f,YAAYrb,GAErBlE,EAAI,EAAGyf,EAAMK,EAAK3f,OAAQH,EAAIyf,EAAKzf,IAAK,CAC/C,IAAM0D,EAAKoc,EAAK9f,GACZP,KAAK+D,UAAUE,IACjBuc,EAAGxgB,KAAKuZ,UAAUtV,MAI1Bqb,oBCxJE,SAAAmB,EAAsBrE,EAA4CY,QAAA,IAAAA,IAAAA,EAAA,IAAlE,IAAAnN,EACEtB,EAAA1O,KAAAG,KAAMoc,EAAOY,EAAO/Z,YAAUjD,YADV6P,EAAAuM,MAAAA,EAA4CvM,EAAAmN,OAAAA,EAN1DnN,EAAA6Q,WAAa,IAAIrX,EAAAA,QACzBwG,EAAA8Q,WAAkCC,EAAAA,MAAM/Q,EAAKuM,MAAM1D,QAAO,SAAAtU,GAAS,OAAAA,EAAMJ,YAAW6L,EAAK6Q,WAAWlR,gBAAgB2B,KAClH0P,EAAAA,UAAU,GACVlY,EAAAA,KAAI,WAAM,OAAAkH,EAAKiR,qBAKfjR,EAAKmN,OAAM7c,EAAAA,EAAA,GAAQ8c,IAA4BD,GAE/CnN,EAAKwO,WACLxO,EAAKyQ,YACFnP,KAAKjO,EAAAA,KAAK,IACVwO,WAAU,SAAAjN,GACT8J,EAAA5O,UAAMogB,OAAMlgB,KAAAgQ,EAACpL,EAAK,CAAE0b,SAAU,SAAAP,GAAU,OAAAA,EAAOzB,kBAgFvD,OA/F0Ire,EAAA2gB,EAAAlS,GAmBxIkS,EAAA9gB,UAAAwe,QAAA,SAAQ1Z,GACN,GAAIzE,KAAKgd,OAAO/Z,WAAawB,EAAK,CAChC,IAAM4R,EAAUrQ,EAAYvB,GAE5B,IAAuB,IADAuB,EAAYhG,KAAKgd,OAAO/Z,WAAW2E,MAAK,SAAA3D,GAAM,OAAAoS,EAAQvV,QAAQmD,IAAO,KAE1F,OAAOjE,KAKX,OAFAA,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEsd,aAC3Bne,KAAK0gB,WAAWre,OACTrC,MAGTygB,EAAA9gB,UAAA6e,QAAA,SAAQva,GACN,QAAIjE,KAAKgE,SAASoD,IAAInD,IACLjE,KAAKuZ,UAAUtV,GAChBua,WAMlBiC,EAAA9gB,UAAAkS,MAAA,SAAMpN,EAAiCuY,QAAA,IAAAA,IAAAA,EAAA,IACrChd,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEgR,MAAMmL,OAMnCyD,EAAA9gB,UAAA4e,QAAA,SAAQta,EAAsBuL,GAC5B,QAD4B,IAAAA,IAAAA,GAAA,GACxBxP,KAAKgE,SAASoD,IAAInD,GAAK,CACzB,IAAMuB,EAASxF,KAAKuZ,UAAUtV,GAC9B,OAAOuL,EAAehK,EAAOqY,SAAWrY,EAAO+Y,UAGjD,OAAO,GAGTkC,EAAA9gB,UAAAohB,UAAA,WACE,OAAO/gB,KAAK8gB,kBAGdL,EAAA9gB,UAAAif,YAAA,SAAY3a,EAAsBuZ,GAChC,GAAIxd,KAAKgE,SAASoD,IAAInD,GAAK,CACzB,IAAMkZ,EAAQnd,KAAKuZ,UAAUtV,GAAYwa,UAEnCI,EAAmBvB,GADTtd,KAAKoc,MAAM7C,UAAUtV,GACWuZ,GAC1CsB,EAAgBxB,GAAcH,EAAMK,GAE1C,OAAOxd,KAAKgd,OAAOE,WAAW2B,EAAkBC,GAGlD,OAAO,MAGT2B,EAAA9gB,UAAAmT,QAAA,SAAQrO,GACNzE,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEiS,aAEtBrO,GACHzE,KAAK0gB,WAAWpR,YAIVmR,EAAA9gB,UAAAugB,kBAAV,SAA4Bjc,GAC1B,OAAO,IAAIwZ,GAAiBzd,KAAKoc,MAAOpc,KAAKgd,OAAQ/Y,IAG/Cwc,EAAA9gB,UAAAmhB,eAAR,mBACQE,EAAchhB,KAAK8f,kBACzB,IAAiB,IAAAmB,EAAAjf,EAAAgf,GAAWE,EAAAD,EAAA5e,QAAA6e,EAAA3e,KAAA2e,EAAAD,EAAA5e,OAAE,CAAzB,IAAM4B,EAAEid,EAAA5e,MACX,GAAItC,KAAKuZ,UAAUtV,GAAIsa,UACrB,OAAO,oGAGX,OAAO,GAEXkC,GA/F0InB,ICgBpI6B,GAAqC,CACzCC,eAAe,EACfC,OAAO,EACPC,UAAW,EACXC,kBAAczZ,EACd0Z,qBAAqB,kBAyBrB,SAAAC,EAAsBrF,EAAkC9K,QAAA,IAAAA,IAAAA,EAAA,IAAxD,IAAAzB,EACEtB,EAAA1O,KAAAG,KAAMoc,EAAO,CACXC,QAAS,WACPxM,EAAK6R,SAAU,EACf7R,EAAKiD,QAAQ,CAAE6O,YAAY,EAAMC,YAAa,QAEhD5hB,KANkB6P,EAAAuM,MAAAA,EAAkCvM,EAAAyB,OAAAA,EApBxDzB,EAAA9N,SAAW,IAAIwd,IAGP1P,EAAAgS,MAAQ,IAAItC,IAGZ1P,EAAAiS,WAAuD,CAC7DF,YAAa,EACbG,QAAS,EACTC,MAAO,EACPC,SAAU,EACVvN,KAAM,IAOA7E,EAAA6R,SAAU,EAoBlB7R,EAAAqS,WAAarS,EAAKuM,MAAMjD,gBAAgBhI,KAAKgR,EAAAA,MAAM,IAXjDtS,EAAKyB,OAAMnR,EAAAA,EAAA,GAAQghB,IAAsB7P,GACnC,IAAA9M,EAA8BqL,EAAKyB,OAAjCgQ,EAAS9c,EAAA8c,UAAEC,EAAY/c,EAAA+c,oBAC/B1R,EAAKuS,KAAO,IAAIrT,EAAAA,gBAAgBuS,GAC5BpF,EAAAA,aAAaqF,KACf1R,EAAKwS,uBAAyBd,EAAa7P,WAAU,WAAM,OAAA7B,EAAK8R,mBAgQtE,OAjSgE7hB,EAAA2hB,EAAAlT,GA6C9DjP,OAAAqC,eAAI8f,EAAA9hB,UAAA,cAAW,KAAf,WACE,OAAOK,KAAKoiB,KAAK5S,gDAMnBlQ,OAAAqC,eAAI8f,EAAA9hB,UAAA,cAAW,KAAf,WACE,OAAOK,KAAK8hB,WAAWF,6CAMzBtiB,OAAAqC,eAAI8f,EAAA9hB,UAAA,UAAO,KAAX,WACE,OAA4B,IAArBK,KAAK4hB,6CAMdtiB,OAAAqC,eAAI8f,EAAA9hB,UAAA,SAAM,KAAV,WACE,OAAOK,KAAK4hB,cAAgB5hB,KAAK8hB,WAAWG,0CAO9CR,EAAA9hB,UAAA2iB,aAAA,WAEE,OADAtiB,KAAKsR,OAAO8P,eAAgB,EACrBphB,MAOTyhB,EAAA9hB,UAAA4iB,UAAA,WAEE,OADAviB,KAAKsR,OAAO+P,OAAQ,EACbrhB,MAMTyhB,EAAA9hB,UAAAwQ,WAAA,SAAW7N,QAAA,IAAAA,IAAAA,GAAA,GACTtC,KAAKwc,WAAWrM,WAAW7N,IAO7Bmf,EAAA9hB,UAAAuS,OAAA,SAAOsQ,GACLxiB,KAAK8hB,WAAaU,EAClBxiB,KAAKyiB,QAAQD,EAAS9N,OAOxB+M,EAAA9hB,UAAA8iB,QAAA,SAAQ/N,GAAR,IAAA7E,EAAA7P,KACEA,KAAK6hB,MAAMxN,IAAIrU,KAAK4hB,YAAa,CAAEnd,IAAKiQ,EAAK/L,KAAI,SAACnD,GAAW,OAAAA,EAAOqK,EAAK2M,WAAWxX,YACpFhF,KAAKwc,WAAW3G,WAAWnB,IAM7B+M,EAAA9hB,UAAAgiB,WAAA,SAAWzc,QAAA,IAAAA,IAAAA,EAAA,IACJlF,KAAK0hB,UACRpe,EAAU,8BAEiB,IAAvB4B,EAAQwd,aAAyB1iB,KAAKsR,OAAOkQ,qBAAuBtc,EAAQwd,aAC9E1iB,KAAKwc,WAAW7F,SAGlB3W,KAAK6hB,MAAQ,IAAItC,IACjBvf,KAAK+B,SAAW,IAAIwd,KAEtBvf,KAAK0hB,SAAU,GAGjBD,EAAA9hB,UAAAgjB,UAAA,SAAUP,GACRpiB,KAAK6hB,MAAMnC,OAAO0C,IAMpBX,EAAA9hB,UAAAmT,QAAA,SAAQtO,OAAAgJ,OAAA,IAAAhJ,EAA8E,GAAEA,EAA9Emd,EAAUnU,EAAAmU,WAAEC,EAAWpU,EAAAoU,YAC3B5hB,KAAKqiB,wBACPriB,KAAKqiB,uBAAuB1D,cAE1BgD,GACF3hB,KAAK2hB,aAEF3U,GAAY4U,IACf5hB,KAAK4iB,QAAQhB,GAEf5hB,KAAK0hB,SAAU,GAMjBD,EAAA9hB,UAAAkjB,aAAA,SAAaT,GACX,OAAOpiB,KAAK4hB,cAAgBQ,GAM9BX,EAAA9hB,UAAAijB,QAAA,SAAQR,GACFA,IAASpiB,KAAK4hB,aAAgB5hB,KAAK8iB,QAAQV,IAC7CpiB,KAAKoiB,KAAK/f,KAAMrC,KAAK8hB,WAAWF,YAAcQ,IAOlDX,EAAA9hB,UAAAojB,SAAA,WACM/iB,KAAK4hB,cAAgB5hB,KAAK8hB,WAAWG,UACvCjiB,KAAK4iB,QAAQ5iB,KAAK8hB,WAAWF,YAAc,IAO/CH,EAAA9hB,UAAAqjB,SAAA,WACMhjB,KAAK8hB,WAAWF,YAAc,GAChC5hB,KAAK4iB,QAAQ5iB,KAAK8hB,WAAWF,YAAc,IAO/CH,EAAA9hB,UAAAsjB,YAAA,WACEjjB,KAAK4iB,QAAQ5iB,KAAK8hB,WAAWG,WAM/BR,EAAA9hB,UAAAujB,aAAA,WACEljB,KAAK4iB,QAAQ,IAMfnB,EAAA9hB,UAAAmjB,QAAA,SAAQV,GACN,OAAOpiB,KAAK6hB,MAAMza,IAAIgb,IAMxBX,EAAA9hB,UAAAwjB,QAAA,SAAQC,GAAR,IAAAvT,EAAA7P,KACMoiB,EAAOpiB,KAAK8hB,WAAWF,YAC3B,OAAI5hB,KAAK8iB,QAAQV,GACRpiB,KAAKqjB,WAAWjB,IAEvBpiB,KAAKmQ,YAAW,GACTqG,EAAAA,KAAK4M,KAAOjS,KACjBoJ,EAAAA,WAAU,SAACjJ,GAMT,OALA8Q,EAAO9Q,EAAOsQ,YACdlS,IAAiB,WACfG,EAAKM,YAAW,GAChBN,EAAKqC,OAAOZ,MAEPzB,EAAKwT,WAAWjB,SAM/BX,EAAA9hB,UAAA4c,SAAA,WACE,OAAOvc,KAAKoc,OAGdqF,EAAA9hB,UAAA2jB,mBAAA,YACkC,IAA5Bxd,EAAM9F,KAAK4hB,eACb5hB,KAAK2iB,UAAU3iB,KAAK4hB,aACpB5hB,KAAK4iB,QAAQ5iB,KAAK4hB,eAIdH,EAAA9hB,UAAA4jB,QAAR,WACE,OAAIvjB,KAAK4M,QACA,GAED5M,KAAK4hB,YAAc,GAAK5hB,KAAK8hB,WAAWC,QAAU,GAGpDN,EAAA9hB,UAAA6jB,MAAR,WACE,OAAIxjB,KAAK6M,OACA7M,KAAK8hB,WAAWE,MAElBhiB,KAAK4hB,YAAc5hB,KAAK8hB,WAAWC,SAMpCN,EAAA9hB,UAAA0jB,WAAR,SAAmBjB,GAAnB,IAAAvS,EAAA7P,KACE,OAAOA,KAAKoc,MAAM1C,UAAU,CAAEC,UAAU,IAAQxI,KAC9CsS,EAAAA,KAAK,GACL9a,EAAAA,KAAI,SAAC3E,GACH,IAAMwe,EAAQriB,EAAAA,EAAA,GACT0P,EAAKiS,YAAU,CAClBpN,KAAM7E,EAAKgS,MAAMrC,IAAI4C,GAAM3d,IAAIkE,KAAI,SAAC1E,GAAO,OAAAD,EAASC,QAGhDO,EAA2BqL,EAAKyB,OAA9B+P,EAAK7c,EAAA6c,MAAED,EAAa5c,EAAA4c,cAqB5B,OAlBIvT,MAAMgC,EAAKiS,WAAWE,SACE,IAAtBQ,EAASP,SACXO,EAASR,MAAQQ,EAAS9N,KAAO8N,EAAS9N,KAAKhU,OAAS,EAExD8hB,EAASR,MAAQQ,EAAST,QAAUS,EAASP,SAE/CpS,EAAKiS,WAAWE,MAAQQ,EAASR,OAG/BX,IACFmB,EAAShM,KAAO3G,EAAK0T,UACrBf,EAAS/L,GAAK5G,EAAK2T,SAGjBpC,IACFoB,EAASkB,aAYnB,SAAuB1B,EAAeD,GAGpC,IAFA,IAAM/B,EAAMnU,KAAK8X,KAAK3B,EAAQD,GACxB7b,EAAM,GACH3F,EAAI,EAAGA,EAAIyf,EAAKzf,IACvB2F,EAAIvD,KAAKpC,EAAI,GAEf,OAAO2F,EAlByB0d,CAAc/T,EAAKiS,WAAWE,MAAOnS,EAAKiS,WAAWC,UAGxES,OA1LbvhB,EAAA,CADCwC,EAAO,8IA+LVge,GAjSgEtF,cAgTnD0H,GAAYpC,kBC7SvB,SAAAqC,EAAsB1H,EAA2B2H,EAA6C/G,QAAA,IAAAA,IAAAA,EAAA,IAA9F,IAAAnN,EACEtB,EAAA1O,KAAAG,KAAMoc,IAAMpc,YADQ6P,EAAAuM,MAAAA,EAA2BvM,EAAAkU,gBAAAA,EAA6ClU,EAAAmN,OAAAA,EAE5FnN,EAAKmN,OAAM7c,EAAQ,CAAE6jB,aAAc,IAAKC,QAAS,YAAaC,WAAW,EAAOC,kBAAmB,SAAApe,GAAK,OAAA8J,EAAKuU,QAAQC,QAAQte,KAASiX,GACtInN,EAAKyU,YAA4C,IAA/B5V,GAAUqV,GAC5BlU,EAAK0U,WAAahM,GAASwL,IAAoBlU,EAAKyU,aAsGxD,OAlHkDxkB,EAAAgkB,EAAAvV,GAehDuV,EAAAnkB,UAAA6kB,QAAA,SAAQC,EAAqBL,GAI3B,OAHApkB,KAAKykB,KAAOA,EACZzkB,KAAKokB,QAAUA,EACfpkB,KAAKqe,WACEre,MAGT8jB,EAAAnkB,UAAAkS,MAAA,SAAM9B,SACAzN,EADNuN,EAAA7P,KAGIsC,EADEyN,IAGM/P,KAAKukB,WAAavkB,KAAK0kB,aAAgB1kB,KAAa+jB,mBAG1D/jB,KAAKukB,YACPjlB,OAAOmO,KAAKzN,KAAK0kB,cAActW,SAAQ,SAAAuW,GACrC,IAAMriB,EAAQuN,EAAK6U,aAAaC,GAChC,GAAIllB,MAAMyE,QAAQ5B,IAAUuN,EAAKuU,QAAS,CACxC,IAAMQ,EAAY/U,EAAK4U,KAAKI,SAASF,GACrC9U,EAAKiV,WAAWF,GAChBtiB,EAAM8L,SAAQ,SAACrI,EAAGxF,GAChBsP,EAAK4U,KAAKjF,IAAImF,GAAUI,OAAOxkB,EAAIsP,EAAKmN,OAAOmH,kBAA+Bpe,WAKtF/F,KAAKykB,KAAKO,WAAW1iB,EAAO,CAAE4hB,UAAWlkB,KAAKgd,OAAOkH,YAErD,IAAMpT,EAAa9Q,KAAKukB,WAAa9I,GAASzb,KAAKuc,WAAW1L,WAAe7Q,KAAKwc,WAAW9S,UAAS,IAAI1J,KAAK+jB,gBAAmBzhB,KAAMkC,EAAA,IAAMxE,KAAKgd,OAAOiH,SAAU3hB,EAAKkC,GACzKxE,KAAK8c,YAAYhM,IAGXgT,EAAAnkB,UAAAmlB,WAAR,SAAmBT,GACjB,KAA0B,IAAnBA,EAAQ3jB,QACb2jB,EAAQY,SAAS,IAIbnB,EAAAnkB,UAAAulB,oBAAR,SAA4BC,EAAWC,GAAvC,IAAAvV,EAAA7P,KACE,GAAKmlB,EACL,OAAO7lB,OAAOmO,KAAK0X,GAAWre,QAAO,SAACC,EAAK4d,GACzC,IAAMriB,EAAQ8iB,EAAKT,GACnB,GAAIllB,MAAMyE,QAAQ5B,IAAUuN,EAAKuU,QAAS,CACxC,IAAMiB,EAAUxV,EAAKmN,OAAOmH,kBAC5BtU,EAAKiV,WAAWjV,EAAK4U,KAAKjF,IAAImF,IAC9BriB,EAAM8L,SAAQ,SAACrI,EAAGxF,GAChBsP,EAAK4U,KAAKjF,IAAImF,GAAUI,OAAOxkB,EAAI8kB,EAAqBtf,OAI5D,OADAgB,EAAI4d,GAAYS,EAAKT,GACd5d,IACN,KAGG+c,EAAAnkB,UAAA0e,SAAR,iBACMb,EADN3N,EAAA7P,KAGE,GAAIA,KAAKukB,WACP,GAAIvkB,KAAKskB,WACPtkB,KAAK0kB,aAAe1kB,KAAKklB,oBAAoBllB,KAAKykB,KAAKniB,MAAOtC,KAAKuc,WAAW1L,YAC9E7Q,KAAKykB,KAAKO,WAAWhlB,KAAK0kB,aAAc,CAAER,UAAWlkB,KAAKgd,OAAOkH,gBAC5D,CACL1G,EAAUxd,KAAKwc,WAAW9S,UAAS,IAAI1J,KAAK+jB,gBAC5C,IAAMqB,EAAOvU,GAAS7Q,KAAKuc,WAAW1L,WAAY2M,GAClDxd,KAAK0kB,aAAe1kB,KAAKklB,oBAAoBE,EAAMA,GACnDplB,KAAKykB,KAAKO,WAAWhlB,KAAK0kB,aAAc,CAAER,UAAWlkB,KAAKgd,OAAOkH,gBAE9D,CACClkB,KAAKuc,WAAW1L,WAAgC7Q,KAAKgd,OAAOiH,WAChE3gB,EAAU,iCACVtD,KAAK8c,cAAWtY,EAAA,IAAIxE,KAAKgd,OAAOiH,SAAWjkB,KAAa+jB,kBAAiBvf,KAG3E,IAAMlC,EAAQtC,KAAKuc,WAAW1L,WAAW7Q,KAAKgd,OAAOiH,SACrDjkB,KAAKykB,KAAKO,WAAW1iB,GAGvBtC,KAAKslB,YAActlB,KAAKykB,KAAKc,aAAapU,KAAK6S,EAAAA,aAAahkB,KAAKgd,OAAOgH,eAAetS,WAAU,SAAApP,GAE/F,IAAIuD,EADJvC,EAAU,yBAINuC,EAFAgK,EAAK0U,WACH1U,EAAKyU,WACI,SAAAlgB,GAAS,OAAAjE,EAAAA,EAAA,GAAMiE,GAAU9B,IAEzB,SAAA8B,GAAS,OAAAqX,GAASrX,EAAOoZ,EAAMlb,IAGjC,iBAAM,OAAAkC,EAAA,IAAIqL,EAAKmN,OAAOiH,SAAU3hB,EAAKkC,GAElDqL,EAAKiN,YAAYjX,EAASgK,EAAK0M,WAAW1L,iBAI9CiT,EAAAnkB,UAAAmT,QAAA,WACE9S,KAAKslB,aAAetlB,KAAKslB,YAAY3G,cACrC3e,KAAKykB,KAAO,KACZzkB,KAAKokB,QAAU,MAEnBN,GAlHkD3H,mBCMhD,SAAAqJ,EAAsBpJ,EAA+BY,EAAyCU,QAAzC,IAAAV,IAAAA,EAAA,IAArD,IAAAnN,EACEtB,EAAA1O,KAAAG,KAAMoc,EAAO,CACXC,QAAS,WAAM,OAAAxM,EAAK4V,YACpBzlB,YAHkB6P,EAAAuM,MAAAA,EAA+BvM,EAAAmN,OAAAA,EAAyCnN,EAAA6N,UAAAA,EAlBtF7N,EAAA3M,MAAO,EAEP2M,EAAA6V,QAAU,CAChBC,KAAM,GACNC,QAAS,KACTC,OAAQ,IAIFhW,EAAAiW,YAAa,EAanB9I,EAAO+I,OAAW/I,EAAO+I,OAAS/I,EAAO+I,OAAS,GAClD/I,EAAOE,WAAaF,EAAOE,YAAU,WAAW,OAAA,GAEhDrN,EAAKwO,aAoMT,OA/NqDve,EAAA0lB,EAAAjX,GAkCnDjP,OAAAqC,eAAI6jB,EAAA7lB,UAAA,WAAQ,KAAZ,WACE,OAAOK,KAAKgmB,2CAOd1mB,OAAAqC,eAAI6jB,EAAA7lB,UAAA,aAAU,KAAd,WACE,OAAOK,KAAKimB,6CAGd3mB,OAAAqC,eAAI6jB,EAAA7lB,UAAA,UAAO,KAAX,WACE,OAAOK,KAAK0lB,QAAQC,KAAKjlB,OAAS,mCAGpCpB,OAAAqC,eAAI6jB,EAAA7lB,UAAA,YAAS,KAAb,WACE,OAAOK,KAAK0lB,QAAQG,OAAOnlB,OAAS,mCAGtCpB,OAAAqC,eAAY6jB,EAAA7lB,UAAA,WAAQ,KAApB,WACE,OAAOK,KAAKgd,OAAOe,+CAIbyH,EAAA7lB,UAAAumB,iBAAR,WACElmB,KAAKmmB,iBAAiB9jB,KAAKrC,KAAKomB,WAChCpmB,KAAKqmB,eAAehkB,KAAKrC,KAAKsmB,UAGhCd,EAAA7lB,UAAA0e,SAAA,WAAA,IAAAxO,EAAA7P,KACEA,KAAKqmB,eAAiB,IAAItX,EAAAA,iBAAgB,GAC1C/O,KAAKgmB,UAAYhmB,KAAKqmB,eAAe7W,eAAe2B,KAAK7J,EAAAA,wBACzDtH,KAAKmmB,iBAAmB,IAAIpX,EAAAA,iBAAgB,GAC5C/O,KAAKimB,YAAcjmB,KAAKmmB,iBAAiB3W,eAAe2B,KAAK7J,EAAAA,wBAE7DtH,KAAK0lB,QAAQE,QAAU5lB,KAAK6c,UAAU7c,KAAK0d,UAAW1d,KAAK2c,UAC3D3c,KAAK0e,aAAgB1e,KAClB0c,aAAa1c,KAAK0d,UAAW1d,KAAK2c,UAClCxL,KAAKoV,EAAAA,YACL7U,WAAU,SAAClN,OAAAgJ,EAAA/K,EAAA+B,EAAA,GAACmhB,EAAInY,EAAA,GAAEoY,EAAOpY,EAAA,GACxB,GAAIqC,EAAK3M,KACP2M,EAAK3M,MAAO,MADd,CAOA,IAAMsjB,EAAe3W,EAAKmN,OAAOE,WAAWyI,EAAMC,IAE7C/V,EAAKiW,YAAcU,IAClB3W,EAAK6V,QAAQC,KAAKjlB,SAAWmP,EAAKmN,OAAO+I,SAC3ClW,EAAK6V,QAAQC,KAAO9V,EAAK6V,QAAQC,KAAKpb,MAAM,IAE9CsF,EAAK6V,QAAQC,KAAI9iB,EAAOgN,EAAK6V,QAAQC,KAAI,CAAEA,IAC3C9V,EAAK6V,QAAQE,QAAUA,EACvB/V,EAAKqW,yBAKbV,EAAA7lB,UAAA8mB,KAAA,WACE,GAAIzmB,KAAK0lB,QAAQC,KAAKjlB,OAAS,EAAG,CAC1B,IAAA8D,EAAoBxE,KAAK0lB,QAAvBC,EAAInhB,EAAAmhB,KAAEC,EAAOphB,EAAAohB,QACfc,EAAWf,EAAKA,EAAKjlB,OAAS,GACpCV,KAAK0lB,QAAQC,KAAOA,EAAKpb,MAAM,EAAGob,EAAKjlB,OAAS,GAChDV,KAAK0lB,QAAQE,QAAUc,EACvB1mB,KAAK0lB,QAAQG,OAAMhjB,EAAA,CAAI+iB,GAAY5lB,KAAK0lB,QAAQG,QAChD7lB,KAAKkS,WAITsT,EAAA7lB,UAAAgnB,KAAA,WACE,GAAI3mB,KAAK0lB,QAAQG,OAAOnlB,OAAS,EAAG,CAC5B,IAAA8D,EAAoBxE,KAAK0lB,QAAvBC,EAAInhB,EAAAmhB,KAAEC,EAAOphB,EAAAohB,QACfvjB,EAAOrC,KAAK0lB,QAAQG,OAAO,GAC3Be,EAAY5mB,KAAK0lB,QAAQG,OAAOtb,MAAM,GAC5CvK,KAAK0lB,QAAQC,KAAI9iB,EAAO8iB,EAAI,CAAEC,IAC9B5lB,KAAK0lB,QAAQE,QAAUvjB,EACvBrC,KAAK0lB,QAAQG,OAASe,EACtB5mB,KAAKkS,OAAO,UAIhBsT,EAAA7lB,UAAAknB,WAAA,SAAWje,GACT,KAAIA,EAAQ,GAAKA,GAAS5I,KAAK0lB,QAAQC,KAAKjlB,QAA5C,CAEM,IAAA8D,EAA4BxE,KAAK0lB,QAA/BC,EAAInhB,EAAAmhB,KAAEE,EAAMrhB,EAAAqhB,OAAED,EAAOphB,EAAAohB,QAavBkB,EAAUnB,EAAKpb,MAAM,EAAG3B,GACxBge,EAAS/jB,EAAO8iB,EAAKpb,MAAM3B,EAAQ,GAAE,CAAEgd,GAAYC,GACnDkB,EAAapB,EAAK/c,GACxB5I,KAAK0lB,QAAQC,KAAOmB,EACpB9mB,KAAK0lB,QAAQE,QAAUmB,EACvB/mB,KAAK0lB,QAAQG,OAASe,EACtB5mB,KAAKkS,WAGPsT,EAAA7lB,UAAAqnB,aAAA,SAAape,GACX,KAAIA,EAAQ,GAAKA,GAAS5I,KAAK0lB,QAAQG,OAAOnlB,QAA9C,CAEM,IAAA8D,EAA4BxE,KAAK0lB,QAA/BC,EAAInhB,EAAAmhB,KAAEE,EAAMrhB,EAAAqhB,OAcdiB,EAAOjkB,EAAO8iB,EAAI,CAdKnhB,EAAAohB,SAcSC,EAAOtb,MAAM,EAAG3B,IAChDme,EAAalB,EAAOjd,GACpBge,EAAYf,EAAOtb,MAAM3B,EAAQ,GACvC5I,KAAK0lB,QAAQC,KAAOmB,EACpB9mB,KAAK0lB,QAAQE,QAAUmB,EACvB/mB,KAAK0lB,QAAQG,OAASe,EACtB5mB,KAAKkS,OAAO,UAQdsT,EAAA7lB,UAAAsnB,KAAA,SAAKzmB,GACH,OAAIA,EAAI,EAAUR,KAAKgnB,aAAaxmB,EAAI,GACpCA,EAAI,EAAUR,KAAK6mB,WAAW7mB,KAAK0lB,QAAQC,KAAKjlB,OAASF,QAA7D,GAkBFglB,EAAA7lB,UAAA8lB,MAAA,SAAMyB,GACJlnB,KAAK0lB,QAAUrf,EAAW6gB,GACtBA,EAAelnB,KAAK0lB,SACpB,CACEC,KAAM,GACNC,QAAS,KACTC,OAAQ,IAEd7lB,KAAKkmB,oBAGPV,EAAA7lB,UAAAmT,QAAA,SAAQqU,QAAA,IAAAA,IAAAA,GAAA,GACFA,GACFnnB,KAAKylB,QAEPzlB,KAAK0e,aAAaC,eAGpB6G,EAAA7lB,UAAAynB,WAAA,WACEpnB,KAAKkD,MAAO,GAGNsiB,EAAA7lB,UAAAuS,OAAR,SAAezO,QAAA,IAAAA,IAAAA,EAAA,QACbzD,KAAK8lB,YAAa,EAClBxiB,EAAU,mBAAmBG,GAC7BzD,KAAK8c,YAAY9c,KAAK0lB,QAAQE,QAAS5lB,KAAK0d,UAAW1d,KAAK2c,UAAU,GACtE3c,KAAKkmB,mBACLlmB,KAAK8lB,YAAa,GAEtBN,GA/NqDrJ,mBCNnD,SAAAkL,EAAsBjL,EAA8CY,QAAA,IAAAA,IAAAA,EAAA,IAApE,IAAAnN,EACEtB,EAAA1O,KAAAG,KAAMoc,EAAOY,EAAO/Z,YAAUjD,YADV6P,EAAAuM,MAAAA,EAA8CvM,EAAAmN,OAAAA,EAElEA,EAAO+I,OAASrX,GAAUsO,EAAO+I,QAAU/I,EAAO+I,OAAS,GAC3DlW,EAAKwO,WACLxO,EAAKyQ,YACFnP,KAAKjO,EAAAA,KAAK,IACVwO,WAAU,SAAAjN,GAAO,OAAAoL,EAAKwO,SAAS5Z,QA8CtC,OArDgJ3E,EAAAunB,EAAA9Y,GAU9I8Y,EAAA1nB,UAAAgnB,KAAA,SAAKliB,GACHzE,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAE8lB,WAG7BU,EAAA1nB,UAAA8mB,KAAA,SAAKhiB,GACHzE,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAE4lB,WAG7BY,EAAA1nB,UAAA2mB,QAAA,SAAQriB,GACN,GAAIjE,KAAK+D,UAAUE,GACjB,OAAOjE,KAAKuZ,UAAUtV,GAAIqiB,SAI9Be,EAAA1nB,UAAAymB,UAAA,SAAUniB,GACR,GAAIjE,KAAK+D,UAAUE,GACjB,OAAOjE,KAAKuZ,UAAUtV,GAAImiB,WAI9BiB,EAAA1nB,UAAAqnB,aAAA,SAAaviB,EAAgCmE,GAC3C5I,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEmmB,aAAape,OAG1Cye,EAAA1nB,UAAAknB,WAAA,SAAWpiB,EAAgCmE,GACzC5I,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEgmB,WAAWje,OAGxCye,EAAA1nB,UAAA8lB,MAAA,SAAMhhB,GACJzE,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAE4kB,YAG7B4B,EAAA1nB,UAAAmT,QAAA,SAAQrO,EAAiC0iB,QAAA,IAAAA,IAAAA,GAAA,GACvCnnB,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEiS,QAAQqU,OAGrCE,EAAA1nB,UAAAynB,WAAA,SAAW3iB,GACTzE,KAAKugB,UAAU9b,GAAK,SAAA5D,GAAK,OAAAA,EAAEumB,iBAGnBC,EAAA1nB,UAAAugB,kBAAV,SAA4Bjc,GAC1B,OAAO,IAAIuhB,GAA0BxlB,KAAKoc,MAAOpc,KAAKgd,OAAQ/Y,IAElEojB,GArDgJ/H,KCHpIgI,EAAAA,cAAAA,EAAAA,YAAW,KACrB,OAAA,SAGF,IAIYC,GAJNC,KAAkBhjB,GAAA,IACrB8iB,EAAAA,YAAYpS,QAAS,cAGZqS,GAAAA,EAAAA,oBAAAA,EAAAA,kBAAiB,KAC3B,OAAA,SACAA,GAAA,YAAA,eACAA,GAAA,YAAA,eACAA,GAAA,eAAA,kBACAA,GAAA,eAAA,kBACAA,GAAA,eAAA,kBACAA,GAAA,mBAAA,uBAGF,IAAME,KAAwBja,GAAA,IAC3B+Z,EAAAA,kBAAkBrS,QAAS,SAC5B1H,GAAC+Z,EAAAA,kBAAkBG,aAAc,MACjCla,GAAC+Z,EAAAA,kBAAkBI,aAAc,MACjCna,GAAC+Z,EAAAA,kBAAkBK,gBAAiB,SACpCpa,GAAC+Z,EAAAA,kBAAkBM,gBAAiB,SACpCra,GAAC+Z,EAAAA,kBAAkBO,gBAAiB,SACpCta,GAAC+Z,EAAAA,kBAAkBQ,oBAAqB,0BAO1BvL,GAAiFwL,GAC/F,OAAOC,GAA0BD,EAAoB,YAAa,oBAOpDC,GAAuFve,GACrG,IAAMwH,EAAQhH,EAAWR,GAEzB,GAAI5D,EAAMoL,GACR,MAAM,IAAI5C,GAAc4C,EAAMxH,UAAS,kBAGzC,OAAOwH,WAOOgX,GAA+GF,GAC7H,OAAOxL,GAASwL,YAOFG,GAAqHze,GACnI,OAAOue,GAAgCve,qBCjEzC,SAAA0e,KAiDA,OA5CEA,EAAAzoB,UAAA0oB,kBAAA,SAAkBC,QAAA,IAAAA,IAAAA,EAAA,IAIhB,IAHA,IAAIvhB,EAAM,GAEJ0G,EADa6a,EAAO5nB,OAAS,EACT4nB,EAAShpB,OAAOmO,KAAKvD,GACtC3J,EAAI,EAAGA,EAAIkN,EAAK/M,OAAQH,IAAK,CACpC,IAAImJ,EAAY+D,EAAKlN,GACH,WAAdmJ,IACF3C,EAAI2C,GAAaQ,EAAWR,GAAW0G,UAI3C,OAAOrJ,GAGTqhB,EAAAzoB,UAAA4oB,kBAAA,SAAkBD,EAA+CpjB,GAC/D,IAAMsjB,EAAaroB,EAAQ,CAAEwb,mBAAmB,EAAO8M,MAAM,GAAYvjB,GACzEsjB,EAAc7M,mBAAqBE,IAAqB,GAExD,IAAI6M,EAAmBJ,EAEnB/P,GAAS+P,KACXI,EAAmBtL,KAAKuL,MAAMD,IAGhC,IAAME,EAAOtpB,OAAOmO,KAAKib,GAAkBhoB,OAE3C,GAAI8nB,EAAcC,KAChBnf,EACG6H,KACCrM,EAAAA,QAAO,SAAA8J,GAAQ,OAAA8Z,EAAiB9oB,eAAegP,MAC/C6U,EAAAA,KAAKmF,IAENlX,WAAU,SAAA9C,GAAQ,OAAA1E,EAAW0E,GAAMyB,WAAU,WAAM,OAAAqY,EAAiB9Z,cAEvE,mBAASrO,EAAOkN,GACd,IAAM/D,EAAY+D,EAAKlN,GACnB2J,EAAWR,IACbQ,EAAWR,GAAW2G,WAAU,WAAM,OAAAqY,EAAiBhf,OAHlDnJ,EAAI,EAAGkN,EAAOnO,OAAOmO,KAAKib,GAAmBnoB,EAAIkN,EAAK/M,OAAQH,MAA9DA,EAAOkN,GAQlB+a,EAAc7M,mBAAqBE,IAAqB,IAE5DuM,KAEaS,GAAkB,IAAIT,GCtCnC,IAAAU,GAAA,WACE,SAAAA,EAAqB1M,GAAApc,KAAAoc,MAAAA,EA6BvB,OA3BE0M,EAAAnpB,UAAAE,KAAA,SAAKkpB,EAA2BhK,GAAhC,IAAAlP,EAAA7P,KACE,OAAO+e,EACJ5N,KACCzJ,EAAAA,QACA6S,EAAAA,WAAU,SAAC/U,GACT,IAAIwjB,EAASxjB,EAAOqK,EAAKuM,MAAM3D,UAAUnH,OAAOtM,OAC5CiQ,GAAU,EAEd,OAAO2L,EAAAA,MAAMnR,EAAAA,GAAG,CAAEuF,WAAOlN,EAAWiN,MAAOiU,EAAQ/T,SAAS,IAAUpF,EAAKuM,MAAM3D,UAAUwQ,wBAAwB9X,KAEjHrM,EAAAA,QAAO,SAACokB,GAAW,OAAAA,EAAOnU,QAAUiU,KAEpCG,EAAAA,KAAI,SAACD,GAAW,OAACjU,EAAUiU,EAAOjU,WAElCnQ,EAAAA,QAAO,SAACokB,GAAW,OAAAA,EAAOlU,QAAUgU,IAAW/T,KAE/CsF,EAAAA,WAAU,SAAC2O,GACT,OAAArZ,EAAKuM,MACFpC,aAAcgP,EAASE,EAAOlU,OAASgU,GAEvC7X,KAAKrM,EAAAA,QAAO,WAAM,OAACmQ,cAK7BvD,UAAUqX,IAEjBD,EA9BA,wFjDnB8B,0RkDaC/mB,GAC7B,OAAO,SAAS9B,GACdA,EAA0B,iBAAI,GAC9B,IAAK,IAAIM,EAAI,EAAGkN,EAAOnO,OAAOmO,KAAK1L,GAAWxB,EAAIkN,EAAK/M,OAAQH,IAAK,CAClE,IAAMa,EAAMqM,EAAKlN,GACjBN,EAA0B,iBAAEmB,GAAOW,EAASX,sGCDtBW,GAC1B,OAAO,SAAS9B,GACdA,EAAqB,YAAI,CAAE+E,MAAO,MAElC,IAAK,IAAIzE,EAAI,EAAGkN,EAAOnO,OAAOmO,KAAK1L,GAAWxB,EAAIkN,EAAK/M,OAAQH,IAAK,CAClE,IAAMa,EAAMqM,EAAKlN,GAEL,SAARa,EACFnB,EAAqB,YAAa,UAAI8B,EAASX,GAE/CnB,EAAqB,YAAEmB,GAAOW,EAASX,uElDZnBkQ,GAC1BzI,EAAM1I,EAAAA,EAAA,GAAQ0I,GAAWyI,6BMYG8X,EAAyDlkB,GACrF,QADqF,IAAAA,IAAAA,EAAA,KACjF6E,GAEED,OAAeuf,6BAArB,CAIAze,GAAKlK,QACHkK,GAAKwD,SAAQ,SAAC9N,GACRA,EAAEqe,YACJre,EAAEqe,cAEFre,GAAKA,OAIO8oB,GAAmBA,EAAqB,OAGxDA,EAAkBA,GAAmB,IACZE,IAAM,SAAC9I,GAAO,OAAAA,KACvCtb,EAAUkkB,GAGZ,IACMvV,EAASvU,OAAOc,OAAO,GADuC,CAAEwO,KAAM,QAAS2a,SAAS,EAAMC,gBAAiB,IACpEtkB,GAC3CskB,EAAkB3V,EAAO2V,gBACzBC,EAAY3f,OAAeuf,6BAA6BK,QAAQ7V,GAClE8V,EAAW,GAETC,EAAY,SAAClgB,GACjB,OAAK8f,EAAgB9oB,QAId8oB,EAAgB1oB,QAAQ4I,IAAc,GAG/CkB,GAAKjI,KACH2G,EAAWoI,WAAU,SAAChI,UACS,IAAzBkgB,EAAUlgB,KACdigB,EAAQxpB,EAAAA,EAAA,GACHwpB,KAAQnlB,EAAA,IACVkF,GAAYQ,EAAWR,GAAW0G,SAAQ5L,IAE7CilB,EAASI,KAAK,CAAE7mB,KAAM,IAAIoH,EAAWV,GAAU,cAAgBigB,QAInE/e,GAAKjI,KACHyG,EAAcsI,WAAU,SAAChI,IACM,IAAzBkgB,EAAUlgB,YACPigB,EAASjgB,GAChB+f,EAASI,KAAK,CAAE7mB,KAAM,IAAI0G,EAAS,oBAAsBigB,QAI7D/e,GAAKjI,KACH6G,EAAckI,WAAU,SAAClN,SAAEkF,EAASlF,EAAAkF,UAAEjG,EAAMe,EAAAf,OAC1C,IAA6B,IAAzBmmB,EAAUlgB,GAAd,CACQ,IAAA1G,EAAmCS,EAAMT,KAAnCC,EAA6BQ,EAAMR,UAAxBC,EAAkBO,EAAMP,KAE3CC,EAFgCvC,EAAK6C,EAArC,CAAA,OAAA,YAAA,SAEeN,QACrB,GAAID,EACFM,GAAc,OADhB,CAKA,IAAM0N,EAAQhH,EAAWR,GACzB,GAAKwH,EAAL,CAIA,IAAwB,IAApBhM,EAAQqkB,SAAqBI,EAASjgB,GAExC,GADgB0T,KAAKC,UAAUnM,EAAMd,YAAcgN,KAAKC,UAAUsM,EAASjgB,IAC9D,OAGfigB,EAAQxpB,EAAAA,EAAA,GACHwpB,KAAQnc,EAAA,IACV9D,GAAYwH,EAAMd,SAAQ5C,IAG7B,IAAMsc,EAAY1f,EAAWV,GACzBqgB,EAAM7gB,EAAUjG,GAAa,IAAI6mB,EAAS,OAAO9mB,EAAI,UAAUC,EAAS,IAAM,IAAI6mB,EAAS,OAAO9mB,EAQtG,GANIkC,EAAQ8kB,WACVhY,QAAQiY,MAAMF,GACd/X,QAAQkY,QACRlY,QAAQmY,YAGNjlB,EAAQklB,mBAAZ,CACE,IAAMC,EAAiB/qB,OAAOmO,KAAKkc,GAChC/d,OACA9E,QAAO,SAACC,EAAK2C,GAEZ,OADA3C,EAAI2C,GAAaigB,EAASjgB,GACnB3C,IACN,IAEL0iB,EAASI,KAAI1pB,EAAA,CAAG6C,KAAM+mB,GAAQ5mB,GAAWknB,QAI3CZ,EAASI,KAAI1pB,EAAA,CAAG6C,KAAM+mB,GAAQ5mB,GAAWwmB,UAI7C/e,GAAKjI,KACH8mB,EAAS/X,WAAU,SAAClD,GAClB,GAAqB,aAAjBA,EAAQxL,KAAqB,CAG/B,GAAoB,WAFAwL,EAAQrL,QAAQH,KAIlC,YADAymB,EAASa,KAAKX,GAIhB,GAAInb,EAAQpK,MAEV,IADA,IAAMmmB,EAAYnN,KAAKuL,MAAMna,EAAQpK,kBAC5B7D,EAAOkN,GACd,IAAM/D,EAAY+D,EAAKlN,GACnB2J,EAAWR,IACZ0f,EAA+BE,KAAI,WAClCpf,EAAWR,GAAW2G,WAAU,WAAM,OAAAka,EAAU7gB,MAAY,OAJzDnJ,EAAI,EAAGkN,EAAOnO,OAAOmO,KAAK8c,GAAYhqB,EAAIkN,EAAK/M,OAAQH,MAAvDA,EAAOkN,kEXpDGhH,EAA8CzB,GACzE,OAAO,SAAS+Z,GACd,OAAOA,EAAO5N,KACZxI,EAAAA,KAAI,SAACnC,GAEH,OAA4B,IAAxBtC,EAAQsC,GACHA,EAEFD,EAAKC,EAAYC,EAAgBzB,GIxGlB,SJ0GxBqC,IACAsB,EAAAA,KAAI,SAAArG,GACF,OAAuB,IAAnB4B,EAAQ5B,IAIR4B,EAAQuC,IAAmBJ,EAAWI,GAHjCnE,EAOFA,EAAM,gCwDnGsC4D,EAAQskB,EAAyCxlB,GAC1G,IAAIylB,EACAC,EClBcC,ED6BlB,QAb0G,IAAA3lB,IAAAA,EpDjB9E,MoDqBxBqB,EAAWmkB,ICpBGG,EDqBDH,EAAfE,ECpBK,eAAS,IAAA7mB,EAAA,GAAAC,EAAA,EAAAA,EAAArD,UAAAC,OAAAoD,IAAAD,EAAAC,GAAArD,UAAAqD,GACd,OAAQ6mB,EAAIhqB,WAAA,EAAAkC,EAAIgB,ODqBhB4mB,EAAczkB,EAAYwkB,GAC1BE,EAAW,SAACjlB,GACV,OAA8E,IAAvEglB,EAAY/hB,SAASV,EAASvC,GAAWA,EAAQT,GAASS,KAIjEhG,MAAMyE,QAAQgC,GAChB,OAAOA,EAAIpB,OAAO4lB,2BtDRS3Q,EAAY6Q,EAAaC,QAAA,IAAAA,IAAAA,EAAA,SAAoC1iB,EAAG9I,GAAM,OAAA8I,IAAM9I,IACzG,IAAMuJ,EAAQmR,EAAM+Q,WAAU,SAACC,GAAa,OAAAF,EAAQD,EAAUG,MAC9D,OAAUniB,EAAK/F,EAAOkX,EAAMxP,MAAM,EAAG3B,GAAWmR,EAAMxP,MAAM3B,EAAQ,IAAE/F,EAAQkX,EAAK,CAAE6Q,4CwDTvC1kB,EAAWjC,EAAQqE,EAAuBtD,cAAA,IAAAA,IAAAA,EtDhB5D,MsDiB5B,IAAMgmB,EAAiBhjB,EAASM,GAEhC,OADqBpC,EAAI0B,MAAK,SAAApC,GAAU,OAACwlB,EAAiBxlB,EAAOR,KAAWf,EAAKuB,IAAWvB,KAEnFmE,EAAYlC,EAAKjC,EAAIqE,EAAKtD,GAE1BiB,EAASC,EAAK8kB,EAAc7qB,EAAAA,EAAA,GAAQmI,KAAG9D,EAAA,IAAGQ,GAAQf,EAAEO,IAAK8D,sBxDVlE,OAAOL,EAAS,sCyDOWiJ,EAAc+Z,EAAyB/lB,GAClE,YADkE,IAAAA,IAAAA,EAAA,CAAmCgmB,UAAU,IAC3Gha,EAAMG,SAAS/O,MACV4C,EAAQgmB,SAAWzb,EAAAA,QAAG3H,GAAaqjB,EAAAA,MAErCF,6CCjB6CG,GACpD,OAAOnM,EAAAA,cAAcmM,GAAaja,KAAK0P,EAAAA,UAAU,gDLQ1B,2CMKoC3P,EAA2BhM,GACtF,YADsF,IAAAA,IAAAA,EAAA,IAC/E,IAAIuU,GAAmBvI,EAAOhM,iCALsB6K,EAA8B7K,GACzF,OAAO,IAAIgP,GAAmBnE,EAAc7K,2BALXgM,GACjC,OAAO,IAAIsH,GAAatH,2BALSnB,EAA8B7K,GAC/D,OAAO,IAAI4K,GAAaC,EAAc7K,+K5CJtCmH,EAAAA,SAAU,EACNxC,WACMC,OAAeU,gBACfV,OAAeW,8EeCF,SAAIsU,GAC3B,OAAAA,EAAO5N,KAAKrM,EAAAA,QAAO,SAACxC,GAAmC,OAAAA,MAAAA,oQ8BEvD,OAAOuJ,KAAKwf,SACTC,SAAS,IACT/gB,MAAM,8LCXcjI,GACvB,OAAQ4B,EAAQ5B,IAAUA,EAAQipB,WAAWjpB,GAAS,GAAK,oIrBkFhC0a,GAC3B,IAAMpF,EAA+B,CACnCxW,IAAK,cACLoqB,oBAAoB,EACpBC,QAAUzhB,IAAqCC,aAAjB+S,EAAOyO,QACrCC,YAAatO,KAAKuL,MAClBgD,UAAWvO,KAAKC,UAChBuO,QAAS,GACTlT,OAAQ,GACRmT,kBAAkB,EAClBC,iBAAkB,SAAUpiB,EAAWtF,GACrC,OAAOA,GAET2nB,eAAgB,SAAUriB,EAAWtF,GACnC,OAAOA,GAETuX,kBAAmBG,GACnBkQ,yBAA0B,WAAM,OAAA,SAACjN,GAAW,OAAAA,KAGxCva,EAAiLlF,OAAOc,OAC5L,GACAwX,EACAoF,GAHMyO,EAAOjnB,EAAAinB,QAAED,EAAkBhnB,EAAAgnB,mBAAEE,EAAWlnB,EAAAknB,YAAEC,EAASnnB,EAAAmnB,UAAEC,EAAOpnB,EAAAonB,QAAElT,EAAMlU,EAAAkU,OAAEtX,EAAGoD,EAAApD,IAAE0qB,EAAgBtnB,EAAAsnB,iBAAED,EAAgBrnB,EAAAqnB,iBAAEG,EAAwBxnB,EAAAwnB,yBAAED,EAAcvnB,EAAAunB,eAAEpQ,EAAiBnX,EAAAmX,kBAMlL,KAAK5R,GAAiByhB,IAAwBC,EAA9C,CAEA,IAEIQ,EACAC,EAHEC,EAAaP,EAAQlrB,OAAS,EAC9B0rB,EAAY1T,EAAOhY,OAAS,EAI9ByrB,IACFF,EAAgBL,EAAQ9kB,QACtB,SAACC,EAAKyW,GACAnX,EAAWmX,GACbzW,EAAIslB,IAAI1pB,KAAK6a,GAGbzW,EADkByW,EAAKlC,MAAM,KAAK,IACjBkC,EAEnB,OAAOzW,IAET,CAAEslB,IAAK,MAIPD,IACFF,EAAexT,EAAO5R,QAAO,SAACC,EAAKulB,GAGjC,OAFAvlB,EAAIulB,EAAS5iB,WAAa4iB,EAEnBvlB,IACN,KAGL,IAAIuhB,EAAgC,GAChCvhB,EAAM,GACNwlB,EAAgC,GAE9BC,EAAS,GAUTC,EAAkBziB,KAAqByhB,IAAYxhB,clClJ1B,WAC/B,IACE,MAAiC,oBAAnByiB,eACd,MAAAloB,GACA,OAAO,GkC8IkEmoB,IAAuBlB,IAAYiB,eAuF9G,OArFA3Q,GAAU0P,EAAQmB,QAAQxrB,IAAMsQ,WAAU,SAACpP,GACzC,IAAIuqB,EAAe7kB,EAAS1F,GAASA,EAAQopB,EAAYppB,GAAS,MAElE,SAASwqB,EAAKC,GACZF,EAAqB,OAAC1sB,EAAAA,EAAA,GAAS0sB,EAAqB,QAAK,IAAQE,GACjEF,EAAevtB,OAAOc,OAAO,GAAIysB,EAAc9lB,GAE/CylB,EAAO7pB,KAAK8oB,EAAQuB,QAAQ5rB,EAAKqrB,EAAiBd,EAAUkB,GAAgBA,IAjBhF,SAASI,EAAMlnB,GACbgW,GAAUhW,GAAG2L,WAAU,WACrB,IAAMrP,EAAOmqB,EAAOU,QACpB7qB,GAAQ4qB,EAAM5qB,MAed4qB,CAAMT,EAAOU,SAGf,SAASxb,EAAUhI,EAAW8T,GAC5B8K,EAAO5e,GAAaQ,EAAWR,GAC5BsH,SAAQ,SAAC5M,GAAU,OAAAyM,GAASzM,EAAOoZ,MACnCrM,KACCjO,EAAAA,KAAK,GACLyF,EAAAA,KAAI,SAACuI,GACH,OAAIkb,GAAaF,EAAaxiB,GACrBwiB,EAAaxiB,GAAWwH,GAG1BA,KAETpM,EAAAA,QAAO,WAAM,OAAwB,IAAxB6W,OACbqQ,KAEDta,WAAU,SAACgD,GACV3N,EAAI2C,GAAaoiB,EAAiBpiB,EAAWgL,GAC7CyY,QAAQvf,UAAUqO,MAAK,iBAAM,OAAA6Q,IAAItoB,EAAA,IAAIkF,GAAYQ,EAAWR,GAAW2H,SAASR,WAAUrM,UAIhG,SAAS4oB,EAAW1jB,EAAWwH,EAAOsM,GACpC,GAAI9T,KAAamjB,EAAc,CAC7BtpB,EAAU,iBACV2N,EAAMb,WAAU,SAACjM,GACf,OAAOqX,GAASrX,EAAOoZ,EAAMuO,EAAeriB,EAAWmjB,EAAanjB,GAAYtF,OAElF,IAAMmM,IAAWsc,EAAqB,QAAIA,EAAqB,OAAEnjB,GACjEQ,EAAWR,GAAW4G,YAAYC,EAAU,CAAEC,YAAY,KAI9D+b,EAAc5pB,KACZyG,EAAcsI,WAAU,SAAChI,SACnB4e,EAAO5e,MACgB,IAArBmiB,GACFiB,IAAItoB,EAAA,IAAIkF,IAAY,EAAKlF,IAE3B8jB,EAAO5e,GAAWiV,qBACX2J,EAAO5e,QAKpB6iB,EAAc5pB,KACZ2G,EAAWoI,WAAU,SAAChI,GACpB,GAAkB,WAAdA,EAAJ,CAIA,IAAMwH,EAAQhH,EAAWR,GACzB,GAAIyiB,EAAY,CACd,IAAI3O,EAAOyO,EAAcviB,GAEzB,IAAK8T,EAAM,CAET,IADsByO,EAAcI,IAAIzkB,MAAK,SAAC8D,GAAO,OAAAA,EAAGhC,MAItD,OAFA8T,EAAO9T,EAKX0jB,EAAW1jB,EAAWwH,EAAOsM,GAC7B9L,EAAUhI,EAAW8T,QAErB4P,EAAW1jB,EAAWwH,EAAOxH,GAC7BgI,EAAUhI,EAAWA,QAK3BkS,GAAkBvZ,UAGb,CACLyQ,QAAO,WACLyZ,EAAcne,SAAQ,SAAC9N,GAAM,OAAAA,EAAEqe,iBAC/B,IAAK,IAAIpe,EAAI,EAAGkN,EAAOnO,OAAOmO,KAAK6a,GAAS/nB,EAAIkN,EAAK/M,OAAQH,IAAK,CAChE,IAAMmJ,EAAY+D,EAAKlN,GACvB+nB,EAAO5e,GAAWiV,cAEpB2J,EAAS,IAEX7C,MAAK,WACHgG,EAAQhG,SAEV/C,WAAA,SAAWhZ,GACL5D,EAAM4D,GACMqS,GAAU0P,EAAQuB,QAAQ5rB,EAAK,OACvCsQ,YAIRqK,GADc0P,EAAQmB,QAAQxrB,IACbsQ,WAAU,SAAC3L,GAC1B,IAAM8mB,EAAenB,EAAY3lB,GAAK,MAElC8mB,EAAanjB,YACRmjB,EAAanjB,GACNqS,GAAU0P,EAAQuB,QAAQ5rB,EAAKuqB,EAAUkB,KACjDnb,qCYjQc,2GUMFxM,GAK1BA,EAAU5F,OAAOc,OAAO,GAJY,CAClCitB,QAAS,IAG2BnoB,GACtC,IAAMojB,EAAShpB,OAAOmO,KAAKvD,GAE3BwF,IAAiB,uBACf,IAAoB,IAAA4d,EAAAtrB,EAAAsmB,GAAMiF,EAAAD,EAAAjrB,QAAAkrB,EAAAhrB,KAAAgrB,EAAAD,EAAAjrB,OAAE,CAAvB,IAAM6O,EAAKqc,EAAAjrB,MACRhC,EAAI4J,EAAWgH,GAChBhM,EAAQmoB,SAGmC,IAA1CnoB,EAAQmoB,QAAQvsB,QAAQR,EAAEoJ,YAC5BpJ,EAAEuR,QAHJvR,EAAEuR,uKbkKR2b,EACA/pB,EACAgqB,GAEA,IAAMvc,EAAoC,iBAArBsc,EAAgCrF,GAAsCqF,GAAoBtF,GAAgCsF,GAC/IC,EAAUvc,EAAMuW,GAAyBhkB,IAASiqB,KAAKxc,+BA1GvDsc,EACA/pB,EACAgqB,GAEA,IAAMvc,EAAoC,iBAArBsc,EAAgCvF,GAA0BuF,GAAoBhR,GAAoBgR,GACvHC,EAAUvc,EAAMsW,GAAmB/jB,IAASiqB,KAAKxc,yCT7EjD,OAAO0K,GAAkBpM,qEuBdG0B,GAC5B,OAAO,SAAa6N,GAClB,OAAO4O,EAAAA,OAAM,WAEX,OADAzc,EAAMf,YAAW,GACV4O,EAAO5N,KAAKyc,EAAAA,UAAS,WAAM,OAAA1c,EAAMf,YAAW,0CCJnBe,GACpC,OAAO,SAAa6N,GAClB,OAAO4O,EAAAA,OAAM,WAIX,OAHAzc,EAAMf,YAAW,GACjBe,EAAMH,SAAS,MAERgO,EAAO5N,KACZgY,EAAAA,IAAI,CACFvmB,MAAK,SAACirB,GACJ3c,EAAMf,YAAW,GACjBe,EAAMH,SAAS8c,IAEjBve,SAAQ,WACN4B,EAAMf,YAAW,4ICdInM,EAAegB,gBAAA,IAAAA,IAAAA,E/DHlB,M+DI5B,IAAMP,EAAM,OACZ,IAAqB,IAAAa,EAAAtD,EAAAgC,GAAQuB,EAAAD,EAAAjD,QAAAkD,EAAAhD,KAAAgD,EAAAD,EAAAjD,OAAE,CAA1B,IAAMmD,EAAMD,EAAAjD,MACfmC,EAAI9B,KAAK6C,EAAOR,sGAElB,OAAOP,mDdO4H2X,GACnI,OAAO,SAAC2C,GAAW,OAAAA,EAAO+O,KAAQ,IAAIhF,GAAe1M,8FzBoGpB/Z,GACjC,OAAO,SAAS0c,GACd,OAAOA,EAAO5N,KAAKgY,EAAAA,KAAI,SAAA7mB,GAAS,OAAAoN,IAAiB,WAAM,OAAArN,EAAKC","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { IDS } from './types';\n\nexport interface StoreSnapshotAction {\n  type: string | null;\n  entityIds: IDS[] | null;\n  skip: boolean;\n  payload: any\n}\n\nexport const currentAction: StoreSnapshotAction = {\n  type: null,\n  entityIds: null,\n  skip: false,\n  payload: null\n};\n\nlet customActionActive = false;\n\nexport function resetCustomAction() {\n  customActionActive = false;\n}\n\n// public API for custom actions. Custom action always wins\nexport function logAction(type: string, entityIds?, payload?: any) {\n  setAction(type, entityIds, payload);\n  customActionActive = true;\n}\n\nexport function setAction(type: string, entityIds?, payload?: any) {\n  if (customActionActive === false) {\n    currentAction.type = type;\n    currentAction.entityIds = entityIds;\n    currentAction.payload = payload\n  }\n}\n\nexport function setSkipAction(skip = true) {\n  currentAction.skip = skip;\n}\n\nexport function action(action: string, entityIds?) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n      logAction(action, entityIds);\n      return originalMethod.apply(this, args);\n    };\n\n    return descriptor;\n  };\n}\n","import { EntityState, ID } from './index';\n\n// @internal\nexport function hasEntity<E>(entities: EntityState<E>, id: ID) {\n  return entities.hasOwnProperty(id);\n}\n","// @internal\nexport function isArray<T>(value: any): value is T[] {\n  return Array.isArray(value);\n}\n","import { ActiveState, EntityState, ID, IDS, MultiActiveState } from './types';\nimport { hasEntity } from './hasEntity';\nimport { isArray } from './isArray';\n\n// @internal\nexport function hasActiveState<E>(state: EntityState<E>): state is EntityState<E> & (ActiveState | MultiActiveState) {\n  return state.hasOwnProperty('active');\n}\n\n// @internal\nexport function isMultiActiveState(active: IDS): active is ID[] {\n  return isArray(active);\n}\n\n// @internal\nexport function resolveActiveEntity<E>({ active, ids, entities }: EntityState<E> & (ActiveState | MultiActiveState)) {\n  if (isMultiActiveState(active)) {\n    return getExitingActives(active, ids);\n  }\n\n  if (hasEntity(entities, active) === false) {\n    return null;\n  }\n\n  return active;\n}\n\n// @internal\nexport function getExitingActives(currentActivesIds: ID[], newIds: ID[]) {\n  const filtered = currentActivesIds.filter(id => newIds.indexOf(id) > -1);\n  /** Return the same reference if nothing has changed */\n  if (filtered.length === currentActivesIds.length) {\n    return currentActivesIds;\n  }\n\n  return filtered;\n}\n","import { EntityState, PreAddEntity } from './types';\nimport { hasEntity } from './hasEntity';\n\nexport type AddEntitiesParams<State, Entity> = {\n  state: State;\n  entities: Entity[];\n  idKey: string;\n  options: AddEntitiesOptions;\n  preAddEntity: PreAddEntity<Entity>;\n};\n\nexport type AddEntitiesOptions = { prepend?: boolean; loading?: boolean };\n\n// @internal\nexport function addEntities<S extends EntityState<E>, E>({ state, entities, idKey, options = {}, preAddEntity }: AddEntitiesParams<S, E>) {\n  let newEntities = {};\n  let newIds = [];\n  let hasNewEntities = false;\n\n  for (const entity of entities) {\n    if (hasEntity(state.entities, entity[idKey]) === false) {\n      // evaluate the middleware first to support dynamic ids\n      const current = preAddEntity(entity);\n      const entityId = current[idKey];\n      newEntities[entityId] = current;\n      if (options.prepend) newIds.unshift(entityId);\n      else newIds.push(entityId);\n\n      hasNewEntities = true;\n    }\n  }\n\n  return hasNewEntities\n    ? {\n        newState: {\n          ...state,\n          entities: {\n            ...state.entities,\n            ...newEntities\n          },\n          ids: options.prepend ? [...newIds, ...state.ids] : [...state.ids, ...newIds]\n        },\n        newIds\n      }\n    : null;\n}\n","// @internal\nexport function isNil(v) {\n  return v === null || v === undefined;\n}\n","import { isNil } from './isNil';\n\n// @internal\nexport function coerceArray<T>(value: T | T[]): T[] {\n  if (isNil(value)) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\n","import { OrArray } from './types';\nimport { coerceArray } from './coerceArray';\nimport { AddEntitiesOptions } from './addEntities';\n\n/**\n * Add item to a collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   comments: arrayAdd(state.comments, { id: 2 })\n * }))\n *\n */\n\nexport function arrayAdd<T extends any[], Entity = any>(arr: T, newEntity: OrArray<Entity>, options: AddEntitiesOptions = {}): T {\n  const newEntities = coerceArray(newEntity);\n  const toArr = arr || [];\n\n  return options.prepend ? [...newEntities, ...toArr] : ([...toArr, ...newEntities] as any);\n}\n","// @internal\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function';\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isEmpty<T>(arr: T) {\n  if (isArray(arr)) {\n    return arr.length === 0;\n  }\n  return false;\n}\n","import { ID, IDS, ItemPredicate } from './types';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { isArray } from './isArray';\nimport { isFunction } from './isFunction';\nimport { isEmpty } from './isEmpty';\n\n// @internal\nexport function find<T>(collection: T[], idsOrPredicate: IDS | ItemPredicate, idKey: string) {\n  const result = [];\n  if (isFunction(idsOrPredicate)) {\n    for (const entity of collection) {\n      if (idsOrPredicate(entity) === true) {\n        result.push(entity);\n      }\n    }\n  } else {\n    const toSet = coerceArray(idsOrPredicate).reduce((acc, current) => acc.add(current), new Set());\n\n    for (const entity of collection) {\n      if (toSet.has(entity[idKey])) {\n        result.push(entity);\n      }\n    }\n  }\n\n  return result;\n}\n\n// @internal\nexport function distinctUntilArrayItemChanged<T>(): MonoTypeOperatorFunction<T[]> {\n  return distinctUntilChanged((prevCollection: T[], currentCollection: T[]) => {\n    if (prevCollection === currentCollection) {\n      return true;\n    }\n\n    if (isArray(prevCollection) === false || isArray(currentCollection) === false) {\n      return false;\n    }\n\n    if (isEmpty(prevCollection) && isEmpty(currentCollection)) {\n      return true;\n    }\n\n    // if item is new in the current collection but not exist in the prev collection\n    const hasNewItem = hasChange(currentCollection, prevCollection);\n\n    if (hasNewItem) {\n      return false;\n    }\n\n    const isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);\n\n    // return false means there is a change and we want to call next()\n    return isOneOfItemReferenceChanged === false;\n  });\n}\n\n// @internal\nfunction hasChange<T>(first: T[], second: T[]) {\n  const hasChange = second.some(currentItem => {\n    const oldItem = first.find(prevItem => prevItem === currentItem);\n    return oldItem === undefined;\n  });\n\n  return hasChange;\n}\n\n/**\n * Find items in a collection\n *\n * @example\n *\n *  selectEntity(1, 'comments').pipe(\n *   arrayFind(comment => comment.text = 'text')\n * )\n */\nexport function arrayFind<T>(ids: ItemPredicate<T>, idKey?: never): (source: Observable<T[]>) => Observable<T[]>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind(3)\n * )\n */\nexport function arrayFind<T>(ids: ID, idKey?: string): (source: Observable<T[]>) => Observable<T>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind([1, 2, 3])\n * )\n */\nexport function arrayFind<T>(ids: ID[], idKey?: string): (source: Observable<T[]>) => Observable<T[]>;\nexport function arrayFind<T>(idsOrPredicate: ID[] | ID | ItemPredicate<T>, idKey?: string): (source: Observable<T[]>) => Observable<T[] | T> {\n  return function(source: Observable<T[]>) {\n    return source.pipe(\n      map((collection: T[] | undefined | null) => {\n        // which means the user deleted the root entity or set the collection to nil\n        if (isArray(collection) === false) {\n          return collection;\n        }\n        return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);\n      }),\n      distinctUntilArrayItemChanged(),\n      map(value => {\n        if (isArray(value) === false) {\n          return value;\n        }\n\n        if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {\n          return value;\n        }\n\n        return value[0];\n      })\n    );\n  };\n}\n","// @internal\nexport function isObject(value: any) {\n  const type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n","/**\n * Create an array value comparator for a specific key of the value.\n * @param prop The property of the value to be compared.\n */\nexport function byKey<T>(prop: keyof T) {\n  return (a: T, b: T) => a[prop] === b[prop];\n}\n\n/**\n * Create an array value comparator for the id field of an array value.\n */\nexport function byId<T extends Record<'id', any>>() {\n  return byKey<T>('id');\n}\n\n/**\n * Adds or removes a value from an array by comparing its values. If a matching value exists it is removed, otherwise\n * it is added to the array.\n *\n * @param array The array to modify.\n * @param newValue The new value to toggle.\n * @param compare A compare function to determine equality of array values. Default is an equality test by object identity.\n */\nexport function arrayToggle<T>(array: T[], newValue: T, compare: (a: T, b: T) => boolean = (a, b) => a === b) {\n  const index = array.findIndex((oldValue) => compare(newValue, oldValue));\n  return !!~index ? [...array.slice(0, index), ...array.slice(index + 1)] : [...array, newValue];\n}\n","import { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { isFunction } from './isFunction';\nimport { isObject } from './isObject';\nimport { IDS, ItemPredicate } from './types';\n\n/**\n * Update item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpdate(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpdate<T extends any[], Entity = any>(arr: T, predicateOrIds: IDS | ItemPredicate<Entity>, obj: Partial<Entity>, idKey = DEFAULT_ID_KEY): T {\n  let condition: ItemPredicate<Entity>;\n\n  if (isFunction(predicateOrIds)) {\n    condition = predicateOrIds;\n  } else {\n    const ids = coerceArray(predicateOrIds);\n    condition = (item) => ids.includes(isObject(item) ? item[idKey] : item) === true;\n  }\n\n  const updateFn = (state) =>\n    state.map((entity, index) => {\n      if (condition(entity, index) === true) {\n        return isObject(entity)\n          ? {\n              ...entity,\n              ...obj,\n            }\n          : obj;\n      }\n\n      return entity;\n    });\n\n  return updateFn(arr);\n}\n","export const DEFAULT_ID_KEY = 'id';\n","export interface AkitaConfig {\n  /**\n   * Whether to allowed the reset() stores functionality\n   */\n  resettable?: boolean;\n  ttl?: number;\n  producerFn?: (state: any, fn: any) => any;\n}\n\nlet CONFIG: AkitaConfig = {\n  resettable: false,\n  ttl: null,\n  producerFn: undefined\n};\n\nexport function akitaConfig(config: AkitaConfig) {\n  CONFIG = { ...CONFIG, ...config };\n}\n\n// @internal\nexport function getAkitaConfig() {\n  return CONFIG;\n}\n\nexport function getGlobalProducerFn() {\n  return CONFIG.producerFn;\n}\n","import { isNil } from './isNil';\n\n// @internal\nexport function isDefined(val: any) {\n  return isNil(val) === false;\n}\n","import { ReplaySubject, Subject } from 'rxjs';\nimport { StoreSnapshotAction } from './actions';\n\n// @internal\nexport const $$deleteStore = new Subject<string>();\n// @internal\nexport const $$addStore = new ReplaySubject<string>(50, 5000);\n// @internal\nexport const $$updateStore = new Subject<{ storeName: string; action: StoreSnapshotAction }>();\n\n// @internal\nexport function dispatchDeleted(storeName: string) {\n  $$deleteStore.next(storeName);\n}\n\n// @internal\nexport function dispatchAdded(storeName: string) {\n  $$addStore.next(storeName);\n}\n\n// @internal\nexport function dispatchUpdate(storeName: string, action: StoreSnapshotAction) {\n  $$updateStore.next({ storeName, action });\n}\n","export const isBrowser = typeof window !== 'undefined';\nexport const isNotBrowser = !isBrowser;\n// export const isNativeScript = typeof global !== 'undefined' && (<any>global).__runtimeVersion !== 'undefined'; TODO is this used?\nexport const hasLocalStorage = () => {\n  try {\n    return typeof localStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n};\nexport const hasSessionStorage = () => {\n  try {\n    return typeof sessionStorage !== 'undefined';\n  } catch {\n    return false;\n  }\n};\n","import { Query } from './query';\nimport { isBrowser } from './root';\nimport { Store } from './store';\n\n// @internal\nexport const __stores__: { [storeName: string]: Store<any> } = {};\n\n// @internal\nexport const __queries__: { [storeName: string]: Query<any> } = {};\n\nif (isBrowser) {\n  (window as any).$$stores = __stores__;\n  (window as any).$$queries = __queries__;\n}\n","// @internal\nexport function capitalize(value: string) {\n  return value && value.charAt(0).toUpperCase() + value.slice(1);\n}\n","import { currentAction, setSkipAction } from './actions';\nimport { isDefined } from './isDefined';\nimport { $$addStore, $$deleteStore, $$updateStore } from './dispatchers';\nimport { __stores__ } from './stores';\nimport { capitalize } from './capitalize';\nimport { isNotBrowser } from './root';\n\nexport type DevtoolsOptions = {\n  /** instance name visible in devtools */\n  name: string;\n  /**  maximum allowed actions to be stored in the history tree */\n  maxAge: number;\n  latency: number;\n  actionsBlacklist: string[];\n  actionsWhitelist: string[];\n  storesWhitelist: string[];\n  shouldCatchErrors: boolean;\n  logTrace: boolean;\n  predicate: (state: any, action: any) => boolean;\n  shallow: boolean;\n  sortAlphabetically: boolean;\n};\nlet subs = [];\n\nexport type NgZoneLike = { run: any };\n\nexport function akitaDevtools(ngZone: NgZoneLike, options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(options?: Partial<DevtoolsOptions>);\nexport function akitaDevtools(ngZoneOrOptions?: NgZoneLike | Partial<DevtoolsOptions>, options: Partial<DevtoolsOptions> = {}) {\n  if (isNotBrowser) return;\n\n  if (!(window as any).__REDUX_DEVTOOLS_EXTENSION__) {\n    return;\n  }\n\n  subs.length &&\n    subs.forEach((s) => {\n      if (s.unsubscribe) {\n        s.unsubscribe();\n      } else {\n        s && s();\n      }\n    });\n\n  const isAngular = ngZoneOrOptions && ngZoneOrOptions['run'];\n\n  if (!isAngular) {\n    ngZoneOrOptions = ngZoneOrOptions || {};\n    (ngZoneOrOptions as any).run = (cb) => cb();\n    options = ngZoneOrOptions as Partial<DevtoolsOptions>;\n  }\n\n  const defaultOptions: Partial<DevtoolsOptions> & { name: string } = { name: 'Akita', shallow: true, storesWhitelist: [] };\n  const merged = Object.assign({}, defaultOptions, options);\n  const storesWhitelist = merged.storesWhitelist;\n  const devTools = (window as any).__REDUX_DEVTOOLS_EXTENSION__.connect(merged);\n  let appState = {};\n\n  const isAllowed = (storeName) => {\n    if (!storesWhitelist.length) {\n      return true;\n    }\n\n    return storesWhitelist.indexOf(storeName) > -1;\n  };\n\n  subs.push(\n    $$addStore.subscribe((storeName) => {\n      if (isAllowed(storeName) === false) return;\n      appState = {\n        ...appState,\n        [storeName]: __stores__[storeName]._value(),\n      };\n      devTools.send({ type: `[${capitalize(storeName)}] - @@INIT` }, appState);\n    })\n  );\n\n  subs.push(\n    $$deleteStore.subscribe((storeName) => {\n      if (isAllowed(storeName) === false) return;\n      delete appState[storeName];\n      devTools.send({ type: `[${storeName}] - Delete Store` }, appState);\n    })\n  );\n\n  subs.push(\n    $$updateStore.subscribe(({ storeName, action }) => {\n      if (isAllowed(storeName) === false) return;\n      const { type, entityIds, skip, ...rest } = action;\n\n      const payload = rest.payload;\n      if (skip) {\n        setSkipAction(false);\n        return;\n      }\n\n      const store = __stores__[storeName];\n      if (!store) {\n        return;\n      }\n\n      if (options.shallow === false && appState[storeName]) {\n        const isEqual = JSON.stringify(store._value()) === JSON.stringify(appState[storeName]);\n        if (isEqual) return;\n      }\n\n      appState = {\n        ...appState,\n        [storeName]: store._value(),\n      };\n\n      const normalize = capitalize(storeName);\n      let msg = isDefined(entityIds) ? `[${normalize}] - ${type} (ids: ${entityIds})` : `[${normalize}] - ${type}`;\n\n      if (options.logTrace) {\n        console.group(msg);\n        console.trace();\n        console.groupEnd();\n      }\n\n      if (options.sortAlphabetically) {\n        const sortedAppState = Object.keys(appState)\n          .sort()\n          .reduce((acc, storeName) => {\n            acc[storeName] = appState[storeName];\n            return acc;\n          }, {});\n\n        devTools.send({ type: msg, ...payload }, sortedAppState)\n        return;\n      }\n\n      devTools.send({ type: msg, ...payload }, appState)\n    })\n  );\n\n  subs.push(\n    devTools.subscribe((message) => {\n      if (message.type === 'DISPATCH') {\n        const payloadType = message.payload.type;\n\n        if (payloadType === 'COMMIT') {\n          devTools.init(appState);\n          return;\n        }\n\n        if (message.state) {\n          const rootState = JSON.parse(message.state);\n          for (let i = 0, keys = Object.keys(rootState); i < keys.length; i++) {\n            const storeName = keys[i];\n            if (__stores__[storeName]) {\n              (ngZoneOrOptions as NgZoneLike).run(() => {\n                __stores__[storeName]._setState(() => rootState[storeName], false);\n              });\n            }\n          }\n        }\n      }\n    })\n  );\n}\n","export enum Order {\n  ASC = 'asc',\n  DESC = 'desc'\n}\n\n// @internal\nexport function compareValues(key, order: Order = Order.ASC) {\n  return function(a, b) {\n    if (!a.hasOwnProperty(key) || !b.hasOwnProperty(key)) {\n      return 0;\n    }\n\n    const varA = typeof a[key] === 'string' ? a[key].toUpperCase() : a[key];\n    const varB = typeof b[key] === 'string' ? b[key].toUpperCase() : b[key];\n\n    let comparison = 0;\n    if (varA > varB) {\n      comparison = 1;\n    } else if (varA < varB) {\n      comparison = -1;\n    }\n    return order == Order.DESC ? comparison * -1 : comparison;\n  };\n}\n","export enum EntityActions {\n  Set = 'Set',\n  Add = 'Add',\n  Update = 'Update',\n  Remove = 'Remove',\n}\n\nexport interface EntityAction<IDType> {\n  type: EntityActions;\n  ids: IDType[];\n}\n","import { EntityState, SelectOptions } from './types';\nimport { isFunction } from './isFunction';\nimport { compareValues } from './sort';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToArray<E, S extends EntityState>(state: S, options: SelectOptions<E>): E[] {\n  let arr = [];\n  const { ids, entities } = state;\n  const { filterBy, limitTo, sortBy, sortByOrder } = options;\n\n  for (let i = 0; i < ids.length; i++) {\n    const entity = entities[ids[i]];\n    if (!filterBy) {\n      arr.push(entity);\n      continue;\n    }\n\n    const toArray = coerceArray(filterBy);\n    const allPass = toArray.every(fn => fn(entity, i));\n    if (allPass) {\n      arr.push(entity);\n    }\n  }\n\n  if (sortBy) {\n    let _sortBy: any = isFunction(sortBy) ? sortBy : compareValues(sortBy, sortByOrder);\n    arr = arr.sort((a, b) => _sortBy(a, b, state));\n  }\n\n  const length = Math.min(limitTo || arr.length, arr.length);\n\n  return length === arr.length ? arr : arr.slice(0, length);\n}\n","import { EntityState } from './types';\nimport { isNil } from './isNil';\nimport { coerceArray } from './coerceArray';\n\n// @internal\nexport function entitiesToMap<S extends EntityState<E>, E>(state: S, options) {\n  const map = {};\n  const { filterBy, limitTo } = options;\n  const { ids, entities } = state;\n\n  if (!filterBy && !limitTo) {\n    return entities;\n  }\n  const hasLimit = isNil(limitTo) === false;\n\n  if (filterBy && hasLimit) {\n    let count = 0;\n    for (let i = 0, length = ids.length; i < length; i++) {\n      if (count === limitTo) break;\n      const id = ids[i];\n      const entity = entities[id];\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n        count++;\n      }\n    }\n  } else {\n    const finalLength = Math.min(limitTo || ids.length, ids.length);\n\n    for (let i = 0; i < finalLength; i++) {\n      const id = ids[i];\n      const entity = entities[id];\n\n      if (!filterBy) {\n        map[id] = entity;\n        continue;\n      }\n\n      const allPass = coerceArray(filterBy).every(fn => fn(entity, i));\n      if (allPass) {\n        map[id] = entity;\n      }\n    }\n  }\n\n  return map;\n}\n","import { EntityState, getEntityType, getIDType } from './types';\nimport { Observable } from 'rxjs';\n\nexport abstract class EntityService<S extends EntityState> {\n  abstract get<T>(id?: getIDType<S>, config?: any): Observable<T>;\n  abstract add<T>(entity: getEntityType<EntityState>, config?: any): Observable<T>;\n  abstract update<T>(id: getIDType<S>, entity: Partial<getEntityType<S>>, config: any): Observable<T>;\n  abstract delete<T>(id: getIDType<S>, config: any): Observable<T>;\n}\n","import { isBrowser } from './root';\n\nexport let __DEV__ = true;\n\nexport function enableAkitaProdMode() {\n  __DEV__ = false;\n  if (isBrowser) {\n    delete (window as any).$$stores;\n    delete (window as any).$$queries;\n  }\n}\n\n// @internal\nexport function isDev() {\n  return __DEV__;\n}\n","import { ID, IDS } from './types';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { isArray } from './isArray';\n\nexport type SetActiveOptions = { prev?: boolean; next?: boolean; wrap?: boolean };\n\n// @internal\nexport function getActiveEntities(idOrOptions: IDS | SetActiveOptions | null, ids: ID[], currentActive: IDS | null) {\n  let result;\n\n  if (isArray(idOrOptions)) {\n    result = idOrOptions;\n  } else {\n    if (isObject(idOrOptions)) {\n      if (isNil(currentActive)) return;\n      (idOrOptions as SetActiveOptions) = Object.assign({ wrap: true }, idOrOptions);\n      const currentIdIndex = ids.indexOf(currentActive as ID);\n      if ((idOrOptions as SetActiveOptions).prev) {\n        const isFirst = currentIdIndex === 0;\n        if (isFirst && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isFirst ? ids[ids.length - 1] : (ids[currentIdIndex - 1] as any);\n      } else if ((idOrOptions as SetActiveOptions).next) {\n        const isLast = ids.length === currentIdIndex + 1;\n        if (isLast && !(idOrOptions as SetActiveOptions).wrap) return;\n        result = isLast ? ids[0] : (ids[currentIdIndex + 1] as any);\n      }\n    } else {\n      if (idOrOptions === currentActive) return;\n      result = idOrOptions as ID;\n    }\n  }\n\n  return result;\n}\n","import { EntityState } from './index';\n\n// @internal\nexport const getInitialEntitiesState = () =>\n  ({\n    entities: {},\n    ids: [],\n    loading: true,\n    error: null\n  } as EntityState);\n","// @internal\nexport function isUndefined(value: any): value is undefined {\n  return value === undefined;\n}\n","import { EntityState, ID, StateWithActive } from './types';\nimport { isNil } from './isNil';\nimport { hasActiveState, isMultiActiveState, resolveActiveEntity } from './activeState';\n\nexport type RemoveEntitiesParams<State, Entity> = {\n  state: StateWithActive<State>;\n  ids: any[];\n};\n\n// @internal\nexport function removeEntities<S extends EntityState<E>, E>({ state, ids }: RemoveEntitiesParams<S, E>): S {\n  if (isNil(ids)) return removeAllEntities(state);\n  const entities = state.entities;\n  let newEntities = {};\n\n  for (const id of state.ids) {\n    if (ids.includes(id) === false) {\n      newEntities[id] = entities[id];\n    }\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: state.ids.filter(current => ids.includes(current) === false)\n  };\n\n  if (hasActiveState(state)) {\n    newState.active = resolveActiveEntity(newState);\n  }\n\n  return newState;\n}\n\n// @internal\nexport function removeAllEntities<S>(state: StateWithActive<S>): S {\n  return {\n    ...state,\n    entities: {},\n    ids: [],\n    active: isMultiActiveState(state.active) ? [] : null\n  };\n}\n","import { PreAddEntity } from './types';\n\n// @internal\nexport function toEntitiesObject<E>(entities: E[], idKey: string, preAddEntity: PreAddEntity<E>) {\n  const acc = {\n    entities: {},\n    ids: []\n  };\n\n  for (const entity of entities) {\n    // evaluate the middleware first to support dynamic ids\n    const current = preAddEntity(entity);\n    acc.entities[current[idKey]] = current;\n    acc.ids.push(current[idKey]);\n  }\n\n  return acc;\n}\n","import { Entities, EntityState, HashMap, ID, PreAddEntity } from './types';\nimport { toEntitiesObject } from './toEntitiesObject';\nimport { isArray } from './isArray';\nimport { hasActiveState, resolveActiveEntity } from './activeState';\n\nexport type SetEntities<Entity> = Entity[] | Entities<Entity> | HashMap<Entity>;\n\nexport type SetEntitiesParams<State, Entity> = {\n  state: State;\n  entities: SetEntities<Entity>;\n  idKey: string;\n  preAddEntity: PreAddEntity<Entity>;\n  isNativePreAdd?: boolean;\n};\n\n// @internal\nexport function isEntityState<Entity>(state): state is Entities<Entity> {\n  return state.entities && state.ids;\n}\n\n// @internal\nfunction applyMiddleware<E>(entities: HashMap<E>, preAddEntity: PreAddEntity<E>) {\n  let mapped = {};\n  for (const id of Object.keys(entities)) {\n    mapped[id] = preAddEntity(entities[id]);\n  }\n\n  return mapped;\n}\n\n// @internal\nexport function setEntities<S extends EntityState<E>, E>({ state, entities, idKey, preAddEntity, isNativePreAdd }: SetEntitiesParams<S, E>): S {\n  let newEntities: HashMap<E>;\n  let newIds: ID[];\n\n  if (isArray(entities)) {\n    const resolve = toEntitiesObject(entities, idKey, preAddEntity);\n    newEntities = resolve.entities;\n    newIds = resolve.ids;\n  } else if (isEntityState(entities)) {\n    newEntities = isNativePreAdd ? entities.entities : applyMiddleware(entities.entities, preAddEntity);\n    newIds = entities.ids;\n  } else {\n    // it's an object\n    newEntities = isNativePreAdd ? entities : applyMiddleware(entities, preAddEntity);\n    newIds = Object.keys(newEntities).map(id => (isNaN(id as any) ? id : Number(id)));\n  }\n\n  const newState = {\n    ...state,\n    entities: newEntities,\n    ids: newIds,\n    loading: false\n  };\n\n  if (hasActiveState(state)) {\n    (newState as any).active = resolveActiveEntity(newState as any);\n  }\n\n  return newState;\n}\n","// @internal\nexport function deepFreeze(o) {\n  Object.freeze(o);\n\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      hasOwnProp.call(o, prop) &&\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n}\n","// @internal\nexport class AkitaError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n// @internal\nexport function assertStoreHasName(name: string, className: string) {\n  if (!name) {\n    console.error(`@StoreConfig({ name }) is missing in ${className}`);\n  }\n}\n","// @internal\nexport function toBoolean(value: any): boolean {\n  return value != null && `${value}` !== 'false';\n}\n","import { toBoolean } from './toBoolean';\n\n// @internal\nexport function isPlainObject(value) {\n  return toBoolean(value) && value.constructor.name === 'Object';\n}\n","import { BehaviorSubject, Observable, of, Subject } from 'rxjs';\nimport { logAction } from './actions';\nimport { tap } from 'rxjs/operators';\n\n// @internal\nconst transactionFinished = new Subject();\n\n// @internal\nconst transactionInProcess = new BehaviorSubject(false);\n\nexport type TransactionManager = {\n  activeTransactions: number;\n  batchTransaction: Subject<boolean> | null;\n};\n\n// @internal\nexport const transactionManager: TransactionManager = {\n  activeTransactions: 0,\n  batchTransaction: null\n};\n\n// @internal\nexport function startBatch() {\n  if (!isTransactionInProcess()) {\n    transactionManager.batchTransaction = new Subject();\n  }\n  transactionManager.activeTransactions++;\n  transactionInProcess.next(true);\n}\n\n// @internal\nexport function endBatch() {\n  if (--transactionManager.activeTransactions === 0) {\n    transactionManager.batchTransaction.next(true);\n    transactionManager.batchTransaction.complete();\n    transactionInProcess.next(false);\n    transactionFinished.next(true);\n  }\n}\n\n// @internal\nexport function isTransactionInProcess() {\n  return transactionManager.activeTransactions > 0;\n}\n\n// @internal\nexport function commit(): Observable<boolean> {\n  return transactionManager.batchTransaction ? transactionManager.batchTransaction.asObservable() : of(true);\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *  The following code will update the store, BUT  emits only once\n *\n *  @example\n *  applyTransaction(() => {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  });\n *\n */\nexport function applyTransaction<T>(action: () => T, thisArg = undefined): T {\n  startBatch();\n  try {\n    return action.apply(thisArg);\n  } finally {\n    logAction('@Transaction');\n    endBatch();\n  }\n}\n\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *\n *  The following code will update the store, BUT  emits only once.\n *\n *  @example\n *  @transaction\n *  addTodos() {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  }\n *\n *\n */\nexport function transaction() {\n  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function(...args) {\n      return applyTransaction(() => {\n        return originalMethod.apply(this, args);\n      }, this);\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n *\n * RxJS custom operator that wraps the callback inside transaction\n *\n * @example\n *\n * return http.get().pipe(\n *    withTransaction(response > {\n *      store.setActive(1);\n *      store.update();\n *      store.updateEntity(1, {});\n *    })\n * )\n *\n */\nexport function withTransaction<T>(next: (value: T) => void) {\n  return function(source: Observable<T>): Observable<T> {\n    return source.pipe(tap(value => applyTransaction(() => next(value))));\n  };\n}\n","import { BehaviorSubject, Observable } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { currentAction, resetCustomAction, setAction, StoreSnapshotAction } from './actions';\nimport { getAkitaConfig, getGlobalProducerFn } from './config';\nimport { deepFreeze } from './deepFreeze';\nimport { dispatchAdded, dispatchDeleted, dispatchUpdate } from './dispatchers';\nimport { isDev, __DEV__ } from './env';\nimport { assertStoreHasName } from './errors';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isPlainObject } from './isPlainObject';\nimport { isBrowser } from './root';\nimport { configKey, StoreConfigOptions, UpdatableStoreConfigOptions } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { commit, isTransactionInProcess } from './transaction';\nimport { StoreCache, UpdateStateCallback } from './types';\n\ninterface StoreSnapshot<S> {\n  state: S;\n  action?: StoreSnapshotAction;\n}\n\n/**\n *\n * Store for managing any type of data\n *\n * @example\n *\n * export interface SessionState {\n *   token: string;\n *   userDetails: UserDetails\n * }\n *\n * export function createInitialState(): SessionState {\n *  return {\n *    token: '',\n *    userDetails: null\n *  };\n * }\n *\n * @StoreConfig({ name: 'session' })\n * export class SessionStore extends Store<SessionState> {\n *   constructor() {\n *    super(createInitialState());\n *   }\n * }\n */\nexport class Store<S = any> {\n  private store: BehaviorSubject<Readonly<StoreSnapshot<S>>>;\n  private storeValue: S;\n  private inTransaction = false;\n  private _initialState: S;\n  protected cache: StoreCache = {\n    active: new BehaviorSubject<boolean>(false),\n    ttl: null,\n  };\n\n  constructor(initialState: Partial<S>, protected options: Partial<StoreConfigOptions> = {}) {\n    this.onInit(initialState as S);\n  }\n\n  /**\n   *  Set the loading state\n   *\n   *  @example\n   *\n   *  store.setLoading(true)\n   *\n   */\n  setLoading(loading = false) {\n    if (loading !== (this._value() as S & { loading: boolean }).loading) {\n      isDev() && setAction('Set Loading');\n      this._setState((state) => ({ ...state, loading } as S & { loading: boolean }));\n    }\n  }\n\n  /**\n   *\n   * Set whether the data is cached\n   *\n   * @example\n   *\n   * store.setHasCache(true)\n   * store.setHasCache(false)\n   * store.setHasCache(true, { restartTTL: true })\n   *\n   */\n  setHasCache(hasCache: boolean, options: { restartTTL: boolean } = { restartTTL: false }) {\n    if (hasCache !== this.cache.active.value) {\n      this.cache.active.next(hasCache);\n    }\n\n    if (options.restartTTL) {\n      const ttlConfig = this.getCacheTTL();\n      if (ttlConfig) {\n        if (this.cache.ttl !== null) {\n          clearTimeout(this.cache.ttl);\n        }\n        this.cache.ttl = <any>setTimeout(() => this.setHasCache(false), ttlConfig);\n      }\n    }\n  }\n\n  /**\n   *\n   * Sometimes we need to access the store value from a store\n   *\n   * @example middleware\n   *\n   */\n  getValue() {\n    return this.storeValue;\n  }\n\n  /**\n   *  Set the error state\n   *\n   *  @example\n   *\n   *  store.setError({text: 'unable to load data' })\n   *\n   */\n  setError<T>(error: T) {\n    if (error !== (this._value() as S & { error: any }).error) {\n      isDev() && setAction('Set Error');\n      this._setState((state) => ({ ...state, error } as S & { error: any }));\n    }\n  }\n\n  // @internal\n  _select<R>(project: (store: S) => R): Observable<R> {\n    return this.store.asObservable().pipe(\n      map((snapshot) => project(snapshot.state)),\n      distinctUntilChanged()\n    );\n  }\n\n  // @internal\n  _value(): S {\n    return this.storeValue;\n  }\n\n  // @internal\n  _cache(): BehaviorSubject<boolean> {\n    return this.cache.active;\n  }\n\n  // @internal\n  get config(): StoreConfigOptions {\n    return this.constructor[configKey] || {};\n  }\n\n  // @internal\n  get storeName() {\n    return (this.config as StoreConfigOptions & { storeName: string }).storeName || (this.options as StoreConfigOptions & { storeName: string }).storeName || this.options.name;\n  }\n\n  // @internal\n  get deepFreeze() {\n    return this.config.deepFreezeFn || this.options.deepFreezeFn || deepFreeze;\n  }\n\n  // @internal\n  get cacheConfig() {\n    return this.config.cache || this.options.cache;\n  }\n\n  get _producerFn() {\n    return this.config.producerFn || this.options.producerFn || getGlobalProducerFn();\n  }\n\n  // @internal\n  get resettable() {\n    return isDefined(this.config.resettable) ? this.config.resettable : this.options.resettable;\n  }\n\n  // @internal\n  _setState(newState: ((state: Readonly<S>) => S) | S, _dispatchAction = true) {\n    if (isFunction(newState)) {\n      const _newState = newState(this._value());\n      this.storeValue = __DEV__ ? this.deepFreeze(_newState) : _newState;\n    } else {\n      this.storeValue = newState;\n    }\n\n    if (!this.store) {\n      this.store = new BehaviorSubject({ state: this.storeValue });\n\n      if (isDev()) {\n        this.store.subscribe(({ action }) => {\n          if (action) {\n            dispatchUpdate(this.storeName, action);\n          }\n        });\n      }\n\n      return;\n    }\n\n    if (isTransactionInProcess()) {\n      this.handleTransaction();\n      return;\n    }\n\n    this.dispatch(this.storeValue, _dispatchAction);\n  }\n\n  /**\n   *\n   * Reset the current store back to the initial value\n   *\n   * @example\n   *\n   * store.reset()\n   *\n   */\n  reset() {\n    if (this.isResettable()) {\n      isDev() && setAction('Reset');\n      this._setState(() => Object.assign({}, this._initialState));\n      this.setHasCache(false);\n    } else {\n      isDev() && console.warn(`You need to enable the reset functionality`);\n    }\n  }\n\n  /**\n   *\n   * Update the store's value\n   *\n   * @example\n   *\n   * this.store.update(state => {\n   *   return {...}\n   * })\n   */\n  update(stateCallback: UpdateStateCallback<S>);\n  /**\n   *\n   * @example\n   *\n   *  this.store.update({ token: token })\n   */\n  update(state: Partial<S>);\n  update(stateOrCallback: Partial<S> | UpdateStateCallback<S>) {\n    isDev() && setAction('Update');\n\n    let newState;\n    const currentState = this._value();\n    if (isFunction(stateOrCallback)) {\n      newState = isFunction(this._producerFn) ? this._producerFn(currentState, stateOrCallback) : stateOrCallback(currentState);\n    } else {\n      newState = stateOrCallback;\n    }\n\n    const withHook = this.akitaPreUpdate(currentState, { ...currentState, ...newState } as S);\n    const resolved = isPlainObject(currentState) ? withHook : new (currentState as any).constructor(withHook);\n    this._setState(resolved);\n  }\n\n  updateStoreConfig(newOptions: UpdatableStoreConfigOptions) {\n    this.options = { ...this.options, ...newOptions };\n  }\n\n  // @internal\n  akitaPreUpdate(_: Readonly<S>, nextState: Readonly<S>): S {\n    return nextState;\n  }\n\n  ngOnDestroy() {\n    this.destroy();\n  }\n\n  /**\n   *\n   * Destroy the store\n   *\n   * @example\n   *\n   * store.destroy()\n   *\n   */\n  destroy() {\n    const hmrEnabled = isBrowser ? (window as any).hmrEnabled : false;\n    if (!hmrEnabled && this === __stores__[this.storeName]) {\n      delete __stores__[this.storeName];\n      dispatchDeleted(this.storeName);\n      this.setHasCache(false);\n      this.cache.active.complete();\n      this.store.complete();\n    }\n  }\n\n  private onInit(initialState: S) {\n    __stores__[this.storeName] = this;\n    this._setState(() => initialState);\n    dispatchAdded(this.storeName);\n    if (this.isResettable()) {\n      this._initialState = initialState;\n    }\n    isDev() && assertStoreHasName(this.storeName, this.constructor.name);\n  }\n\n  private dispatch(state: S, _dispatchAction = true) {\n    let action: StoreSnapshotAction | undefined = undefined;\n\n    if (_dispatchAction) {\n      action = currentAction;\n      resetCustomAction();\n    }\n\n    this.store.next({ state, action });\n  }\n\n  private watchTransaction() {\n    commit().subscribe(() => {\n      this.inTransaction = false;\n      this.dispatch(this._value());\n    });\n  }\n\n  private isResettable() {\n    if (this.resettable === false) {\n      return false;\n    }\n    return this.resettable || getAkitaConfig().resettable;\n  }\n\n  private handleTransaction() {\n    if (!this.inTransaction) {\n      this.watchTransaction();\n      this.inTransaction = true;\n    }\n  }\n\n  private getCacheTTL() {\n    return (this.cacheConfig && this.cacheConfig.ttl) || getAkitaConfig().ttl;\n  }\n}\n","import { Subject } from 'rxjs';\nimport { EntityState, ID, PreUpdateEntity, UpdateStateCallback } from './types';\nimport { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n\nexport type UpdateEntitiesParams<State, Entity> = {\n  state: State;\n  ids: any[];\n  idKey: string;\n  newStateOrFn: UpdateStateCallback<Entity> | Partial<Entity> | Partial<State>;\n  preUpdateEntity: PreUpdateEntity<Entity>;\n  producerFn;\n  onEntityIdChanges: (oldId: any, newId: any) => void;\n};\n\n// @internal\nexport function updateEntities<S extends EntityState<E>, E>({ state, ids, idKey, newStateOrFn, preUpdateEntity, producerFn, onEntityIdChanges }: UpdateEntitiesParams<S, E>) {\n  const updatedEntities = {};\n\n  let isUpdatingIdKey = false;\n  let idToUpdate: ID;\n\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity: E;\n    idToUpdate = id;\n\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n\n    const merged = {\n      ...oldEntity,\n      ...newState,\n    };\n\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new (oldEntity as any).constructor(merged);\n      } else {\n        newEntity = new (newState as any).constructor(merged);\n      }\n    }\n\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const { [id]: deletedEntity, ...rest } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map((current) => (current === id ? idToUpdate : current));\n    onEntityIdChanges(id, idToUpdate);\n  }\n\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities,\n    },\n    ids: updatedIds,\n  };\n}\n","import { Subject } from 'rxjs';\nimport { logAction, setAction } from './actions';\nimport { addEntities, AddEntitiesOptions } from './addEntities';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { isDev } from './env';\nimport { getActiveEntities, SetActiveOptions } from './getActiveEntities';\nimport { getInitialEntitiesState } from './getInitialEntitiesState';\nimport { hasEntity } from './hasEntity';\nimport { isDefined } from './isDefined';\nimport { isEmpty } from './isEmpty';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isUndefined } from './isUndefined';\nimport { removeEntities } from './removeEntities';\nimport { SetEntities, setEntities } from './setEntities';\nimport { Store } from './store';\nimport { StoreConfigOptions } from './storeConfig';\nimport { transaction } from './transaction';\nimport {\n  Constructor,\n  CreateStateCallback,\n  EntityState,\n  EntityUICreateFn,\n  getEntityType,\n  getIDType,\n  IDS,\n  OrArray,\n  StateWithActive,\n  UpdateEntityPredicate,\n  UpdateStateCallback,\n  UpsertStateCallback,\n} from './types';\nimport { updateEntities } from './updateEntities';\n\n/**\n *\n * Store for managing a collection of entities\n *\n * @example\n *\n * export interface WidgetsState extends EntityState<Widget> { }\n *\n * @StoreConfig({ name: 'widgets' })\n *  export class WidgetsStore extends EntityStore<WidgetsState> {\n *   constructor() {\n *     super();\n *   }\n * }\n *\n *\n */\nexport class EntityStore<S extends EntityState = any, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Store<S> {\n  ui: EntityUIStore<any, EntityType>;\n  private entityActions = new Subject<EntityAction<IDType>>();\n  private entityIdChanges = new Subject<{ newId: IDType; oldId: IDType; pending: boolean }>();\n\n  constructor(initialState: Partial<S> = {}, protected options: Partial<StoreConfigOptions> = {}) {\n    super({ ...getInitialEntitiesState(), ...initialState }, options);\n  }\n\n  // @internal\n  get selectEntityAction$() {\n    return this.entityActions.asObservable();\n  }\n\n  // @internal\n  get selectEntityIdChanges$() {\n    return this.entityIdChanges.asObservable();\n  }\n\n  // @internal\n  get idKey() {\n    return (this.config as StoreConfigOptions).idKey || this.options.idKey || DEFAULT_ID_KEY;\n  }\n\n  /**\n   *\n   * Replace current collection with provided collection\n   *\n   * @example\n   *\n   * this.store.set([Entity, Entity])\n   * this.store.set({ids: [], entities: {}})\n   * this.store.set({ 1: {}, 2: {}})\n   *\n   */\n  set(entities: SetEntities<EntityType>, options: { activeId?: IDType | null } = {}) {\n    if (isNil(entities)) return;\n\n    isDev() && setAction('Set Entity');\n\n    const isNativePreAdd = this.akitaPreAddEntity === EntityStore.prototype.akitaPreAddEntity;\n    this.setHasCache(true, { restartTTL: true });\n\n    this._setState((state) => {\n      const newState = setEntities({\n        state,\n        entities,\n        idKey: this.idKey,\n        preAddEntity: this.akitaPreAddEntity,\n        isNativePreAdd,\n      });\n\n      if (isUndefined(options.activeId) === false) {\n        (newState as any).active = options.activeId;\n      }\n\n      return newState;\n    });\n\n    if (this.hasInitialUIState()) {\n      this.handleUICreation();\n    }\n\n    this.entityActions.next({ type: EntityActions.Set, ids: this.ids });\n  }\n\n  /**\n   * Add entities\n   *\n   * @example\n   *\n   * this.store.add([Entity, Entity])\n   * this.store.add(Entity)\n   * this.store.add(Entity, { prepend: true })\n   *\n   * this.store.add(Entity, { loading: false })\n   */\n  add(entities: OrArray<EntityType>, options: AddEntitiesOptions = { loading: false }) {\n    const collection = coerceArray(entities);\n\n    if (isEmpty(collection)) return;\n\n    const data = addEntities({\n      state: this._value(),\n      preAddEntity: this.akitaPreAddEntity,\n      entities: collection,\n      idKey: this.idKey,\n      options,\n    });\n\n    if (data) {\n      isDev() && setAction('Add Entity');\n      data.newState.loading = options.loading;\n\n      this._setState(() => data.newState);\n\n      if (this.hasInitialUIState()) {\n        this.handleUICreation(true);\n      }\n\n      this.entityActions.next({ type: EntityActions.Add, ids: data.newIds });\n    }\n  }\n\n  /**\n   *\n   * Update entities\n   *\n   * @example\n   *\n   * store.update(1, entity => ...)\n   * store.update([1, 2, 3], entity => ...)\n   * store.update(null, entity => ...)\n   */\n  update(id: OrArray<IDType> | null, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(1, { name: newName })\n   */\n  update(id: OrArray<IDType> | null, newState: Partial<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, entity => ({ name: newName }))\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newStateFn: UpdateStateCallback<EntityType>);\n  /**\n   * store.update(entity => entity.price > 3, { name: newName })\n   */\n  update(predicate: UpdateEntityPredicate<EntityType>, newState: Partial<EntityType>);\n  /** Support non-entity updates */\n  update(newState: UpdateStateCallback<S>);\n  update(newState: Partial<S>);\n  update(\n    idsOrFnOrState: OrArray<IDType> | null | Partial<S> | UpdateStateCallback<S> | UpdateEntityPredicate<EntityType>,\n    newStateOrFn?: UpdateStateCallback<EntityType> | Partial<EntityType> | Partial<S>\n  ) {\n    if (isUndefined(newStateOrFn)) {\n      super.update(idsOrFnOrState as Partial<S>);\n      return;\n    }\n    let ids: IDType[] = [];\n\n    if (isFunction(idsOrFnOrState)) {\n      // We need to filter according the predicate function\n      ids = this.ids.filter((id) => (idsOrFnOrState as UpdateEntityPredicate<EntityType>)(this.entities[id]));\n    } else {\n      // If it's nil we want all of them\n      ids = isNil(idsOrFnOrState) ? this.ids : coerceArray(idsOrFnOrState as OrArray<IDType>);\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Update Entity', ids);\n\n    let entityIdChanged:\n      | undefined\n      | {\n          newId: IDType;\n          oldId: IDType;\n        };\n\n    this._setState((state) =>\n      updateEntities({\n        idKey: this.idKey,\n        ids,\n        preUpdateEntity: this.akitaPreUpdateEntity,\n        state,\n        newStateOrFn,\n        producerFn: this._producerFn,\n        onEntityIdChanges: (oldId: IDType, newId: IDType) => {\n          entityIdChanged = { oldId, newId };\n          this.entityIdChanges.next({ ...entityIdChanged, pending: true });\n        },\n      })\n    );\n\n    if (entityIdChanged) {\n      this.entityIdChanges.next({ ...entityIdChanged, pending: false });\n    }\n\n    this.entityActions.next({ type: EntityActions.Update, ids });\n  }\n\n  /**\n   *\n   * Create or update.\n   *\n   * Warning: By omitting the initializing callback parameter onCreate(), the type safety of entities cannot be guaranteed.\n   *\n   * @example\n   *\n   * store.upsert(1, { active: true });\n   * store.upsert([2, 3], { active: true });\n   * store.upsert([2, 3], entity => ({ isOpen: !(entity?.isOpen ?? true) }))\n   *\n   */\n  upsert<NewEntityType extends Partial<EntityType>>(ids: OrArray<IDType>, newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType, options?: { baseClass?: Constructor }): void;\n  /**\n   *\n   * Create or update\n   *\n   * @example\n   *\n   * store.upsert(1, { active: true }, (id, newState) => ({ id, ...newState, enabled: true }));\n   * store.upsert([2, 3], { active: true }, (id, newState) => ({ id, ...newState, enabled: true }));\n   * store.upsert([2, 3], entity => ({ isOpen: !(entity?.isOpen ?? true) }), (id, newState) => ({ id, ...newState, enabled: true }));\n   *\n   */\n  upsert<NewEntityType extends Partial<EntityType>>(\n    ids: OrArray<IDType>,\n    newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType,\n    onCreate: CreateStateCallback<EntityType, NewEntityType, IDType>,\n    options?: { baseClass?: Constructor }\n  ): void;\n  @transaction()\n  upsert<NewEntityType extends Partial<EntityType>>(\n    ids: OrArray<IDType>,\n    newState: UpsertStateCallback<EntityType, NewEntityType> | NewEntityType,\n    onCreate?: CreateStateCallback<EntityType, NewEntityType, IDType> | { baseClass?: Constructor },\n    options: { baseClass?: Constructor } = {}\n  ) {\n    const toArray = coerceArray(ids);\n    const predicate = (isUpdate) => (id) => hasEntity(this.entities, id) === isUpdate;\n    const baseClass = isFunction(onCreate) ? options.baseClass : onCreate ? onCreate.baseClass : undefined;\n    const isClassBased = isFunction(baseClass);\n\n    const updateIds = toArray.filter(predicate(true));\n    const newEntities = toArray.filter(predicate(false)).map((id) => {\n      const newStateObj = typeof newState === 'function' ? newState({}) : newState;\n      const entity = isFunction(onCreate) ? onCreate(id, newStateObj) : newStateObj;\n      const withId = { ...entity, [this.idKey]: id };\n      if (isClassBased) {\n        return new baseClass(withId);\n      }\n      return withId;\n    });\n\n    // it can be any of the three types\n    this.update(updateIds, newState as UpdateStateCallback<EntityType, NewEntityType>);\n    this.add(newEntities);\n    isDev() && logAction('Upsert Entity');\n  }\n\n  /**\n   *\n   * Upsert entity collection (idKey must be present)\n   *\n   * @example\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }]);\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });\n   *\n   */\n  upsertMany(entities: EntityType[], options: { baseClass?: Constructor; loading?: boolean } = {}) {\n    const addedIds = [];\n    const updatedIds = [];\n    const updatedEntities = {};\n\n    // Update the state directly to optimize performance\n    for (const entity of entities) {\n      const withPreCheckHook = this.akitaPreCheckEntity(entity);\n      const id = withPreCheckHook[this.idKey];\n      if (hasEntity(this.entities, id)) {\n        const prev = this._value().entities[id];\n        const merged = { ...this._value().entities[id], ...withPreCheckHook };\n        const next = options.baseClass ? new options.baseClass(merged) : merged;\n        const withHook = this.akitaPreUpdateEntity(prev, next);\n        const nextId = withHook[this.idKey];\n        updatedEntities[nextId] = withHook;\n        updatedIds.push(nextId);\n      } else {\n        const newEntity = options.baseClass ? new options.baseClass(withPreCheckHook) : withPreCheckHook;\n        const withHook = this.akitaPreAddEntity(newEntity);\n        const nextId = withHook[this.idKey];\n        addedIds.push(nextId);\n        updatedEntities[nextId] = withHook;\n      }\n    }\n\n    isDev() && logAction('Upsert Many');\n\n    this._setState((state) => ({\n      ...state,\n      ids: addedIds.length ? [...state.ids, ...addedIds] : state.ids,\n      entities: {\n        ...state.entities,\n        ...updatedEntities,\n      },\n      loading: !!options.loading,\n    }));\n\n    updatedIds.length && this.entityActions.next({ type: EntityActions.Update, ids: updatedIds });\n    addedIds.length && this.entityActions.next({ type: EntityActions.Add, ids: addedIds });\n    if (addedIds.length && this.hasUIStore()) {\n      this.handleUICreation(true);\n    }\n  }\n\n  /**\n   *\n   * Replace one or more entities (except the id property)\n   *\n   *\n   * @example\n   *\n   * this.store.replace(5, newEntity)\n   * this.store.replace([1,2,3], newEntity)\n   */\n  replace(ids: IDS, newState: Partial<EntityType>) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const replaced = {};\n    for (const id of toArray) {\n      replaced[id] = { ...newState, [this.idKey]: id };\n    }\n    isDev() && setAction('Replace Entity', ids);\n    this._setState((state) => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        ...replaced,\n      },\n    }));\n  }\n\n  /**\n   *\n   * Move entity inside the collection\n   *\n   *\n   * @example\n   *\n   * this.store.move(fromIndex, toIndex)\n   */\n  move(from: number, to: number) {\n    const ids = this.ids.slice();\n    ids.splice(to < 0 ? ids.length + to : to, 0, ids.splice(from, 1)[0]);\n\n    isDev() && setAction('Move Entity');\n    this._setState((state) => ({\n      ...state,\n      // Change the entities reference so that selectAll emit\n      entities: {\n        ...state.entities,\n      },\n      ids,\n    }));\n  }\n\n  /**\n   *\n   * Remove one or more entities\n   *\n   * @example\n   *\n   * this.store.remove(5)\n   * this.store.remove([1,2,3])\n   * this.store.remove()\n   */\n  remove(id?: OrArray<IDType>);\n  /**\n   * this.store.remove(entity => entity.id === 1)\n   */\n  remove(predicate: (entity: Readonly<EntityType>) => boolean);\n  remove(idsOrFn?: OrArray<IDType> | ((entity: Readonly<EntityType>) => boolean)) {\n    if (isEmpty(this.ids)) return;\n\n    const idPassed = isDefined(idsOrFn);\n\n    // null means remove all\n    let ids: IDType[] | null = [];\n\n    if (isFunction(idsOrFn)) {\n      ids = this.ids.filter((entityId) => idsOrFn(this.entities[entityId]));\n    } else {\n      ids = idPassed ? coerceArray(idsOrFn) : this.ids;\n    }\n\n    if (isEmpty(ids)) return;\n\n    isDev() && setAction('Remove Entity', ids);\n    this._setState((state: StateWithActive<S>) => removeEntities({ state, ids }));\n\n    if (!idPassed) {\n      this.setHasCache(false);\n    }\n\n    this.handleUIRemove(ids);\n    this.entityActions.next({ type: EntityActions.Remove, ids });\n  }\n\n  /**\n   *\n   * Update the active entity\n   *\n   * @example\n   *\n   * this.store.updateActive({ completed: true })\n   * this.store.updateActive(active => {\n   *   return {\n   *     config: {\n   *      ..active.config,\n   *      date\n   *     }\n   *   }\n   * })\n   */\n  updateActive(newStateOrCallback: UpdateStateCallback<EntityType> | Partial<EntityType>) {\n    const ids = coerceArray(this.active);\n    isDev() && setAction('Update Active', ids);\n    this.update(ids, newStateOrCallback as Partial<EntityType>);\n  }\n\n  /**\n   * Set the given entity as active\n   *\n   * @example\n   *\n   * store.setActive(1)\n   * store.setActive([1, 2, 3])\n   */\n  setActive(idOrOptions: S['active'] extends any[] ? S['active'] : SetActiveOptions | S['active']);\n  setActive(idOrOptions: IDType | SetActiveOptions | null) {\n    const active = getActiveEntities(idOrOptions, this.ids, this.active);\n\n    if (active === undefined) {\n      return;\n    }\n\n    isDev() && setAction('Set Active', active);\n    this._setActive(active);\n  }\n\n  /**\n   * Add active entities\n   *\n   * @example\n   *\n   * store.addActive(2);\n   * store.addActive([3, 4, 5]);\n   */\n  addActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const everyExist = toArray.every((id) => this.active.indexOf(id) > -1);\n    if (everyExist) return;\n\n    isDev() && setAction('Add Active', ids);\n    this._setState((state) => {\n      /** Protect against case that one of the items in the array exist */\n      const uniques = Array.from(new Set([...(state.active as IDType[]), ...toArray]));\n      return {\n        ...state,\n        active: uniques,\n      };\n    });\n  }\n\n  /**\n   * Remove active entities\n   *\n   * @example\n   *\n   * store.removeActive(2)\n   * store.removeActive([3, 4, 5])\n   */\n  removeActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const someExist = toArray.some((id) => this.active.indexOf(id) > -1);\n    if (!someExist) return;\n\n    isDev() && setAction('Remove Active', ids);\n    this._setState((state) => {\n      return {\n        ...state,\n        active: Array.isArray(state.active) ? state.active.filter((currentId) => toArray.indexOf(currentId) === -1) : null,\n      };\n    });\n  }\n\n  /**\n   * Toggle active entities\n   *\n   * @example\n   *\n   * store.toggle(2)\n   * store.toggle([3, 4, 5])\n   */\n  @transaction()\n  toggleActive<T = OrArray<IDType>>(ids: T) {\n    const toArray = coerceArray(ids);\n    const filterExists = (remove) => (id) => this.active.includes(id) === remove;\n    const remove = toArray.filter(filterExists(true));\n    const add = toArray.filter(filterExists(false));\n    this.removeActive(remove);\n    this.addActive(add);\n    isDev() && logAction('Toggle Active');\n  }\n\n  /**\n   *\n   * Create sub UI store for managing Entity's UI state\n   *\n   * @example\n   *\n   * export type ProductUI = {\n   *   isLoading: boolean;\n   *   isOpen: boolean\n   * }\n   *\n   * interface ProductsUIState extends EntityState<ProductUI> {}\n   *\n   * export class ProductsStore EntityStore<ProductsState, Product> {\n   *   ui: EntityUIStore<ProductsUIState, ProductUI>;\n   *\n   *   constructor() {\n   *     super();\n   *     this.createUIStore();\n   *   }\n   *\n   * }\n   */\n  createUIStore(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    const defaults: Partial<StoreConfigOptions> = { name: `UI/${this.storeName}`, idKey: this.idKey };\n    this.ui = new EntityUIStore(initialState, { ...defaults, ...storeConfig });\n    return this.ui;\n  }\n\n  // @internal\n  destroy() {\n    super.destroy();\n    if (this.ui instanceof EntityStore) {\n      this.ui.destroy();\n    }\n    this.entityActions.complete();\n  }\n\n  // @internal\n  akitaPreUpdateEntity(_: Readonly<EntityType>, nextEntity: any): EntityType {\n    return nextEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreAddEntity(newEntity: any): EntityType {\n    return newEntity as EntityType;\n  }\n\n  // @internal\n  akitaPreCheckEntity(newEntity: Readonly<EntityType>): EntityType {\n    return newEntity;\n  }\n\n  private get ids() {\n    return this._value().ids;\n  }\n\n  private get entities() {\n    return this._value().entities;\n  }\n\n  private get active() {\n    return this._value().active;\n  }\n\n  private _setActive(ids: OrArray<IDType>) {\n    this._setState((state) => {\n      return {\n        ...state,\n        active: ids,\n      };\n    });\n  }\n\n  private handleUICreation(add = false) {\n    const ids = this.ids;\n    const isFunc = isFunction(this.ui._akitaCreateEntityFn);\n    let uiEntities;\n    const createFn = (id) => {\n      const current = this.entities[id];\n      const ui = isFunc ? this.ui._akitaCreateEntityFn(current) : this.ui._akitaCreateEntityFn;\n      return {\n        [this.idKey]: current[this.idKey],\n        ...ui,\n      };\n    };\n\n    if (add) {\n      uiEntities = this.ids.filter((id) => isUndefined(this.ui.entities[id])).map(createFn);\n    } else {\n      uiEntities = ids.map(createFn);\n    }\n\n    add ? this.ui.add(uiEntities) : this.ui.set(uiEntities);\n  }\n\n  private hasInitialUIState() {\n    return this.hasUIStore() && isUndefined(this.ui._akitaCreateEntityFn) === false;\n  }\n\n  private handleUIRemove(ids: IDType[]) {\n    if (this.hasUIStore()) {\n      this.ui.remove(ids);\n    }\n  }\n\n  private hasUIStore() {\n    return this.ui instanceof EntityUIStore;\n  }\n}\n\n// @internal\nexport class EntityUIStore<UIState, DEPRECATED = any> extends EntityStore<UIState> {\n  _akitaCreateEntityFn: EntityUICreateFn;\n\n  constructor(initialState = {}, storeConfig: Partial<StoreConfigOptions> = {}) {\n    super(initialState, storeConfig);\n  }\n\n  /**\n   *\n   * Set the initial UI entity state. This function will determine the entity's\n   * initial state when we call `set()` or `add()`.\n   *\n   * @example\n   *\n   * constructor() {\n   *   super();\n   *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));\n   *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });\n   * }\n   *\n   */\n  setInitialEntityState<EntityUI = any, Entity = any>(createFn: EntityUICreateFn<EntityUI, Entity>) {\n    this._akitaCreateEntityFn = createFn;\n  }\n}\n","import { Observable, of, OperatorFunction } from 'rxjs';\nimport { filter } from 'rxjs/operators';\n\n/**\n * @example\n *\n * query.selectEntity(2).pipe(filterNil)\n * @deprecated Use the operator function filterNilValue()\n */\nexport const filterNil = <T>(source: Observable<T | undefined | null>): Observable<NonNullable<T>> =>\n  source.pipe(filter((value): value is NonNullable<T> => value !== null && typeof value !== 'undefined'));\n\n/**\n * @example\n *\n * query.selectEntity(2).pipe(filterNilValue())\n */\nexport function filterNilValue<T>(): OperatorFunction<T, NonNullable<T>> {\n  return filter((value: T): value is NonNullable<T> => value !== null && value !== undefined);\n}\n","// @internal\nexport function isString(value: any): value is string {\n  return typeof value === 'string';\n}\n","import { Store } from './store';\nimport { Observable } from 'rxjs';\nimport { queryConfigKey, QueryConfigOptions } from './queryConfig';\nimport { isString } from './isString';\nimport { isFunction } from './isFunction';\nimport { isDev } from './env';\nimport { __queries__ } from './stores';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { compareKeys } from './compareKeys';\nimport { ReturnTypes } from './types';\n\nexport class Query<S> {\n  // @internal\n  __store__: Store<S>;\n\n  constructor(protected store: Store<S>) {\n    this.__store__ = store;\n    if (isDev()) {\n      // @internal\n      __queries__[store.storeName] = this;\n    }\n  }\n\n  /**\n   * Select a slice from the store\n   *\n   * @example\n   *\n   * this.query.select()\n   * this.query.select(state => state.entities)\n   * this.query.select('token');\n   * this.query.select(['name', 'email'])\n   * this.query.select([state => state.name, state => state.age])\n   *\n   */\n  select<K extends keyof S>(key: K): Observable<S[K]>;\n  select<R>(project: (store: S) => R): Observable<R>;\n  select<K extends keyof S>(stateKeys: K[]): Observable<Pick<S, K>>;\n  select<R extends [(state: S) => any] | Array<(state: S) => any>>(selectorFns: R): Observable<ReturnTypes<R>>;\n  select(): Observable<S>;\n  select<R>(project?: ((store: S) => R) | keyof S | (keyof S)[] | ((state: S) => any)[]): Observable<R | S | any[]> {\n    let mapFn;\n    if (isFunction(project)) {\n      mapFn = project;\n    } else if (isString(project)) {\n      mapFn = state => state[project];\n    } else if (Array.isArray(project)) {\n      return this.store\n        ._select(state => state)\n        .pipe(\n          distinctUntilChanged(compareKeys(project)),\n          map(state => {\n            if (isFunction(project[0])) {\n              return (project as ((state: S) => any)[]).map(func => func(state));\n            }\n\n            return (project as (keyof S)[]).reduce((acc, k) => {\n              acc[k as any] = state[k];\n              return acc;\n            }, {});\n          })\n        ) as any;\n    } else {\n      mapFn = state => state;\n    }\n\n    return this.store._select(mapFn);\n  }\n\n  /**\n   * Select the loading state\n   *\n   * @example\n   *\n   * this.query.selectLoading().subscribe(isLoading => {})\n   */\n  selectLoading() {\n    return this.select(state => (state as S & { loading: boolean }).loading);\n  }\n\n  /**\n   * Select the error state\n   *\n   * @example\n   *\n   * this.query.selectError().subscribe(error => {})\n   */\n  selectError<ErrorType = any>(): Observable<ErrorType> {\n    return this.select(state => (state as S & { error: ErrorType }).error);\n  }\n\n  /**\n   * Get the store's value\n   *\n   * @example\n   *\n   * this.query.getValue()\n   *\n   */\n  getValue(): S {\n    return this.store._value();\n  }\n\n  /**\n   * Select the cache state\n   *\n   * @example\n   *\n   * this.query.selectHasCache().pipe(\n   *   switchMap(hasCache => {\n   *     return hasCache ? of() : http().pipe(res => store.set(res))\n   *   })\n   * )\n   */\n  selectHasCache(): Observable<boolean> {\n    return this.store._cache().asObservable();\n  }\n\n  /**\n   * Whether we've cached data\n   *\n   * @example\n   *\n   * this.query.getHasCache()\n   *\n   */\n  getHasCache(): boolean {\n    return this.store._cache().value;\n  }\n\n  // @internal\n  get config(): QueryConfigOptions {\n    return this.constructor[queryConfigKey];\n  }\n}\n","import { isFunction } from './isFunction';\n\nexport function compareKeys<T>(keysOrFuncs: any[]) {\n  return function <T>(prevState, currState) {\n    const isFns = isFunction(keysOrFuncs[0]);\n    // Return when they are NOT changed\n    return keysOrFuncs.some(keyOrFunc => {\n      if(isFns) {\n        return keyOrFunc(prevState) !== keyOrFunc(currState);\n      }\n      return prevState[keyOrFunc] !== currState[keyOrFunc];\n    }) === false;\n  };\n}\n","import { isUndefined } from './isUndefined';\nimport { isString } from './isString';\nimport { ItemPredicate } from './types';\n\n// @internal\nexport function findEntityByPredicate<E>(predicate: ItemPredicate<E>, entities) {\n    for(const entityId of Object.keys(entities)) {\n      if(predicate(entities[entityId]) === true) {\n        return entityId;\n      }\n    }\n\n    return undefined;\n}\n\n// @internal\nexport function getEntity( id, project ) {\n  return function(entities) {\n    const entity = entities[id];\n\n    if(isUndefined(entity)) {\n      return undefined;\n    }\n\n    if(!project) {\n      return entity;\n    }\n\n    if(isString(project)) {\n      return entity[project];\n    }\n\n    return (project as Function)(entity);\n  };\n\n}\n","// @internal\nexport function sortByOptions(options, config) {\n  options.sortBy = options.sortBy || (config && config.sortBy);\n  options.sortByOrder = options.sortByOrder || (config && config.sortByOrder);\n}\n","import { Observable, of } from 'rxjs';\nimport { distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';\nimport { distinctUntilArrayItemChanged } from './arrayFind';\nimport { coerceArray } from './coerceArray';\nimport { entitiesToArray } from './entitiesToArray';\nimport { entitiesToMap } from './entitiesToMap';\nimport { EntityAction, EntityActions } from './entityActions';\nimport { EntityStore } from './entityStore';\nimport { findEntityByPredicate, getEntity } from './getEntity';\nimport { isArray } from './isArray';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { mapSkipUndefined } from './mapSkipUndefined';\nimport { Query } from './query';\nimport { QueryConfigOptions } from './queryConfig';\nimport { SelectAllOptionsA, SelectAllOptionsB, SelectAllOptionsC, SelectAllOptionsD, SelectAllOptionsE } from './selectAllOverloads';\nimport { sortByOptions } from './sortByOptions';\nimport { toBoolean } from './toBoolean';\nimport { EntityState, getEntityType, getIDType, HashMap, ItemPredicate, OrArray, SelectOptions } from './types';\n\n/**\n *\n *  The Entity Query is similar to the general Query, with additional functionality tailored for EntityStores.\n *\n *  class WidgetsQuery extends QueryEntity<WidgetsState> {\n *     constructor(protected store: WidgetsStore) {\n *       super(store);\n *     }\n *  }\n *\n *\n *\n */\nexport class QueryEntity<S extends EntityState, EntityType = getEntityType<S>, IDType = getIDType<S>> extends Query<S> {\n  ui: EntityUIQuery<any, EntityType>;\n  protected store: EntityStore<S>;\n\n  // @internal\n  __store__;\n\n  constructor(store: EntityStore<S>, private options: QueryConfigOptions = {}) {\n    super(store);\n    this.__store__ = store;\n  }\n\n  /**\n   * Select the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.selectAll()\n   *\n   * this.query.selectAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.selectAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.selectAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   *\n   */\n  selectAll(options: SelectAllOptionsA<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsB<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsC<EntityType>): Observable<HashMap<EntityType>>;\n  selectAll(options: SelectAllOptionsD<EntityType>): Observable<EntityType[]>;\n  selectAll(options: SelectAllOptionsE<EntityType>): Observable<EntityType[]>;\n  selectAll(): Observable<EntityType[]>;\n  selectAll(\n    options: SelectOptions<EntityType> = {\n      asObject: false,\n    }\n  ): Observable<EntityType[] | HashMap<EntityType>> {\n    return this.select((state) => state.entities).pipe(map(() => this.getAll(options)));\n  }\n\n  /**\n   * Get the entire store's entity collection\n   *\n   * @example\n   *\n   * this.query.getAll()\n   *\n   * this.query.getAll({\n   *   limitTo: 5\n   *   filterBy: entity => entity.completed === true\n   * })\n   *\n   * this.query.getAll({\n   *   asObject: true,\n   *   limitTo: 3\n   * })\n   *\n   *  this.query.getAll({\n   *   sortBy: 'price',\n   *   sortByOrder: Order.DESC\n   * })\n   */\n  getAll(options: SelectAllOptionsA<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsB<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsC<EntityType>): HashMap<EntityType>;\n  getAll(options: SelectAllOptionsD<EntityType>): EntityType[];\n  getAll(options: SelectAllOptionsE<EntityType>): EntityType[];\n  getAll(): EntityType[];\n  getAll(options: SelectOptions<EntityType> = { asObject: false, filterBy: undefined, limitTo: undefined }): EntityType[] | HashMap<EntityType> {\n    if (options.asObject) {\n      return entitiesToMap(this.getValue(), options);\n    }\n    sortByOptions(options, this.config || this.options);\n\n    return entitiesToArray(this.getValue(), options);\n  }\n\n  /**\n   * Select multiple entities from the store\n   *\n   * @example\n   *\n   * this.query.selectMany([1,2,3])\n   * this.query.selectMany([1,2], entity => entity.title)\n   */\n  selectMany<R>(ids: IDType[]): Observable<EntityType[]>;\n  selectMany<R>(ids: IDType[], project: (entity: EntityType) => R): Observable<R[]>;\n  selectMany<R>(ids: IDType[], project?: (entity: EntityType) => R): Observable<EntityType[] | R[]> {\n    if (!ids || !ids.length) return of([]);\n\n    return this.select((state) => state.entities).pipe(\n      map((entities) => mapSkipUndefined(ids, (id) => getEntity(id, project)(entities))),\n      distinctUntilArrayItemChanged()\n    );\n  }\n\n  /**\n   * Select an entity or a slice of an entity\n   *\n   * @example\n   *\n   * this.query.selectEntity(1)\n   * this.query.selectEntity(1, entity => entity.config.date)\n   * this.query.selectEntity(1, 'comments')\n   * this.query.selectEntity(e => e.title === 'title')\n   *\n   */\n  selectEntity<R>(id: IDType): Observable<EntityType | undefined>;\n  selectEntity<K extends keyof EntityType>(id: IDType, project?: K): Observable<EntityType[K] | undefined>;\n  selectEntity<R>(id: IDType, project: (entity?: EntityType) => R): Observable<R>;\n  selectEntity<R>(predicate: ItemPredicate<EntityType>): Observable<EntityType | undefined>;\n  selectEntity<R>(idOrPredicate: IDType | ItemPredicate<EntityType>, project?: ((entity: EntityType) => R) | keyof EntityType): Observable<R | EntityType | undefined> {\n    let id = idOrPredicate;\n\n    if (isFunction(idOrPredicate)) {\n      // For performance reason we expect the entity to be in the store\n      (id as any) = findEntityByPredicate(idOrPredicate, this.getValue().entities);\n    }\n\n    return this.select((state) => state.entities).pipe(map(getEntity(id, project)), distinctUntilChanged());\n  }\n\n  /**\n   * Get an entity by id\n   *\n   * @example\n   *\n   * this.query.getEntity(1);\n   */\n  getEntity(id: IDType): EntityType | undefined {\n    return this.getValue().entities[id as any];\n  }\n\n  /**\n   * Select the active entity's id\n   *\n   * @example\n   *\n   * this.query.selectActiveId()\n   */\n  selectActiveId(): Observable<S['active'] | undefined> {\n    return this.select((state) => (state as S & { active: S['active'] }).active);\n  }\n\n  /**\n   * Get the active id\n   *\n   * @example\n   *\n   * this.query.getActiveId()\n   */\n  getActiveId(): S['active'] | undefined {\n    return this.getValue().active;\n  }\n\n  /**\n   * Select the active entity\n   *\n   * @example\n   *\n   * this.query.selectActive()\n   * this.query.selectActive(entity => entity.title)\n   */\n  selectActive<R>(): S['active'] extends any[] ? Observable<EntityType[]> : Observable<EntityType | undefined>;\n  selectActive<R>(project?: (entity: EntityType) => R): S['active'] extends any[] ? Observable<R[]> : Observable<R | undefined>;\n  selectActive<R>(project?: (entity: EntityType) => R): Observable<R | EntityType> | Observable<EntityType[] | R[] | undefined> {\n    if (isArray(this.getActive())) {\n      return this.selectActiveId().pipe(switchMap((ids) => this.selectMany(ids, project)));\n    }\n    return this.selectActiveId().pipe(switchMap((ids) => this.selectEntity(ids, project)));\n  }\n\n  /**\n   * Get the active entity\n   *\n   * @example\n   *\n   * this.query.getActive()\n   */\n  getActive(): S['active'] extends any[] ? EntityType[] : EntityType | undefined;\n  getActive(): OrArray<EntityType> | undefined {\n    const activeId = this.getActiveId();\n    if (isArray(activeId)) {\n      return activeId.map((id) => this.getValue().entities[id as any]);\n    }\n    return toBoolean(activeId) ? this.getEntity(activeId) : undefined;\n  }\n\n  /**\n   * Select the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.selectCount()\n   * this.query.selectCount(entity => entity.completed)\n   */\n  selectCount(predicate?: (entity: EntityType, index: number) => boolean): Observable<number> {\n    return this.select((state) => state.entities).pipe(map(() => this.getCount(predicate)));\n  }\n\n  /**\n   * Get the store's entity collection length\n   *\n   * @example\n   *\n   * this.query.getCount()\n   * this.query.getCount(entity => entity.completed)\n   */\n  getCount(predicate?: (entity: EntityType, index: number) => boolean): number {\n    if (isFunction(predicate)) {\n      return this.getAll().filter(predicate).length;\n    }\n    return this.getValue().ids.length;\n  }\n\n  /**\n   *\n   * Select the last entity from the store\n   *\n   * @example\n   *\n   * this.query.selectLast()\n   * this.query.selectLast(todo => todo.title)\n   */\n  selectLast<R>(): Observable<EntityType | undefined>;\n  selectLast<R>(project: (entity?: EntityType) => R): Observable<R>;\n  selectLast<R>(project?: (entity?: EntityType) => R): Observable<R | EntityType | undefined> {\n    return this.selectAt((ids) => ids[ids.length - 1], project);\n  }\n\n  /**\n   *\n   * Select the first entity from the store\n   *\n   * @example\n   *\n   * this.query.selectFirst()\n   * this.query.selectFirst(todo => todo.title)\n   */\n  selectFirst<R>(): Observable<EntityType | undefined>;\n  selectFirst<R>(project: (entity?: EntityType) => R): Observable<R>;\n  selectFirst<R>(project?: (entity?: EntityType) => R): Observable<R | EntityType | undefined> {\n    return this.selectAt((ids) => ids[0], project);\n  }\n\n  /**\n   *\n   * Listen for entity actions\n   *\n   *  @example\n   *  this.query.selectEntityAction(EntityActions.Add);\n   *  this.query.selectEntityAction(EntityActions.Update);\n   *  this.query.selectEntityAction(EntityActions.Remove);\n   *\n   *  this.query.selectEntityAction([EntityActions.Add, EntityActions.Update, EntityActions.Remove])\n   *\n   *  this.query.selectEntityAction();\n   */\n  selectEntityAction(action: EntityActions): Observable<IDType[]>;\n  selectEntityAction(actions: EntityActions[]): Observable<EntityAction<IDType>>;\n  selectEntityAction(): Observable<EntityAction<IDType>>;\n  selectEntityAction(actionOrActions?: EntityActions | EntityActions[]): Observable<IDType[] | EntityAction<IDType>> {\n    if (isNil(actionOrActions)) {\n      return this.store.selectEntityAction$;\n    }\n\n    const project = isArray(actionOrActions) ? (action: EntityAction<IDType>) => action : ({ ids }: EntityAction<IDType>) => ids;\n    const actions = coerceArray(actionOrActions);\n\n    return this.store.selectEntityAction$.pipe(\n      filter(({ type }: EntityAction<IDType>) => actions.includes(type)),\n      map((action) => project(action))\n    );\n  }\n\n  /**\n   * Returns whether entity exists\n   *\n   * @example\n   *\n   * this.query.hasEntity(2)\n   * this.query.hasEntity(entity => entity.completed)\n   * this.query.hasEntity([1, 2, 33])\n   *\n   */\n  hasEntity(id: IDType): boolean;\n  hasEntity(id: IDType[]): boolean;\n  hasEntity(project: (entity: EntityType) => boolean): boolean;\n  hasEntity(): boolean;\n  hasEntity(projectOrIds?: IDType | IDType[] | ((entity: EntityType) => boolean)): boolean {\n    if (isNil(projectOrIds)) {\n      return this.getValue().ids.length > 0;\n    }\n\n    if (isFunction(projectOrIds)) {\n      return this.getAll().some(projectOrIds);\n    }\n\n    if (isArray(projectOrIds)) {\n      return projectOrIds.every((id) => (id as any) in this.getValue().entities);\n    }\n\n    return (projectOrIds as any) in this.getValue().entities;\n  }\n\n  /**\n   * Returns whether entity store has an active entity\n   *\n   * @example\n   *\n   * this.query.hasActive()\n   * this.query.hasActive(3)\n   *\n   */\n  hasActive(id?: IDType): boolean {\n    const active = this.getValue().active;\n    const isIdProvided = isDefined(id);\n    if (Array.isArray(active)) {\n      if (isIdProvided) {\n        return active.includes(id);\n      }\n      return active.length > 0;\n    }\n    return isIdProvided ? active === id : isDefined(active);\n  }\n\n  /**\n   *\n   * Create sub UI query for querying Entity's UI state\n   *\n   * @example\n   *\n   *\n   * export class ProductsQuery extends QueryEntity<ProductsState> {\n   *   ui: EntityUIQuery<ProductsUIState>;\n   *\n   *   constructor(protected store: ProductsStore) {\n   *     super(store);\n   *     this.createUIQuery();\n   *   }\n   *\n   * }\n   */\n  createUIQuery() {\n    this.ui = new EntityUIQuery(this.__store__.ui);\n  }\n\n  private selectAt<R>(mapFn: (ids: IDType[]) => IDType, project?: (entity?: EntityType) => R) {\n    return this.select((state) => state.ids as any[]).pipe(\n      map(mapFn),\n      distinctUntilChanged(),\n      switchMap((id: IDType) => this.selectEntity(id, project))\n    );\n  }\n}\n\n// @internal\nexport class EntityUIQuery<UIState, DEPRECATED = any> extends QueryEntity<UIState> {\n  constructor(store) {\n    super(store);\n  }\n}\n","// @internal\nexport function mapSkipUndefined<T, V>(arr: T[], callbackFn: (value: T, index: number, array: T[]) => V) {\n  return arr.reduce((result, value, index, array) => {\n    const val = callbackFn(value, index, array);\n    if (val !== undefined) {\n      result.push(val);\n    }\n    return result;\n  }, []);\n}\n","/**\n * @internal\n *\n * @example\n *\n * getValue(state, 'todos.ui')\n *\n */\nexport function getValue( obj: any, prop: string ) {\n  /** return the whole state  */\n  if( prop.split('.').length === 1 ) {\n    return obj;\n  }\n  const removeStoreName = prop\n    .split('.')\n    .slice(1)\n    .join('.');\n  return removeStoreName.split('.').reduce(( acc: any, part: string ) => acc && acc[part], obj);\n}\n","import { isObject } from './isObject';\n\n/**\n * @internal\n *\n * @example\n * setValue(state, 'todos.ui', { filter: {} })\n */\nexport function setValue(obj: any, prop: string, val: any, replace = false) {\n  const split = prop.split('.');\n\n  if (split.length === 1) {\n    return { ...obj, ...val };\n  }\n\n  obj = { ...obj };\n\n  const lastIndex = split.length - 2;\n  const removeStoreName = prop.split('.').slice(1);\n\n  removeStoreName.reduce((acc, part, index) => {\n    if (index !== lastIndex) {\n      acc[part] = { ...acc[part] };\n      return acc && acc[part];\n    }\n\n    acc[part] = replace || Array.isArray(acc[part]) || !isObject(acc[part]) ? val : { ...acc[part], ...val };\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n}\n","import { from, isObservable, of, OperatorFunction, ReplaySubject, Subscription } from 'rxjs';\nimport { filter, map, skip } from 'rxjs/operators';\nimport { setAction } from './actions';\nimport { $$addStore, $$deleteStore } from './dispatchers';\nimport { getValue } from './getValueByString';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { hasLocalStorage, hasSessionStorage, isNotBrowser } from './root';\nimport { setValue } from './setValueByString';\nimport { __stores__ } from './stores';\nimport { HashMap, MaybeAsync } from './types';\n\nlet skipStorageUpdate = false;\n\nconst _persistStateInit = new ReplaySubject(1);\n\nexport function selectPersistStateInit() {\n  return _persistStateInit.asObservable();\n}\n\nexport function setSkipStorageUpdate(skip: boolean) {\n  skipStorageUpdate = skip;\n}\n\nexport function getSkipStorageUpdate() {\n  return skipStorageUpdate;\n}\n\nexport interface PersistStateStorage {\n  getItem(key: string): MaybeAsync;\n\n  setItem(key: string, value: any): MaybeAsync;\n\n  clear(): void;\n}\n\nfunction isPromise(v: any) {\n  return v && isFunction(v.then);\n}\n\nfunction observify(asyncOrValue: any) {\n  if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {\n    return from(asyncOrValue);\n  }\n\n  return of(asyncOrValue);\n}\n\nexport type PersistStateSelectFn<T = any> = ((store: T) => Partial<T>) & { storeName: string };\n\nexport interface PersistStateParams {\n  /** The storage key */\n  key: string;\n  /** Whether to enable persistState in a non-browser environment */\n  enableInNonBrowser: boolean;\n  /** Storage strategy to use. This defaults to LocalStorage but you can pass SessionStorage or anything that implements the StorageEngine API. */\n  storage: PersistStateStorage;\n  /** Custom deserializer. Defaults to JSON.parse */\n  deserialize: Function;\n  /** Custom serializer, defaults to JSON.stringify */\n  serialize: Function;\n  /** By default the whole state is saved to storage, use this param to include only the stores you need. */\n  include: (string | ((storeName: string) => boolean))[];\n  /** By default the whole state is saved to storage, use this param to include only the data you need. */\n  select: PersistStateSelectFn[];\n\n  preStorageUpdate(storeName: string, state: any): any;\n\n  preStoreUpdate(storeName: string, state: any, initialState: any): any;\n\n  skipStorageUpdate: () => boolean;\n  preStorageUpdateOperator: () => OperatorFunction<any, any>;\n  /** Whether to persist a dynamic store upon destroy */\n  persistOnDestroy: boolean;\n}\n\nexport interface PersistState {\n  destroy(): void;\n  /**\n   * @deprecated Use clearStore instead.\n   */\n  clear(): void;\n  clearStore(storeName?: string): void;\n}\n\nexport function persistState(params?: Partial<PersistStateParams>): PersistState {\n  const defaults: PersistStateParams = {\n    key: 'AkitaStores',\n    enableInNonBrowser: false,\n    storage: !hasLocalStorage() ? params.storage : localStorage,\n    deserialize: JSON.parse,\n    serialize: JSON.stringify,\n    include: [],\n    select: [],\n    persistOnDestroy: false,\n    preStorageUpdate: function (storeName, state) {\n      return state;\n    },\n    preStoreUpdate: function (storeName, state) {\n      return state;\n    },\n    skipStorageUpdate: getSkipStorageUpdate,\n    preStorageUpdateOperator: () => (source) => source,\n  };\n\n  const { storage, enableInNonBrowser, deserialize, serialize, include, select, key, preStorageUpdate, persistOnDestroy, preStorageUpdateOperator, preStoreUpdate, skipStorageUpdate } = Object.assign(\n    {},\n    defaults,\n    params\n  );\n\n  if ((isNotBrowser && !enableInNonBrowser) || !storage) return;\n\n  const hasInclude = include.length > 0;\n  const hasSelect = select.length > 0;\n  let includeStores: { fns: Function[]; [key: string]: Function[] | string };\n  let selectStores: { [key: string]: PersistStateSelectFn };\n\n  if (hasInclude) {\n    includeStores = include.reduce(\n      (acc, path) => {\n        if (isFunction(path)) {\n          acc.fns.push(path);\n        } else {\n          const storeName = path.split('.')[0];\n          acc[storeName] = path;\n        }\n        return acc;\n      },\n      { fns: [] }\n    );\n  }\n\n  if (hasSelect) {\n    selectStores = select.reduce((acc, selectFn) => {\n      acc[selectFn.storeName] = selectFn;\n\n      return acc;\n    }, {});\n  }\n\n  let stores: HashMap<Subscription> = {};\n  let acc = {};\n  let subscriptions: Subscription[] = [];\n\n  const buffer = [];\n\n  function _save(v: any) {\n    observify(v).subscribe(() => {\n      const next = buffer.shift();\n      next && _save(next);\n    });\n  }\n\n  // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it\n  const isLocalStorage = (hasLocalStorage() && storage === localStorage) || (hasSessionStorage() && storage === sessionStorage);\n\n  observify(storage.getItem(key)).subscribe((value: any) => {\n    let storageState = isObject(value) ? value : deserialize(value || '{}');\n\n    function save(storeCache) {\n      storageState['$cache'] = { ...(storageState['$cache'] || {}), ...storeCache };\n      storageState = Object.assign({}, storageState, acc);\n\n      buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));\n      _save(buffer.shift());\n    }\n\n    function subscribe(storeName, path) {\n      stores[storeName] = __stores__[storeName]\n        ._select((state) => getValue(state, path))\n        .pipe(\n          skip(1),\n          map((store) => {\n            if (hasSelect && selectStores[storeName]) {\n              return selectStores[storeName](store);\n            }\n\n            return store;\n          }),\n          filter(() => skipStorageUpdate() === false),\n          preStorageUpdateOperator()\n        )\n        .subscribe((data) => {\n          acc[storeName] = preStorageUpdate(storeName, data);\n          Promise.resolve().then(() => save({ [storeName]: __stores__[storeName]._cache().getValue() }));\n        });\n    }\n\n    function setInitial(storeName, store, path) {\n      if (storeName in storageState) {\n        setAction('@PersistState');\n        store._setState((state) => {\n          return setValue(state, path, preStoreUpdate(storeName, storageState[storeName], state));\n        });\n        const hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;\n        __stores__[storeName].setHasCache(hasCache, { restartTTL: true });\n      }\n    }\n\n    subscriptions.push(\n      $$deleteStore.subscribe((storeName) => {\n        if (stores[storeName]) {\n          if (persistOnDestroy === false) {\n            save({ [storeName]: false });\n          }\n          stores[storeName].unsubscribe();\n          delete stores[storeName];\n        }\n      })\n    );\n\n    subscriptions.push(\n      $$addStore.subscribe((storeName) => {\n        if (storeName === 'router') {\n          return;\n        }\n\n        const store = __stores__[storeName];\n        if (hasInclude) {\n          let path = includeStores[storeName];\n\n          if (!path) {\n            const passPredicate = includeStores.fns.some((fn) => fn(storeName));\n            if (passPredicate) {\n              path = storeName;\n            } else {\n              return;\n            }\n          }\n          setInitial(storeName, store, path);\n          subscribe(storeName, path);\n        } else {\n          setInitial(storeName, store, storeName);\n          subscribe(storeName, storeName);\n        }\n      })\n    );\n\n    _persistStateInit.next();\n  });\n\n  return {\n    destroy() {\n      subscriptions.forEach((s) => s.unsubscribe());\n      for (let i = 0, keys = Object.keys(stores); i < keys.length; i++) {\n        const storeName = keys[i];\n        stores[storeName].unsubscribe();\n      }\n      stores = {};\n    },\n    clear() {\n      storage.clear();\n    },\n    clearStore(storeName?: string) {\n      if (isNil(storeName)) {\n        const value = observify(storage.setItem(key, '{}'));\n        value.subscribe();\n        return;\n      }\n      const value = storage.getItem(key);\n      observify(value).subscribe((v) => {\n        const storageState = deserialize(v || '{}');\n\n        if (storageState[storeName]) {\n          delete storageState[storeName];\n          const value = observify(storage.setItem(key, serialize(storageState)));\n          value.subscribe();\n        }\n      });\n    },\n  };\n}\n","import { EntityStore } from '../entityStore';\nimport { QueryEntity } from '../queryEntity';\nimport { Query } from '../query';\nimport { filterNilValue } from '../filterNil';\nimport { toBoolean } from '../toBoolean';\nimport { getAkitaConfig } from '../config';\nimport { getValue } from '../getValueByString';\nimport { setValue } from '../setValueByString';\n\nexport type Queries<State> = Query<State> | QueryEntity<State>;\n\nexport abstract class AkitaPlugin<State = any> {\n  protected constructor(protected query: Queries<State>, config?: { resetFn?: Function }) {\n    if (config && config.resetFn) {\n      if (getAkitaConfig().resettable) {\n        this.onReset(config.resetFn);\n      }\n    }\n  }\n\n  /** This method is responsible for getting access to the query. */\n  protected getQuery() {\n    return this.query;\n  }\n\n  /** This method is responsible for getting access to the store. */\n  protected getStore() {\n    return this.getQuery().__store__;\n  }\n\n  /** This method is responsible for cleaning. */\n  public abstract destroy();\n\n  /** This method is responsible tells whether the plugin is entityBased or not.  */\n  protected isEntityBased(entityId: any) {\n    return toBoolean(entityId);\n  }\n\n  /** This method is responsible for selecting the source; it can be the whole store or one entity. */\n  protected selectSource(entityId: any, property?: string) {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).selectEntity(entityId).pipe(filterNilValue());\n    }\n\n    if (property) {\n      return this.getQuery().select((state) => getValue(state, this.withStoreName(property)));\n    }\n\n    return this.getQuery().select();\n  }\n\n  protected getSource(entityId: any, property?: string): any {\n    if (this.isEntityBased(entityId)) {\n      return (this.getQuery() as QueryEntity<State>).getEntity(entityId);\n    }\n\n    const state = this.getQuery().getValue();\n\n    if (property) {\n      return getValue(state, this.withStoreName(property));\n    }\n\n    return state;\n  }\n\n  protected withStoreName(prop: string) {\n    return `${this.storeName}.${prop}`;\n  }\n\n  protected get storeName() {\n    return this.getStore().storeName;\n  }\n\n  /** This method is responsible for updating the store or one entity; it can be the whole store or one entity. */\n  protected updateStore(newState, entityId?, property?: string, replace = false) {\n    if (this.isEntityBased(entityId)) {\n      const store = this.getStore() as EntityStore;\n\n      replace ? store.replace(entityId, newState) : store.update(entityId, newState);\n    } else {\n      if (property) {\n        this.getStore()._setState((state) => {\n          return setValue(state, this.withStoreName(property), newState, true);\n        });\n\n        return;\n      }\n\n      const nextState = replace ? newState : (state) => ({ ...state, ...newState });\n\n      this.getStore()._setState(nextState);\n    }\n  }\n\n  /**\n   * Function to invoke upon reset\n   */\n  private onReset(fn: Function) {\n    const original = this.getStore().reset;\n    this.getStore().reset = (...params) => {\n      /** It should run after the plugin destroy method */\n      setTimeout(() => {\n        original.apply(this.getStore(), params);\n        fn();\n      });\n    };\n  }\n}\n","import { AkitaPlugin, Queries } from '../plugin';\nimport { QueryEntity } from '../../queryEntity';\nimport { BehaviorSubject, combineLatest, Observable, Subject, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map, skip } from 'rxjs/operators';\nimport { isUndefined } from '../../isUndefined';\nimport { Query } from '../../query';\nimport { coerceArray } from '../../coerceArray';\nimport { isFunction } from '../../isFunction';\nimport { logAction } from '../../actions';\n\ntype Head<State = any> = State | Partial<State>;\n\nexport type DirtyCheckComparator<State> = (head: State, current: State) => boolean;\n\nexport type DirtyCheckParams<StoreState = any> = {\n  comparator?: DirtyCheckComparator<StoreState>;\n  watchProperty?: keyof StoreState | (keyof StoreState)[];\n};\n\nexport const dirtyCheckDefaultParams = {\n  comparator: (head, current) => JSON.stringify(head) !== JSON.stringify(current),\n};\n\nexport function getNestedPath(nestedObj, path: string) {\n  const pathAsArray: string[] = path.split('.');\n  return pathAsArray.reduce((obj, key) => (obj && obj[key] !== 'undefined' ? obj[key] : undefined), nestedObj);\n}\n\nexport type DirtyCheckResetParams<StoreState = any> = {\n  updateFn?: StoreState | ((head: StoreState, current: StoreState) => any);\n};\n\nexport class DirtyCheckPlugin<State = any> extends AkitaPlugin<State> {\n  private head: Head<State>;\n  private dirty = new BehaviorSubject(false);\n  private subscription: Subscription;\n  private active = false;\n  private _reset = new Subject();\n\n  isDirty$: Observable<boolean> = this.dirty.asObservable().pipe(distinctUntilChanged());\n  reset$ = this._reset.asObservable();\n\n  constructor(protected query: Queries<State>, private params?: DirtyCheckParams<State>, private _entityId?: any) {\n    super(query);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    if (this.params.watchProperty) {\n      const watchProp = coerceArray(this.params.watchProperty) as any[];\n      if (query instanceof QueryEntity && watchProp.includes('entities') && !watchProp.includes('ids')) {\n        watchProp.push('ids');\n      }\n      this.params.watchProperty = watchProp;\n    }\n  }\n\n  reset(params: DirtyCheckResetParams = {}): void {\n    let currentValue = this.head;\n    if (isFunction(params.updateFn)) {\n      if (this.isEntityBased(this._entityId)) {\n        currentValue = params.updateFn(this.head, (this.getQuery() as QueryEntity<State>).getEntity(this._entityId));\n      } else {\n        currentValue = params.updateFn(this.head, (this.getQuery() as Query<State>).getValue());\n      }\n    }\n    logAction(`@DirtyCheck - Revert`);\n    this.updateStore(currentValue, this._entityId);\n    this._reset.next();\n  }\n\n  setHead(): DirtyCheckPlugin<State> {\n    if (!this.active) {\n      this.activate();\n      this.active = true;\n    } else {\n      this.head = this._getHead();\n    }\n    this.updateDirtiness(false);\n    return this;\n  }\n\n  isDirty(): boolean {\n    return !!this.dirty.value;\n  }\n\n  hasHead(): boolean {\n    return !!this.getHead();\n  }\n\n  destroy(): void {\n    this.head = null;\n    this.subscription && this.subscription.unsubscribe();\n    this._reset && this._reset.complete();\n  }\n\n  isPathDirty(path: string): boolean {\n    const head = this.getHead();\n    const current = (this.getQuery() as Query<State>).getValue();\n    const currentPathValue = getNestedPath(current, path);\n    const headPathValue = getNestedPath(head, path);\n\n    return this.params.comparator(currentPathValue, headPathValue);\n  }\n\n  getHead(): Partial<State> | State | undefined | null {\n    return this.head;\n  }\n\n  private activate() {\n    this.head = this._getHead();\n    /** if we are tracking specific properties select only the relevant ones */\n    const source = this.params.watchProperty\n      ? (this.params.watchProperty as (keyof State)[]).map((prop) =>\n          this.query\n            .select((state) => state[prop])\n            .pipe(\n              map((val) => ({\n                val,\n                __akitaKey: prop,\n              }))\n            )\n        )\n      : [this.selectSource(this._entityId)];\n    this.subscription = combineLatest(...source)\n      .pipe(skip(1))\n      .subscribe((currentState: any[]) => {\n        if (isUndefined(this.head)) return;\n        /** __akitaKey is used to determine if we are tracking a specific property or a store change */\n        const isChange = currentState.some((state) => {\n          const head = state.__akitaKey ? this.head[state.__akitaKey as any] : this.head;\n          const compareTo = state.__akitaKey ? state.val : state;\n\n          return this.params.comparator(head, compareTo);\n        });\n\n        this.updateDirtiness(isChange);\n      });\n  }\n\n  private updateDirtiness(isDirty: boolean) {\n    this.dirty.next(isDirty);\n  }\n\n  private _getHead(): Head<State> {\n    let head: Head<State> = this.getSource(this._entityId);\n    if (this.params.watchProperty) {\n      head = this.getWatchedValues(head as State);\n    }\n    return head;\n  }\n\n  private getWatchedValues(source: State): Partial<State> {\n    return (this.params.watchProperty as (keyof State)[]).reduce((watched, prop) => {\n      watched[prop] = source[prop];\n      return watched;\n    }, {} as Partial<State>);\n  }\n}\n","import { Observable } from 'rxjs';\nimport { EntityState, OrArray, getIDType } from '../types';\nimport { QueryEntity } from '../queryEntity';\nimport { isUndefined } from '../isUndefined';\nimport { coerceArray } from '../coerceArray';\nimport { toBoolean } from '../toBoolean';\nimport { isFunction } from '../isFunction';\n\nexport type RebaseAction<P = any> = (plugin: P) => any;\n\nexport type RebaseActions<P = any> = { beforeRemove?: RebaseAction; beforeAdd?: RebaseAction; afterAdd?: RebaseAction };\n\n/**\n * Each plugin that wants to add support for entities should extend this interface.\n */\nexport abstract class EntityCollectionPlugin<State extends EntityState, P> {\n  protected entities = new Map<getIDType<State>, P>();\n\n  protected constructor(protected query: QueryEntity<State>, private entityIds: OrArray<getIDType<State>>) {}\n\n  /**\n   * Get the entity plugin instance.\n   */\n  protected getEntity(id: getIDType<State>): P {\n    return this.entities.get(id);\n  }\n\n  /**\n   * Whether the entity plugin exist.\n   */\n  protected hasEntity(id: getIDType<State>): boolean {\n    return this.entities.has(id);\n  }\n\n  /**\n   * Remove the entity plugin instance.\n   */\n  protected removeEntity(id: getIDType<State>) {\n    this.destroy(id);\n    return this.entities.delete(id);\n  }\n\n  /**\n   * Set the entity plugin instance.\n   */\n  protected createEntity(id: getIDType<State>, plugin: P) {\n    return this.entities.set(id, plugin);\n  }\n\n  /**\n   * If the user passes `entityIds` we take them; otherwise, we take all.\n   */\n  protected getIds(): any {\n    return isUndefined(this.entityIds) ? this.query.getValue().ids : coerceArray(this.entityIds);\n  }\n\n  /**\n   * When you call one of the plugin methods, you can pass id/ids or undefined which means all.\n   */\n  protected resolvedIds(ids?): getIDType<State>[] {\n    return isUndefined(ids) ? this.getIds() : coerceArray(ids);\n  }\n\n  /**\n   * Call this method when you want to activate the plugin on init or when you need to listen to add/remove of entities dynamically.\n   *\n   * For example in your plugin you may do the following:\n   *\n   * this.query.select(state => state.ids).pipe(skip(1)).subscribe(ids => this.activate(ids));\n   */\n  protected rebase(ids: getIDType<State>[], actions: RebaseActions<P> = {}) {\n    /**\n     *\n     * If the user passes `entityIds` & we have new ids check if we need to add/remove instances.\n     *\n     * This phase will be called only upon update.\n     */\n    if (toBoolean(ids)) {\n      /**\n       * Which means all\n       */\n      if (isUndefined(this.entityIds)) {\n        for (let i = 0, len = ids.length; i < len; i++) {\n          const entityId = ids[i];\n          if (this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          }\n        }\n\n        this.entities.forEach((plugin, entityId) => {\n          if (ids.indexOf(entityId) === -1) {\n            isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n            this.removeEntity(entityId);\n          }\n        });\n      } else {\n        /**\n         * Which means the user passes specific ids\n         */\n        const _ids = coerceArray(this.entityIds);\n        for (let i = 0, len = _ids.length; i < len; i++) {\n          const entityId = _ids[i];\n          /** The Entity in current ids and doesn't exist, add it. */\n          if (ids.indexOf(entityId) > -1 && this.hasEntity(entityId) === false) {\n            isFunction(actions.beforeAdd) && actions.beforeAdd(entityId);\n            const plugin = this.instantiatePlugin(entityId);\n            this.entities.set(entityId, plugin);\n            isFunction(actions.afterAdd) && actions.afterAdd(plugin);\n          } else {\n            this.entities.forEach((plugin, entityId) => {\n              /** The Entity not in current ids and exists, remove it. */\n              if (ids.indexOf(entityId) === -1 && this.hasEntity(entityId) === true) {\n                isFunction(actions.beforeRemove) && actions.beforeRemove(plugin);\n                this.removeEntity(entityId);\n              }\n            });\n          }\n        }\n      }\n    } else {\n      /**\n       * Otherwise, start with the provided ids or all.\n       */\n      this.getIds().forEach(id => {\n        if (!this.hasEntity(id)) this.createEntity(id, this.instantiatePlugin(id));\n      });\n    }\n  }\n\n  /**\n   * Listen for add/remove entities.\n   */\n  protected selectIds(): Observable<any> {\n    return this.query.select(state => state.ids);\n  }\n\n  /**\n   * Base method for activation, you can override it if you need to.\n   */\n  protected activate(ids?: any[]) {\n    this.rebase(ids);\n  }\n\n  /**\n   * This method is responsible for plugin instantiation.\n   *\n   * For example:\n   * return new StateHistory(this.query, this.params, id) as P;\n   */\n  protected abstract instantiatePlugin(id: getIDType<State>): P;\n\n  /**\n   * This method is responsible for cleaning.\n   */\n  public abstract destroy(id?: getIDType<State>);\n\n  /**\n   * Loop over each id and invoke the plugin method.\n   */\n  protected forEachId(ids: OrArray<getIDType<State>>, cb: (entity: P) => any) {\n    const _ids = this.resolvedIds(ids);\n\n    for (let i = 0, len = _ids.length; i < len; i++) {\n      const id = _ids[i];\n      if (this.hasEntity(id)) {\n        cb(this.getEntity(id));\n      }\n    }\n  }\n}\n","import { DirtyCheckComparator, dirtyCheckDefaultParams, DirtyCheckPlugin, DirtyCheckResetParams, getNestedPath } from './dirtyCheckPlugin';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\nimport { auditTime, map, skip } from 'rxjs/operators';\nimport { merge, Observable, Subject } from 'rxjs';\nimport { EntityState, OrArray, getIDType, getEntityType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { coerceArray } from '../../coerceArray';\n\nexport type DirtyCheckCollectionParams<State extends EntityState> = {\n  comparator?: DirtyCheckComparator<getEntityType<State>>;\n  entityIds?: OrArray<getIDType<State>>;\n};\n\nexport class EntityDirtyCheckPlugin<State extends EntityState = any, P extends DirtyCheckPlugin<State> = DirtyCheckPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  private _someDirty = new Subject();\n  someDirty$: Observable<boolean> = merge(this.query.select(state => state.entities), this._someDirty.asObservable()).pipe(\n    auditTime(0),\n    map(() => this.checkSomeDirty())\n  );\n\n  constructor(protected query: QueryEntity<State>, private readonly params: DirtyCheckCollectionParams<State> = {}) {\n    super(query, params.entityIds);\n    this.params = { ...dirtyCheckDefaultParams, ...params };\n    // TODO lazy activate?\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => {\n        super.rebase(ids, { afterAdd: plugin => plugin.setHead() });\n      });\n  }\n\n  setHead(ids?: OrArray<getIDType<State>>) {\n    if (this.params.entityIds && ids) {\n      const toArray = coerceArray(ids) as getIDType<State>[];\n      const someAreWatched = coerceArray(this.params.entityIds).some(id => toArray.indexOf(id) > -1);\n      if (someAreWatched === false) {\n        return this;\n      }\n    }\n    this.forEachId(ids, e => e.setHead());\n    this._someDirty.next();\n    return this;\n  }\n\n  hasHead(id: getIDType<State>): boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return entity.hasHead();\n    }\n\n    return false;\n  }\n\n  reset(ids?: OrArray<getIDType<State>>, params: DirtyCheckResetParams = {}) {\n    this.forEachId(ids, e => e.reset(params));\n  }\n\n  isDirty(id: getIDType<State>): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: true): Observable<boolean>;\n  isDirty(id: getIDType<State>, asObservable: false): boolean;\n  isDirty(id: getIDType<State>, asObservable = true): Observable<boolean> | boolean {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return asObservable ? entity.isDirty$ : entity.isDirty();\n    }\n\n    return false;\n  }\n\n  someDirty(): boolean {\n    return this.checkSomeDirty();\n  }\n\n  isPathDirty(id: getIDType<State>, path: string) {\n    if (this.entities.has(id)) {\n      const head = (this.getEntity(id) as any).getHead();\n      const current = this.query.getEntity(id);\n      const currentPathValue = getNestedPath(current, path);\n      const headPathValue = getNestedPath(head, path);\n\n      return this.params.comparator(currentPathValue, headPathValue);\n    }\n\n    return null;\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.destroy());\n    /** complete only when the plugin destroys */\n    if (!ids) {\n      this._someDirty.complete();\n    }\n  }\n\n  protected instantiatePlugin(id: getIDType<State>): P {\n    return new DirtyCheckPlugin(this.query, this.params, id) as P;\n  }\n\n  private checkSomeDirty(): boolean {\n    const entitiesIds = this.resolvedIds();\n    for (const id of entitiesIds) {\n      if (this.getEntity(id).isDirty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n","import { BehaviorSubject, from, isObservable, Observable, Subscription } from 'rxjs';\nimport { delay, map, switchMap, take } from 'rxjs/operators';\nimport { action, logAction } from '../../actions';\nimport { isNil } from '../../isNil';\nimport { isUndefined } from '../../isUndefined';\nimport { QueryEntity } from '../../queryEntity';\nimport { applyTransaction } from '../../transaction';\nimport { EntityState, getEntityType, ID } from '../../types';\nimport { AkitaPlugin } from '../plugin';\n\nexport interface PaginationResponse<E> {\n  currentPage: number;\n  perPage: number;\n  lastPage: number;\n  data: E[];\n  total?: number;\n  from?: number;\n  to?: number;\n  pageControls?: number[];\n}\n\nexport type PaginatorConfig = {\n  pagesControls?: boolean;\n  range?: boolean;\n  startWith?: number;\n  cacheTimeout?: Observable<number>;\n  clearStoreWithCache?: boolean;\n};\n\nconst paginatorDefaults: PaginatorConfig = {\n  pagesControls: false,\n  range: false,\n  startWith: 1,\n  cacheTimeout: undefined,\n  clearStoreWithCache: true,\n};\n\nexport class PaginatorPlugin<State extends EntityState> extends AkitaPlugin<State> {\n  /** Save current filters, sorting, etc. in cache */\n  metadata = new Map();\n\n  private page: BehaviorSubject<number>;\n  private pages = new Map<number, { ids: ID[] }>();\n  private readonly clearCacheSubscription: Subscription;\n\n  private pagination: PaginationResponse<getEntityType<State>> = {\n    currentPage: 1,\n    perPage: 0,\n    total: 0,\n    lastPage: 0,\n    data: [],\n  };\n\n  /**\n   * When the user navigates to a different page and return\n   * we don't want to call `clearCache` on first time.\n   */\n  private initial = true;\n\n  constructor(protected query: QueryEntity<State>, public config: PaginatorConfig = {}) {\n    super(query, {\n      resetFn: () => {\n        this.initial = false;\n        this.destroy({ clearCache: true, currentPage: 1 });\n      },\n    });\n    this.config = { ...paginatorDefaults, ...config };\n    const { startWith, cacheTimeout } = this.config;\n    this.page = new BehaviorSubject(startWith);\n    if (isObservable(cacheTimeout)) {\n      this.clearCacheSubscription = cacheTimeout.subscribe(() => this.clearCache());\n    }\n  }\n\n  /**\n   * Proxy to the query loading\n   */\n  isLoading$ = this.query.selectLoading().pipe(delay(0));\n\n  /**\n   * Listen to page changes\n   */\n  get pageChanges() {\n    return this.page.asObservable();\n  }\n\n  /**\n   * Get the current page number\n   */\n  get currentPage() {\n    return this.pagination.currentPage;\n  }\n\n  /**\n   * Check if current page is the first one\n   */\n  get isFirst() {\n    return this.currentPage === 1;\n  }\n\n  /**\n   * Check if current page is the last one\n   */\n  get isLast() {\n    return this.currentPage === this.pagination.lastPage;\n  }\n\n  /**\n   * Whether to generate an array of pages for *ngFor\n   * [1, 2, 3, 4]\n   */\n  withControls() {\n    this.config.pagesControls = true;\n    return this;\n  }\n\n  /**\n   * Whether to generate the `from` and `to` keys\n   * [1, 2, 3, 4]\n   */\n  withRange() {\n    this.config.range = true;\n    return this;\n  }\n\n  /**\n   * Set the loading state\n   */\n  setLoading(value = true) {\n    this.getStore().setLoading(value);\n  }\n\n  /**\n   * Update the pagination object and add the page\n   */\n  @action('@Pagination - New Page')\n  update(response: PaginationResponse<getEntityType<State>>) {\n    this.pagination = response;\n    this.addPage(response.data);\n  }\n\n  /**\n   *\n   * Set the ids and add the page to store\n   */\n  addPage(data: getEntityType<State>[]) {\n    this.pages.set(this.currentPage, { ids: data.map((entity) => entity[this.getStore().idKey]) });\n    this.getStore().upsertMany(data);\n  }\n\n  /**\n   * Clear the cache.\n   */\n  clearCache(options: { clearStore?: boolean } = {}) {\n    if (!this.initial) {\n      logAction('@Pagination - Clear Cache');\n\n      if (options.clearStore !== false && (this.config.clearStoreWithCache || options.clearStore)) {\n        this.getStore().remove();\n      }\n\n      this.pages = new Map();\n      this.metadata = new Map();\n    }\n    this.initial = false;\n  }\n\n  clearPage(page: number) {\n    this.pages.delete(page);\n  }\n\n  /**\n   * Clear the cache timeout and optionally the pages\n   */\n  destroy({ clearCache, currentPage }: { clearCache?: boolean; currentPage?: number } = {}) {\n    if (this.clearCacheSubscription) {\n      this.clearCacheSubscription.unsubscribe();\n    }\n    if (clearCache) {\n      this.clearCache();\n    }\n    if (!isUndefined(currentPage)) {\n      this.setPage(currentPage);\n    }\n    this.initial = true;\n  }\n\n  /**\n   * Whether the provided page is active\n   */\n  isPageActive(page: number) {\n    return this.currentPage === page;\n  }\n\n  /**\n   * Set the current page\n   */\n  setPage(page: number) {\n    if (page !== this.currentPage || !this.hasPage(page)) {\n      this.page.next((this.pagination.currentPage = page));\n    }\n  }\n\n  /**\n   * Increment current page\n   */\n  nextPage() {\n    if (this.currentPage !== this.pagination.lastPage) {\n      this.setPage(this.pagination.currentPage + 1);\n    }\n  }\n\n  /**\n   * Decrement current page\n   */\n  prevPage() {\n    if (this.pagination.currentPage > 1) {\n      this.setPage(this.pagination.currentPage - 1);\n    }\n  }\n\n  /**\n   * Set current page to last\n   */\n  setLastPage() {\n    this.setPage(this.pagination.lastPage);\n  }\n\n  /**\n   * Set current page to first\n   */\n  setFirstPage() {\n    this.setPage(1);\n  }\n\n  /**\n   * Check if page exists in cache\n   */\n  hasPage(page: number) {\n    return this.pages.has(page);\n  }\n\n  /**\n   * Get the current page if it's in cache, otherwise invoke the request\n   */\n  getPage(req: () => Observable<PaginationResponse<getEntityType<State>>>) {\n    let page = this.pagination.currentPage;\n    if (this.hasPage(page)) {\n      return this.selectPage(page);\n    } else {\n      this.setLoading(true);\n      return from(req()).pipe(\n        switchMap((config: PaginationResponse<getEntityType<State>>) => {\n          page = config.currentPage;\n          applyTransaction(() => {\n            this.setLoading(false);\n            this.update(config);\n          });\n          return this.selectPage(page);\n        })\n      );\n    }\n  }\n\n  getQuery(): QueryEntity<State> {\n    return this.query;\n  }\n\n  refreshCurrentPage() {\n    if (isNil(this.currentPage) === false) {\n      this.clearPage(this.currentPage);\n      this.setPage(this.currentPage);\n    }\n  }\n\n  private getFrom() {\n    if (this.isFirst) {\n      return 1;\n    }\n    return (this.currentPage - 1) * this.pagination.perPage + 1;\n  }\n\n  private getTo() {\n    if (this.isLast) {\n      return this.pagination.total;\n    }\n    return this.currentPage * this.pagination.perPage;\n  }\n\n  /**\n   * Select the page\n   */\n  private selectPage(page: number): Observable<PaginationResponse<getEntityType<State>>> {\n    return this.query.selectAll({ asObject: true }).pipe(\n      take(1),\n      map((entities) => {\n        const response: PaginationResponse<getEntityType<State>> = {\n          ...this.pagination,\n          data: this.pages.get(page).ids.map((id) => entities[id]),\n        };\n\n        const { range, pagesControls } = this.config;\n\n        /** If no total - calc it */\n        if (isNaN(this.pagination.total)) {\n          if (response.lastPage === 1) {\n            response.total = response.data ? response.data.length : 0;\n          } else {\n            response.total = response.perPage * response.lastPage;\n          }\n          this.pagination.total = response.total;\n        }\n\n        if (range) {\n          response.from = this.getFrom();\n          response.to = this.getTo();\n        }\n\n        if (pagesControls) {\n          response.pageControls = generatePages(this.pagination.total, this.pagination.perPage);\n        }\n\n        return response;\n      })\n    );\n  }\n}\n\n/**\n * Generate an array so we can ngFor them to navigate between pages\n */\nfunction generatePages(total: number, perPage: number) {\n  const len = Math.ceil(total / perPage);\n  const arr = [];\n  for (let i = 0; i < len; i++) {\n    arr.push(i + 1);\n  }\n  return arr;\n}\n\n/** backward compatibility */\nexport const Paginator = PaginatorPlugin;\n","import { AkitaPlugin } from '../plugin';\nimport { Query } from '../../query';\nimport { Observable, Subscription } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\nimport { getValue } from '../../getValueByString';\nimport { toBoolean } from '../../toBoolean';\nimport { isString } from '../../isString';\nimport { setValue } from '../../setValueByString';\nimport { logAction } from '../../actions';\n\nexport type FormGroupLike = {\n  patchValue: Function;\n  setValue: Function;\n  value: any;\n  get: Function;\n  valueChanges: Observable<any>;\n  controls: any;\n};\n\nexport type AkitaFormProp<T> = {\n  [key: string]: T;\n};\n\nexport type PersistFormParams = {\n  debounceTime?: number;\n  formKey?: string;\n  emitEvent?: boolean;\n  arrControlFactory?: ArrayControlFactory;\n};\n\nexport type ArrayControlFactory = (value: any) => any; // Todo: Return  AbstractControl interface\n\nexport class PersistNgFormPlugin<T = any> extends AkitaPlugin {\n  formChanges: Subscription;\n  private isRootKeys: boolean;\n  private form: FormGroupLike;\n  private isKeyBased: boolean;\n  private initialValue;\n  private builder;\n\n  constructor(protected query: Query<any>, private factoryFnOrPath?: Function | string, private params: PersistFormParams = {}) {\n    super(query);\n    this.params = { ...{ debounceTime: 300, formKey: 'akitaForm', emitEvent: false, arrControlFactory: v => this.builder.control(v) }, ...params };\n    this.isRootKeys = toBoolean(factoryFnOrPath) === false;\n    this.isKeyBased = isString(factoryFnOrPath) || this.isRootKeys;\n  }\n\n  setForm(form: FormGroupLike, builder?) {\n    this.form = form;\n    this.builder = builder;\n    this.activate();\n    return this;\n  }\n\n  reset(initialState?: T) {\n    let value;\n    if (initialState) {\n      value = initialState;\n    } else {\n      value = this.isKeyBased ? this.initialValue : (this as any).factoryFnOrPath();\n    }\n\n    if (this.isKeyBased) {\n      Object.keys(this.initialValue).forEach(stateKey => {\n        const value = this.initialValue[stateKey];\n        if (Array.isArray(value) && this.builder) {\n          const formArray = this.form.controls[stateKey];\n          this.cleanArray(formArray);\n          value.forEach((v, i) => {\n            this.form.get(stateKey).insert(i, (this.params.arrControlFactory as Function)(v));\n          });\n        }\n      });\n    }\n    this.form.patchValue(value, { emitEvent: this.params.emitEvent });\n\n    const storeValue = this.isKeyBased ? setValue(this.getQuery().getValue(), `${this.getStore().storeName}.${this.factoryFnOrPath}`, value) : { [this.params.formKey]: value };\n    this.updateStore(storeValue);\n  }\n\n  private cleanArray(control) {\n    while (control.length !== 0) {\n      control.removeAt(0);\n    }\n  }\n\n  private resolveInitialValue(formValue, root) {\n    if (!formValue) return;\n    return Object.keys(formValue).reduce((acc, stateKey) => {\n      const value = root[stateKey];\n      if (Array.isArray(value) && this.builder) {\n        const factory = this.params.arrControlFactory;\n        this.cleanArray(this.form.get(stateKey));\n        value.forEach((v, i) => {\n          this.form.get(stateKey).insert(i, (factory as Function)(v));\n        });\n      }\n      acc[stateKey] = root[stateKey];\n      return acc;\n    }, {});\n  }\n\n  private activate() {\n    let path;\n\n    if (this.isKeyBased) {\n      if (this.isRootKeys) {\n        this.initialValue = this.resolveInitialValue(this.form.value, this.getQuery().getValue());\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      } else {\n        path = `${this.getStore().storeName}.${this.factoryFnOrPath}`;\n        const root = getValue(this.getQuery().getValue(), path);\n        this.initialValue = this.resolveInitialValue(root, root);\n        this.form.patchValue(this.initialValue, { emitEvent: this.params.emitEvent });\n      }\n    } else {\n      if (!(this.getQuery().getValue() as AkitaFormProp<T>)[this.params.formKey]) {\n        logAction('@PersistNgFormPlugin activate');\n        this.updateStore({ [this.params.formKey]: (this as any).factoryFnOrPath() });\n      }\n\n      const value = this.getQuery().getValue()[this.params.formKey];\n      this.form.patchValue(value);\n    }\n\n    this.formChanges = this.form.valueChanges.pipe(debounceTime(this.params.debounceTime)).subscribe(value => {\n      logAction('@PersistForm - Update');\n      let newState;\n      if (this.isKeyBased) {\n        if (this.isRootKeys) {\n          newState = state => ({ ...state, ...value });\n        } else {\n          newState = state => setValue(state, path, value);\n        }\n      } else {\n        newState = () => ({ [this.params.formKey]: value });\n      }\n      this.updateStore(newState(this.getQuery().getValue()));\n    });\n  }\n\n  destroy() {\n    this.formChanges && this.formChanges.unsubscribe();\n    this.form = null;\n    this.builder = null;\n  }\n}\n","import { pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { BehaviorSubject, Observable } from 'rxjs';\nimport { AkitaPlugin, Queries } from '../plugin';\nimport { logAction } from '../../actions';\nimport { isFunction } from '../../isFunction';\n\nexport interface StateHistoryParams {\n  maxAge?: number;\n  watchProperty?: string;\n  comparator?: (prevState, currentState) => boolean;\n}\n\nexport type History<State> = {\n  past: State[];\n  present: State | null;\n  future: State[];\n};\n\nexport class StateHistoryPlugin<State = any> extends AkitaPlugin<State> {\n  /** Allow skipping an update from outside */\n  private skip = false;\n\n  private history = {\n    past: [],\n    present: null,\n    future: [],\n  };\n\n  /** Skip the update when redo/undo */\n  private skipUpdate = false;\n  private subscription;\n\n  /* Subjects for supporting observable hasPast$ and hasFuture$ */\n  private hasPastSubject: BehaviorSubject<boolean>;\n  private _hasPast$: Observable<boolean>;\n  private hasFutureSubject: BehaviorSubject<boolean>;\n  private _hasFuture$: Observable<boolean>;\n\n  constructor(protected query: Queries<State>, private params: StateHistoryParams = {}, private _entityId?: any) {\n    super(query, {\n      resetFn: () => this.clear(),\n    });\n    params.maxAge = !!params.maxAge ? params.maxAge : 10;\n    params.comparator = params.comparator || (() => true);\n\n    this.activate();\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available past\n   *\n   */\n  get hasPast$(): Observable<boolean> {\n    return this._hasPast$;\n  }\n\n  /**\n   * Observable stream representing whether the history plugin has an available future\n   *\n   */\n  get hasFuture$(): Observable<boolean> {\n    return this._hasFuture$;\n  }\n\n  get hasPast() {\n    return this.history.past.length > 0;\n  }\n\n  get hasFuture() {\n    return this.history.future.length > 0;\n  }\n\n  private get property() {\n    return this.params.watchProperty;\n  }\n\n  /* Updates the hasPast$ hasFuture$ observables*/\n  private updateHasHistory() {\n    this.hasFutureSubject.next(this.hasFuture);\n    this.hasPastSubject.next(this.hasPast);\n  }\n\n  activate() {\n    this.hasPastSubject = new BehaviorSubject(false);\n    this._hasPast$ = this.hasPastSubject.asObservable().pipe(distinctUntilChanged());\n    this.hasFutureSubject = new BehaviorSubject(false);\n    this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(distinctUntilChanged());\n\n    this.history.present = this.getSource(this._entityId, this.property);\n    this.subscription = (this as any)\n      .selectSource(this._entityId, this.property)\n      .pipe(pairwise())\n      .subscribe(([past, present]) => {\n        if (this.skip) {\n          this.skip = false;\n          return;\n        }\n        /**\n         *  comparator: (prev, current) => isEqual(prev, current) === false\n         */\n        const shouldUpdate = this.params.comparator(past, present);\n\n        if (!this.skipUpdate && shouldUpdate) {\n          if (this.history.past.length === this.params.maxAge) {\n            this.history.past = this.history.past.slice(1);\n          }\n          this.history.past = [...this.history.past, past];\n          this.history.present = present;\n          this.updateHasHistory();\n        }\n      });\n  }\n\n  undo() {\n    if (this.history.past.length > 0) {\n      const { past, present } = this.history;\n      const previous = past[past.length - 1];\n      this.history.past = past.slice(0, past.length - 1);\n      this.history.present = previous;\n      this.history.future = [present, ...this.history.future];\n      this.update();\n    }\n  }\n\n  redo() {\n    if (this.history.future.length > 0) {\n      const { past, present } = this.history;\n      const next = this.history.future[0];\n      const newFuture = this.history.future.slice(1);\n      this.history.past = [...past, present];\n      this.history.present = next;\n      this.history.future = newFuture;\n      this.update('Redo');\n    }\n  }\n\n  jumpToPast(index: number) {\n    if (index < 0 || index >= this.history.past.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9];\n     * const index = 2;\n     *\n     * newPast = past.slice(0, index) = [1, 2];\n     * newPresent = past[index] = 3;\n     * newFuture = [...past.slice(index + 1),present, ...future] = [4, 5, 6, 7, 8, 9];\n     *\n     */\n    const newPast = past.slice(0, index);\n    const newFuture = [...past.slice(index + 1), present, ...future];\n    const newPresent = past[index];\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update();\n  }\n\n  jumpToFuture(index: number) {\n    if (index < 0 || index >= this.history.future.length) return;\n\n    const { past, future, present } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9, 10]\n     * const index = 1\n     *\n     * newPast = [...past, present, ...future.slice(0, index) = [1, 2, 3, 4, 5, 6, 7];\n     * newPresent = future[index] = 8;\n     * newFuture = futrue.slice(index+1) = [9, 10];\n     *\n     */\n\n    const newPast = [...past, present, ...future.slice(0, index)];\n    const newPresent = future[index];\n    const newFuture = future.slice(index + 1);\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update('Redo');\n  }\n\n  /**\n   *\n   * jump n steps in the past or forward\n   *\n   */\n  jump(n: number) {\n    if (n > 0) return this.jumpToFuture(n - 1);\n    if (n < 0) return this.jumpToPast(this.history.past.length + n);\n  }\n\n  /**\n   * Clear the history\n   *\n   * @param customUpdateFn Callback function for only clearing part of the history\n   *\n   * @example\n   *\n   * stateHistory.clear((history) => {\n   *  return {\n   *    past: history.past,\n   *    present: history.present,\n   *    future: []\n   *  };\n   * });\n   */\n  clear(customUpdateFn?: (history: History<State>) => History<State>) {\n    this.history = isFunction(customUpdateFn)\n      ? customUpdateFn(this.history)\n      : {\n          past: [],\n          present: null,\n          future: [],\n        };\n    this.updateHasHistory();\n  }\n\n  destroy(clearHistory = false) {\n    if (clearHistory) {\n      this.clear();\n    }\n    this.subscription.unsubscribe();\n  }\n\n  ignoreNext() {\n    this.skip = true;\n  }\n\n  private update(action = 'Undo') {\n    this.skipUpdate = true;\n    logAction(`@StateHistory - ${action}`);\n    this.updateStore(this.history.present, this._entityId, this.property, true);\n    this.updateHasHistory();\n    this.skipUpdate = false;\n  }\n}\n","import { EntityState, OrArray, getIDType } from '../../types';\nimport { QueryEntity } from '../../queryEntity';\nimport { StateHistoryParams, StateHistoryPlugin } from './stateHistoryPlugin';\nimport { toBoolean } from '../../toBoolean';\nimport { skip } from 'rxjs/operators';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\n\nexport interface StateHistoryEntityParams<IDType> extends StateHistoryParams {\n  entityIds?: OrArray<IDType>;\n}\n\nexport class EntityStateHistoryPlugin<State extends EntityState = any, P extends StateHistoryPlugin<State> = StateHistoryPlugin<State>> extends EntityCollectionPlugin<State, P> {\n  constructor(protected query: QueryEntity<State>, protected readonly params: StateHistoryEntityParams<getIDType<State>> = {}) {\n    super(query, params.entityIds);\n    params.maxAge = toBoolean(params.maxAge) ? params.maxAge : 10;\n    this.activate();\n    this.selectIds()\n      .pipe(skip(1))\n      .subscribe(ids => this.activate(ids));\n  }\n\n  redo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.redo());\n  }\n\n  undo(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.undo());\n  }\n\n  hasPast(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasPast;\n    }\n  }\n\n  hasFuture(id: getIDType<State>) {\n    if (this.hasEntity(id)) {\n      return this.getEntity(id).hasFuture;\n    }\n  }\n\n  jumpToFuture(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToFuture(index));\n  }\n\n  jumpToPast(ids: OrArray<getIDType<State>>, index: number) {\n    this.forEachId(ids, e => e.jumpToPast(index));\n  }\n\n  clear(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.clear());\n  }\n\n  destroy(ids?: OrArray<getIDType<State>>, clearHistory = false) {\n    this.forEachId(ids, e => e.destroy(clearHistory));\n  }\n\n  ignoreNext(ids?: OrArray<getIDType<State>>) {\n    this.forEachId(ids, e => e.ignoreNext());\n  }\n\n  protected instantiatePlugin(id: getIDType<State>) {\n    return new StateHistoryPlugin<State>(this.query, this.params, id) as P;\n  }\n}\n","import { EntityStore } from './entityStore';\nimport { AkitaError } from './errors';\nimport { isNil } from './isNil';\nimport { Store } from './store';\nimport { configKey } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { Constructor } from './types';\n\nexport enum StoreAction {\n  Update = 'UPDATE',\n}\n\nconst StoreActionMapping = {\n  [StoreAction.Update]: 'update',\n};\n\nexport enum EntityStoreAction {\n  Update = 'UPDATE',\n  AddEntities = 'ADD_ENTITIES',\n  SetEntities = 'SET_ENTITIES',\n  UpdateEntities = 'UPDATE_ENTITIES',\n  RemoveEntities = 'REMOVE_ENTITIES',\n  UpsertEntities = 'UPSERT_ENTITIES',\n  UpsertManyEntities = 'UPSERT_MANY_ENTITIES',\n}\n\nconst EntityStoreActionMapping = {\n  [EntityStoreAction.Update]: 'update',\n  [EntityStoreAction.AddEntities]: 'add',\n  [EntityStoreAction.SetEntities]: 'set',\n  [EntityStoreAction.UpdateEntities]: 'update',\n  [EntityStoreAction.RemoveEntities]: 'remove',\n  [EntityStoreAction.UpsertEntities]: 'upsert',\n  [EntityStoreAction.UpsertManyEntities]: 'upsertMany',\n};\n\n/**\n * Get a {@link Store} from the global store registry.\n * @param storeClass The {@link Store} class of the instance to be returned.\n */\nexport function getStore<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : never>(storeClass: Constructor<TStore>): TStore {\n  return getStoreByName<TStore, S>(storeClass[configKey]['storeName']);\n}\n\n/**\n * Get a {@link Store} from the global store registry.\n * @param storeName The {@link Store} name of the instance to be returned.\n */\nexport function getStoreByName<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : never>(storeName: string): TStore {\n  const store = __stores__[storeName] as TStore;\n\n  if (isNil(store)) {\n    throw new AkitaError(`${store.storeName} doesn't exist`);\n  }\n\n  return store;\n}\n\n/**\n * Get a {@link EntityStore} from the global store registry.\n * @param storeClass The {@link EntityStore} class of the instance to be returned.\n */\nexport function getEntityStore<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : never>(storeClass: Constructor<TEntityStore>): TEntityStore {\n  return getStore(storeClass as Constructor<Store<S>>) as TEntityStore;\n}\n\n/**\n * Get a {@link EntityStore} from the global store registry.\n * @param storeName The {@link EntityStore} name of the instance to be returned.\n */\nexport function getEntityStoreByName<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : never>(storeName: string): TEntityStore {\n  return getStoreByName<TEntityStore, S>(storeName) as TEntityStore;\n}\n\n/**\n * Run {@link StoreAction.Update} action.\n * @param storeClassOrName The {@link Store} class or name in which the action should be executed.\n * @param action The {@link StoreAction.Update} action, see {@link Store.update}.\n * @param operation The operation to execute the {@link StoreAction.Update} action.\n * @example\n *\n *  runStoreAction(BooksStore, StoreAction.Update, update => update({ filter: 'COMPLETE' }));\n *\n */\nexport function runStoreAction<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : any>(\n  storeClassOrName: Constructor<TStore> | string,\n  action: StoreAction.Update,\n  operation: (operator: TStore['update']) => void\n);\nexport function runStoreAction<TStore extends Store<S>, S = TStore extends Store<infer T> ? T : any>(\n  storeClassOrName: Constructor<TStore> | string,\n  action: StoreAction,\n  operation: (operator: TStore[keyof TStore] & Function) => void\n) {\n  const store = typeof storeClassOrName === 'string' ? getStoreByName<TStore, S>(storeClassOrName) : getStore<TStore, S>(storeClassOrName);\n  operation(store[StoreActionMapping[action]].bind(store));\n}\n\n/**\n * Run {@link EntityStoreAction.SetEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.SetEntities} action, see {@link EntityStore.set}.\n * @param operation The operation to execute the {@link EntityStoreAction.SetEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.SetEntities, set => set([{ id: 1 }, { id: 2 }]));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.SetEntities,\n  operation: (operator: TEntityStore['set']) => void\n);\n/**\n * Run {@link EntityStoreAction.AddEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.AddEntities} action, see {@link EntityStore.add}.\n * @param operation The operation to execute the {@link EntityStoreAction.AddEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.AddEntities, add => add({ id: 1 }));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.AddEntities,\n  operation: (operator: TEntityStore['add']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpdateEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpdateEntities} action, see {@link EntityStore.update}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpdateEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpdateEntities, update => update(2, { title: 'New title' }));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpdateEntities,\n  operation: (operator: TEntityStore['update']) => void\n);\n/**\n * Run {@link EntityStoreAction.RemoveEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.RemoveEntities} action, see {@link EntityStore.remove}.\n * @param operation The operation to execute the {@link EntityStoreAction.RemoveEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.RemoveEntities, remove => remove(2));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.RemoveEntities,\n  operation: (operator: TEntityStore['remove']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpsertEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpsertEntities} action, see {@link EntityStore.upsert}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpsertEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpsertEntities, upsert => upsert([2, 3], { title: 'New Title' }, (id, newState) => ({ id, ...newState, price: 0 })));\n *\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpsertEntities,\n  operation: (operator: TEntityStore['upsert']) => void\n);\n/**\n * Run {@link EntityStoreAction.UpsertManyEntities} action.\n * @param storeClassOrName The {@link EntityStore} class or name in which the action should be executed.\n * @param action The {@link EntityStoreAction.UpsertManyEntities} action, see {@link EntityStore.upsertMany}.\n * @param operation The operation to execute the {@link EntityStoreAction.UpsertManyEntities} action.\n * @example\n *\n *  runEntityStoreAction(BooksStore, EntityStoreAction.UpsertManyEntities, upsertMany => upsertMany([\n *    { id: 2, title: 'New title', price: 0 },\n *    { id: 4, title: 'Another title', price: 0 },\n *  ));\n */\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction.UpsertManyEntities,\n  operation: (operator: TEntityStore['upsertMany']) => void\n);\nexport function runEntityStoreAction<TEntityStore extends EntityStore<S>, S = TEntityStore extends EntityStore<infer T> ? T : any>(\n  storeClassOrName: Constructor<TEntityStore> | string,\n  action: EntityStoreAction,\n  operation: (operator: TEntityStore[keyof TEntityStore] & Function) => void\n) {\n  const store = typeof storeClassOrName === 'string' ? getEntityStoreByName<TEntityStore, S>(storeClassOrName) : getEntityStore<TEntityStore, S>(storeClassOrName);\n  operation(store[EntityStoreActionMapping[action]].bind(store));\n}\n","import { __stores__ } from './stores';\nimport { isString } from './isString';\nimport { setSkipStorageUpdate } from './persistState';\nimport { $$addStore } from './dispatchers';\nimport { filter, take } from 'rxjs/operators';\n\nexport class SnapshotManager {\n  /**\n   * Get a snapshot of the whole state or a specific stores\n   * Use it ONLY for things such as saving the state in the server\n   */\n  getStoresSnapshot(stores: string[] = []) {\n    let acc = {};\n    const hasInclude = stores.length > 0;\n    const keys = hasInclude ? stores : Object.keys(__stores__);\n    for (let i = 0; i < keys.length; i++) {\n      let storeName = keys[i];\n      if (storeName !== 'router') {\n        acc[storeName] = __stores__[storeName]._value();\n      }\n    }\n\n    return acc;\n  }\n\n  setStoresSnapshot(stores: { [storeName: string]: any } | string, options?: { skipStorageUpdate?: boolean; lazy?: boolean }) {\n    const mergedOptions = { ...{ skipStorageUpdate: false, lazy: false }, ...options };\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(true);\n\n    let normalizedStores = stores;\n\n    if (isString(stores)) {\n      normalizedStores = JSON.parse(normalizedStores as string);\n    }\n\n    const size = Object.keys(normalizedStores).length;\n\n    if (mergedOptions.lazy) {\n      $$addStore\n        .pipe(\n          filter(name => normalizedStores.hasOwnProperty(name)),\n          take(size)\n        )\n        .subscribe(name => __stores__[name]._setState(() => normalizedStores[name]));\n    } else {\n      for (let i = 0, keys = Object.keys(normalizedStores); i < keys.length; i++) {\n        const storeName = keys[i];\n        if (__stores__[storeName]) {\n          __stores__[storeName]._setState(() => normalizedStores[storeName]);\n        }\n      }\n    }\n\n    mergedOptions.skipStorageUpdate && setSkipStorageUpdate(false);\n  }\n}\n\nexport const snapshotManager = new SnapshotManager();\n","import { merge, MonoTypeOperatorFunction, Observable, of, Operator, Subscriber, TeardownLogic } from 'rxjs';\nimport { filter, first, switchMap, tap } from 'rxjs/operators';\nimport { QueryEntity } from './queryEntity';\nimport { EntityState, getEntityType, getQueryEntityState } from './types';\n\n/**\n * Track id updates of an entity and re-evaluation the query with the changed entity id.\n * Hint: Don't place the operator after other operators in the same pipeline as those will be skipped on\n * re-evaluation. Also, it can't be used with the selection operator, e.g <code>selectEntity(1, e => e.title)</code>\n * @param query The query from which the entity is selected.\n * @example\n *\n *   query.selectEntity(1).pipe(trackIdChanges(query)).subscribe(entity => { ... })\n *\n */\nexport function trackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T> = getQueryEntityState<K>, T = getEntityType<S>>(query: K): MonoTypeOperatorFunction<T> {\n  return (source) => source.lift<T>(new TrackIdChanges(query));\n}\n\nclass TrackIdChanges<K extends QueryEntity<S, T>, S extends EntityState<T>, T = getEntityType<S>> implements Operator<T, T> {\n  constructor(readonly query: K) {}\n\n  call(subscriber: Subscriber<T>, source: Observable<T>): TeardownLogic {\n    return source\n      .pipe(\n        first(),\n        switchMap((entity) => {\n          let currId = entity[this.query.__store__.config.idKey];\n          let pending = false;\n\n          return merge(of({ newId: undefined, oldId: currId, pending: false }), this.query.__store__.selectEntityIdChanges$).pipe(\n            // the new id must differ form the old id\n            filter((change) => change.oldId === currId),\n            // extract the current pending state of the id update\n            tap((change) => (pending = change.pending)),\n            // only update the selection query if the id update is already applied to the store\n            filter((change) => change.newId !== currId && !pending),\n            // build a selection query for the new entity id\n            switchMap((change) =>\n              this.query\n                .selectEntity((currId = change.newId || currId))\n                // skip undefined value if pending.\n                .pipe(filter(() => !pending))\n            )\n          );\n        })\n      )\n      .subscribe(subscriber);\n  }\n}\n","import { Order } from './sort';\n\nexport type SortBy<E, S = any> = ((a: E, b: E, state?: S) => number) | keyof E;\n\nexport interface SortByOptions<E> {\n  sortBy?: SortBy<E>;\n  sortByOrder?: Order;\n}\n\nexport interface QueryConfigOptions<E = any> extends SortByOptions<E> {}\n\nexport const queryConfigKey = 'akitaQueryConfig';\n\nexport function QueryConfig<E>(metadata: QueryConfigOptions<E>) {\n  return function(constructor: Function) {\n    constructor[queryConfigKey] = {};\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      constructor[queryConfigKey][key] = metadata[key];\n    }\n  };\n}\n","import { AkitaConfig } from './config';\n\nexport type StoreConfigOptions = {\n  name: string;\n  resettable?: AkitaConfig['resettable'];\n  cache?: { ttl: number };\n  deepFreezeFn?: (o: any) => any;\n  idKey?: string;\n  producerFn?: AkitaConfig['producerFn'];\n};\n\nexport type UpdatableStoreConfigOptions = {\n  cache?: { ttl: number };\n};\n\nexport const configKey = 'akitaConfig';\n\nexport function StoreConfig(metadata: StoreConfigOptions) {\n  return function(constructor: Function) {\n    constructor[configKey] = { idKey: 'id' };\n\n    for (let i = 0, keys = Object.keys(metadata); i < keys.length; i++) {\n      const key = keys[i];\n      /* name is preserved read only key */\n      if (key === 'name') {\n        constructor[configKey]['storeName'] = metadata[key];\n      } else {\n        constructor[configKey][key] = metadata[key];\n      }\n    }\n  };\n}\n","import { IDS, ItemPredicate } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { coerceArray } from './coerceArray';\nimport { isObject } from './isObject';\nimport { isFunction } from './isFunction';\nimport { not } from './not';\n\n/**\n * Remove item from collection\n *\n * @example\n *\n *\n * store.update(state => ({\n *   names: arrayRemove(state.names, ['one', 'second'])\n * }))\n */\nexport function arrayRemove<T extends any[], Entity = any>(arr: T, identifier: IDS | ItemPredicate<Entity>, idKey = DEFAULT_ID_KEY): T {\n  let identifiers;\n  let filterFn;\n\n  if (isFunction(identifier)) {\n    filterFn = not(identifier);\n  } else {\n    identifiers = coerceArray(identifier as IDS);\n    filterFn = (current) => {\n      return identifiers.includes(isObject(current) ? current[idKey] : current) === false;\n    };\n  }\n\n  if (Array.isArray(arr)) {\n    return arr.filter(filterFn) as any;\n  }\n}\n","// @internal\nexport function not(pred: Function): Function {\n  return function(...args) {\n    return !pred(...args);\n  };\n}\n","import { ID } from './types';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { arrayAdd } from './arrayAdd';\nimport { arrayUpdate } from './arrayUpdate';\nimport { isObject } from './isObject';\n\n/**\n * Upsert item in a collection\n *\n * @example\n *\n *\n * store.update(1, entity => ({\n *   comments: arrayUpsert(entity.comments, 1, { name: 'newComment' })\n * }))\n */\nexport function arrayUpsert<Root extends any[]>(arr: Root, id: ID, obj: Partial<Root[0]>, idKey = DEFAULT_ID_KEY): Root[0][] {\n  const entityIsObject = isObject(obj);\n  const entityExists = arr.some(entity => (entityIsObject ? entity[idKey] === id : entity === id));\n  if (entityExists) {\n    return arrayUpdate(arr, id, obj, idKey);\n  } else {\n    return arrayAdd(arr, entityIsObject ? { ...obj, [idKey]: id } : obj);\n  }\n}\n","import { EMPTY, Observable, of } from 'rxjs';\nimport { Store } from './store';\n\n/**\n * \n * Helper function for checking if we have data in cache\n * \n * export class ProductsService {\n *   constructor(private productsStore: ProductsStore) {}\n\n *   get(): Observable<void> {\n *     const request = this.http.get().pipe(\n *       tap(this.productsStore.set(response))\n *     );\n *\n *     return cacheable(this.productsStore, request);\n *   }\n * }\n */\nexport function cacheable<T>(store: Store, request$: Observable<T>, options: { emitNext: boolean } = { emitNext: false }): Observable<T | undefined | never> {\n  if (store._cache().value) {\n    return options.emitNext ? of(undefined) : EMPTY;\n  }\n  return request$;\n}\n","import { combineLatest, Observable, ObservableInput, ObservedValueOf } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\n\ntype ReturnTypes<T extends Observable<any>[]> = { [P in keyof T]: T[P] extends Observable<infer R> ? R : never };\ntype Observables = [Observable<any>] | Observable<any>[];\n\nexport function combineQueries<R extends Observables>(observables: R): Observable<ReturnTypes<R>> {\n  return combineLatest(observables).pipe(auditTime(0)) as any;\n}\n","import { Store } from './store';\nimport { Query } from './query';\nimport { StoreConfigOptions } from './storeConfig';\nimport { EntityStore } from './entityStore';\nimport { QueryEntity } from './queryEntity';\nimport { QueryConfigOptions } from './queryConfig';\nimport { EntityState } from './types';\n\nexport function createStore<State>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new Store<State>(initialState, options);\n}\n\nexport function createQuery<State>(store: Store<State>) {\n  return new Query<State>(store);\n}\n\nexport function createEntityStore<State extends EntityState>(initialState: Partial<State>, options: Partial<StoreConfigOptions>) {\n  return new EntityStore<State>(initialState, options);\n}\n\nexport function createEntityQuery<State extends EntityState>(store: EntityStore<State>, options: QueryConfigOptions = {}) {\n  return new QueryEntity<State>(store, options);\n}\n","/**\n * Generate random guid\n *\n * @example\n *\n * {\n *   id: guid()\n * }\n *\n * @remarks this isn't a GUID, but a 10 char random alpha-num\n */\nexport function guid() {\n  return Math.random()\n    .toString(36)\n    .slice(2);\n}\n","import { isArray } from './isArray';\n\n// @internal\nexport function isNumber(value: any): value is number {\n  return !isArray(value) && value - parseFloat(value) + 1 >= 0;\n}\n","import { __stores__ } from './stores';\nimport { applyTransaction } from './transaction';\n\nexport interface ResetStoresParams {\n  exclude: string[];\n}\n\n/**\n * Reset stores back to their initial state\n *\n * @example\n *\n * resetStores()\n * resetStores({\n *   exclude: ['auth']\n * })\n */\nexport function resetStores(options?: Partial<ResetStoresParams>) {\n  const defaults: ResetStoresParams = {\n    exclude: []\n  };\n\n  options = Object.assign({}, defaults, options);\n  const stores = Object.keys(__stores__);\n\n  applyTransaction(() => {\n    for (const store of stores) {\n      const s = __stores__[store];\n      if (!options.exclude) {\n        s.reset();\n      } else {\n        if (options.exclude.indexOf(s.storeName) === -1) {\n          s.reset();\n        }\n      }\n    }\n  });\n}\n","import { defer, MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { finalize } from 'rxjs/operators';\nimport { Store } from './store';\n\nexport function setLoading<T>(store: Store): MonoTypeOperatorFunction<T> {\n  return function <T>(source: Observable<T>) {\n    return defer(() => {\n      store.setLoading(true);\n      return source.pipe(finalize(() => store.setLoading(false)));\n    });\n  };\n}\n","import { defer, MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\nimport { Store } from './store';\n\nexport function setLoadingAndError<T>(store: Store): MonoTypeOperatorFunction<T> {\n  return function <T>(source: Observable<T>) {\n    return defer(() => {\n      store.setLoading(true);\n      store.setError(null);\n\n      return source.pipe(\n        tap({\n          error(err) {\n            store.setLoading(false);\n            store.setError(err);\n          },\n          complete() {\n            store.setLoading(false);\n          },\n        })\n      );\n    });\n  };\n}\n","import { DEFAULT_ID_KEY } from './defaultIDKey';\n\n// @internal\nexport function toEntitiesIds<E>(entities: E[], idKey = DEFAULT_ID_KEY) {\n  const ids = [];\n  for (const entity of entities) {\n    ids.push(entity[idKey]);\n  }\n  return ids;\n}\n"]}