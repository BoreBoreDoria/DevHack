{"version":3,"file":"arrayFind.js","sourceRoot":"ng://@datorama/akita/","sources":["lib/arrayFind.ts"],"names":[],"mappings":"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","sourcesContent":["import { ID, IDS, ItemPredicate } from './types';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { MonoTypeOperatorFunction, Observable } from 'rxjs';\nimport { isArray } from './isArray';\nimport { isFunction } from './isFunction';\nimport { isEmpty } from './isEmpty';\n\n// @internal\nexport function find<T>(collection: T[], idsOrPredicate: IDS | ItemPredicate, idKey: string) {\n  const result = [];\n  if (isFunction(idsOrPredicate)) {\n    for (const entity of collection) {\n      if (idsOrPredicate(entity) === true) {\n        result.push(entity);\n      }\n    }\n  } else {\n    const toSet = coerceArray(idsOrPredicate).reduce((acc, current) => acc.add(current), new Set());\n\n    for (const entity of collection) {\n      if (toSet.has(entity[idKey])) {\n        result.push(entity);\n      }\n    }\n  }\n\n  return result;\n}\n\n// @internal\nexport function distinctUntilArrayItemChanged<T>(): MonoTypeOperatorFunction<T[]> {\n  return distinctUntilChanged((prevCollection: T[], currentCollection: T[]) => {\n    if (prevCollection === currentCollection) {\n      return true;\n    }\n\n    if (isArray(prevCollection) === false || isArray(currentCollection) === false) {\n      return false;\n    }\n\n    if (isEmpty(prevCollection) && isEmpty(currentCollection)) {\n      return true;\n    }\n\n    // if item is new in the current collection but not exist in the prev collection\n    const hasNewItem = hasChange(currentCollection, prevCollection);\n\n    if (hasNewItem) {\n      return false;\n    }\n\n    const isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);\n\n    // return false means there is a change and we want to call next()\n    return isOneOfItemReferenceChanged === false;\n  });\n}\n\n// @internal\nfunction hasChange<T>(first: T[], second: T[]) {\n  const hasChange = second.some(currentItem => {\n    const oldItem = first.find(prevItem => prevItem === currentItem);\n    return oldItem === undefined;\n  });\n\n  return hasChange;\n}\n\n/**\n * Find items in a collection\n *\n * @example\n *\n *  selectEntity(1, 'comments').pipe(\n *   arrayFind(comment => comment.text = 'text')\n * )\n */\nexport function arrayFind<T>(ids: ItemPredicate<T>, idKey?: never): (source: Observable<T[]>) => Observable<T[]>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind(3)\n * )\n */\nexport function arrayFind<T>(ids: ID, idKey?: string): (source: Observable<T[]>) => Observable<T>;\n/**\n * @example\n *\n * selectEntity(1, 'comments').pipe(\n *   arrayFind([1, 2, 3])\n * )\n */\nexport function arrayFind<T>(ids: ID[], idKey?: string): (source: Observable<T[]>) => Observable<T[]>;\nexport function arrayFind<T>(idsOrPredicate: ID[] | ID | ItemPredicate<T>, idKey?: string): (source: Observable<T[]>) => Observable<T[] | T> {\n  return function(source: Observable<T[]>) {\n    return source.pipe(\n      map((collection: T[] | undefined | null) => {\n        // which means the user deleted the root entity or set the collection to nil\n        if (isArray(collection) === false) {\n          return collection;\n        }\n        return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);\n      }),\n      distinctUntilArrayItemChanged(),\n      map(value => {\n        if (isArray(value) === false) {\n          return value;\n        }\n\n        if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {\n          return value;\n        }\n\n        return value[0];\n      })\n    );\n  };\n}\n"]}