import { coerceArray } from './coerceArray';
import { DEFAULT_ID_KEY } from './defaultIDKey';
import { distinctUntilChanged, map } from 'rxjs/operators';
import { isArray } from './isArray';
import { isFunction } from './isFunction';
import { isEmpty } from './isEmpty';
// @internal
export function find(collection, idsOrPredicate, idKey) {
    const result = [];
    if (isFunction(idsOrPredicate)) {
        for (const entity of collection) {
            if (idsOrPredicate(entity) === true) {
                result.push(entity);
            }
        }
    }
    else {
        const toSet = coerceArray(idsOrPredicate).reduce((acc, current) => acc.add(current), new Set());
        for (const entity of collection) {
            if (toSet.has(entity[idKey])) {
                result.push(entity);
            }
        }
    }
    return result;
}
// @internal
export function distinctUntilArrayItemChanged() {
    return distinctUntilChanged((prevCollection, currentCollection) => {
        if (prevCollection === currentCollection) {
            return true;
        }
        if (isArray(prevCollection) === false || isArray(currentCollection) === false) {
            return false;
        }
        if (isEmpty(prevCollection) && isEmpty(currentCollection)) {
            return true;
        }
        // if item is new in the current collection but not exist in the prev collection
        const hasNewItem = hasChange(currentCollection, prevCollection);
        if (hasNewItem) {
            return false;
        }
        const isOneOfItemReferenceChanged = hasChange(prevCollection, currentCollection);
        // return false means there is a change and we want to call next()
        return isOneOfItemReferenceChanged === false;
    });
}
// @internal
function hasChange(first, second) {
    const hasChange = second.some(currentItem => {
        const oldItem = first.find(prevItem => prevItem === currentItem);
        return oldItem === undefined;
    });
    return hasChange;
}
export function arrayFind(idsOrPredicate, idKey) {
    return function (source) {
        return source.pipe(map((collection) => {
            // which means the user deleted the root entity or set the collection to nil
            if (isArray(collection) === false) {
                return collection;
            }
            return find(collection, idsOrPredicate, idKey || DEFAULT_ID_KEY);
        }), distinctUntilArrayItemChanged(), map(value => {
            if (isArray(value) === false) {
                return value;
            }
            if (isArray(idsOrPredicate) || isFunction(idsOrPredicate)) {
                return value;
            }
            return value[0];
        }));
    };
}
//# sourceMappingURL=arrayFind.js.map