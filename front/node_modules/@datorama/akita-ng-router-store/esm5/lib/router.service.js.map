{"version":3,"file":"router.service.js","sourceRoot":"ng://@datorama/akita-ng-router-store/","sources":["lib/router.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { ActivatedRouteSnapshot, GuardsCheckEnd, NavigationCancel, NavigationEnd, NavigationError, ResolveEnd, Router, RoutesRecognized } from '@angular/router';\nimport { RouterState, RouterStore } from './router.store';\nimport { RouterQuery } from './router.query';\nimport { action, setSkipAction } from '@datorama/akita';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class RouterService {\n  private dispatchTriggeredByRouter = false;\n  private navigationTriggeredByDispatch = false;\n  private lastRouterState: RouterState;\n\n  constructor(private routerStore: RouterStore, private routerQuery: RouterQuery, private router: Router) {}\n\n  @action('Navigation Cancelled')\n  dispatchRouterCancel(event: NavigationCancel) {\n    this.update({ navigationId: event.id });\n    this.routerQuery.__navigationCancel.next(event);\n  }\n\n  @action('Navigation Error')\n  dispatchRouterError(event: NavigationError) {\n    this.update({ navigationId: event.id });\n    this.routerQuery.__navigationError.next(event);\n  }\n\n  @action('Navigation Succeeded')\n  dispatchRouterSuccess() {\n    this.update(this.lastRouterState);\n  }\n\n  init() {\n    this.setUpStoreListener();\n    this.setUpStateRollbackEvents();\n  }\n\n  private update(routerState: Partial<RouterState>) {\n    this.dispatchTriggeredByRouter = true;\n    this.routerStore.update((state) => {\n      return {\n        ...state,\n        ...routerState,\n      };\n    });\n    this.dispatchTriggeredByRouter = false;\n    this.navigationTriggeredByDispatch = false;\n  }\n\n  private setUpStoreListener(): void {\n    this.routerQuery\n      .select((state) => state)\n      .subscribe((s) => {\n        this.lastRouterState = s;\n        this.navigateIfNeeded();\n      });\n  }\n\n  private navigateIfNeeded(): void {\n    if (!this.lastRouterState || !this.lastRouterState.state || this.dispatchTriggeredByRouter) {\n      return;\n    }\n\n    if (this.router.url !== this.lastRouterState.state.url) {\n      this.navigationTriggeredByDispatch = true;\n      setSkipAction();\n      this.router.navigateByUrl(this.lastRouterState.state.url);\n    }\n  }\n\n  private setUpStateRollbackEvents(): void {\n    this.router.events.subscribe((e) => {\n      if (e instanceof RoutesRecognized || e instanceof GuardsCheckEnd || e instanceof ResolveEnd) {\n        this.lastRouterState = this.serializeRoute(e);\n      } else if (e instanceof NavigationCancel) {\n        this.dispatchRouterCancel(e);\n      } else if (e instanceof NavigationError) {\n        this.dispatchRouterError(e);\n      } else if (e instanceof NavigationEnd && !this.navigationTriggeredByDispatch) {\n        this.dispatchRouterSuccess();\n      }\n    });\n  }\n\n  private serializeRoute(navigationEvent: RoutesRecognized | GuardsCheckEnd | ResolveEnd): RouterState {\n    let state: ActivatedRouteSnapshot = navigationEvent.state.root;\n    while (state.firstChild) {\n      state = state.firstChild;\n    }\n    const { params, data, queryParams, fragment } = state;\n\n    return {\n      navigationId: navigationEvent.id,\n      state: {\n        url: navigationEvent.url,\n        urlAfterRedirects: navigationEvent.urlAfterRedirects,\n        params,\n        queryParams,\n        fragment,\n        data,\n        navigationExtras: this.router.getCurrentNavigation().extras ? this.router.getCurrentNavigation().extras.state : {},\n      },\n    };\n  }\n}\n"]}