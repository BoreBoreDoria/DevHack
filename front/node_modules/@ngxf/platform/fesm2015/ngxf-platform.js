import { EventEmitter, Directive, TemplateRef, ViewContainerRef, ChangeDetectorRef, Input, Output, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, isDevMode, InjectionToken, NgModuleFactoryLoader, Injector, Host, ElementRef, Pipe, ANALYZE_FOR_ENTRY_COMPONENTS, NgModule } from '@angular/core';
import { isObservable, of, from } from 'rxjs';
import { APP_BASE_HREF, NgForOf } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { catchError, tap, finalize, distinctUntilChanged } from 'rxjs/operators';
import { convertToParamMap, ActivatedRoute } from '@angular/router';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/async.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function AsyncContext() { }
if (false) {
    /** @type {?} */
    AsyncContext.prototype.$implicit;
}
/**
 * @record
 */
function SubscriptionStrategy() { }
if (false) {
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    SubscriptionStrategy.prototype.createSubscription = function (async, next, error, complete) { };
    /**
     * @param {?} subscription
     * @return {?}
     */
    SubscriptionStrategy.prototype.dispose = function (subscription) { };
}
class ObservableStrategy {
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    createSubscription(async, next, error, complete) {
        return async.subscribe(next, error, complete);
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    dispose(subscription) {
        if (subscription) {
            subscription.unsubscribe();
        }
    }
}
class PromiseStrategy {
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    createSubscription(async, next, error, complete) {
        /** @type {?} */
        const promise = async.then(next, error);
        if ('finally' in promise) {
            return ((/** @type {?} */ (promise))).finally(complete);
        }
        return promise;
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    dispose(subscription) { }
}
/** @type {?} */
const observableStrategy = new ObservableStrategy();
/** @type {?} */
const promiseStrategy = new PromiseStrategy();
/**
 * @param {?} async
 * @return {?}
 */
function resolveStrategy(async) {
    if (isObservable(async)) {
        return observableStrategy;
    }
    if (isPromise(async)) {
        return promiseStrategy;
    }
    throw new Error(`InvalidDirectiveArgument: 'async' for directive 'async'`);
}
class AsyncDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} cd
     */
    constructor(templateRef, viewContainer, cd) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.cd = cd;
        this.next = new EventEmitter();
        this.error = new EventEmitter();
        this.complete = new EventEmitter();
        this.context = { $implicit: null };
        this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.context);
        this.componentInstance = ((/** @type {?} */ (cd))).context;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('async' in changes) {
            this.onAsyncDidChanged(this.async, changes.async.previousValue);
        }
        if ('asyncFrom' in changes) {
            this.onAsyncDidChanged(this.asyncFrom, changes.asyncFrom.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose();
        this.viewContainer.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    onAsyncDidChanged(current, previous) {
        if (!this.subscription) {
            return current && this.subscribe(current);
        }
        if (current !== previous) {
            this.dispose();
            return this.onAsyncDidChanged(current, null);
        }
    }
    /**
     * @private
     * @param {?} async
     * @return {?}
     */
    subscribe(async) {
        this.strategy = resolveStrategy(async);
        this.subscription = this.strategy.createSubscription(async, (/**
         * @param {?} value
         * @return {?}
         */
        (value) => this.onNext(value)), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.onError(error)), (/**
         * @return {?}
         */
        () => this.onComplete()));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    onNext(value) {
        this.context.$implicit = value;
        this.next.emit(value);
        if (isFunction(this.asyncNext)) {
            this.asyncNext.call(this.componentInstance, value);
        }
        this.viewRef.markForCheck();
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    onError(error) {
        this.error.emit(error);
        if (isFunction(this.asyncError)) {
            this.asyncError.call(this.componentInstance, error);
        }
    }
    /**
     * @private
     * @return {?}
     */
    onComplete() {
        this.complete.next();
        if (isFunction(this.asyncComplete)) {
            this.asyncComplete.call(this.componentInstance);
        }
    }
    /**
     * @private
     * @return {?}
     */
    dispose() {
        if (this.strategy) {
            this.strategy.dispose(this.subscription);
            this.subscription = null;
            this.strategy = null;
        }
    }
}
AsyncDirective.decorators = [
    { type: Directive, args: [{ selector: '[async]' },] }
];
/** @nocollapse */
AsyncDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ChangeDetectorRef }
];
AsyncDirective.propDecorators = {
    async: [{ type: Input }],
    asyncFrom: [{ type: Input }],
    asyncNext: [{ type: Input }],
    asyncError: [{ type: Input }],
    asyncComplete: [{ type: Input }],
    next: [{ type: Output }],
    error: [{ type: Output }],
    complete: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    AsyncDirective.prototype.async;
    /** @type {?} */
    AsyncDirective.prototype.asyncFrom;
    /** @type {?} */
    AsyncDirective.prototype.asyncNext;
    /** @type {?} */
    AsyncDirective.prototype.asyncError;
    /** @type {?} */
    AsyncDirective.prototype.asyncComplete;
    /** @type {?} */
    AsyncDirective.prototype.next;
    /** @type {?} */
    AsyncDirective.prototype.error;
    /** @type {?} */
    AsyncDirective.prototype.complete;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.componentInstance;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.strategy;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.cd;
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @param {?} fields
 * @return {?}
 */
function omit(obj, fields) {
    /** @type {?} */
    const shallowCopy = Object.assign({}, obj);
    for (let i = 0; i < fields.length; i++) {
        /** @type {?} */
        const key = fields[i];
        delete shallowCopy[key];
    }
    return shallowCopy;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/recompose/composed.view.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const PARENT_CONTEXT_TOKEN = Symbol('[PARENT_CONTEXT_TOKEN]');
/**
 * @record
 */
function ComposedContext() { }
if (false) {
    /* Skipping unnamed member:
    [ PARENT_CONTEXT_TOKEN ]: TemplateRef<ComposedContext>[];*/
    /** @type {?} */
    ComposedContext.prototype.children;
    /* Skipping unhandled member: [ key: string ]: any;*/
}
/**
 * @template C
 */
class ComposedView {
    /**
     * @param {?} viewContainerRef
     * @param {?=} templateRefs
     */
    constructor(viewContainerRef, templateRefs) {
        this.viewContainerRef = viewContainerRef;
        this.templateRefs = templateRefs;
    }
    /**
     * @param {?} context
     * @return {?}
     */
    createEmbeddedView(context) {
        const [templateRef, ...tail] = this.getParentTemplateRefs();
        this.context = (/** @type {?} */ ((/** @type {?} */ (context))));
        if (tail.length > 0) {
            this.elementRef = templateRef.elementRef;
            this.context[PARENT_CONTEXT_TOKEN] = tail;
            this.context.children = new ComposedView(this.viewContainerRef, tail);
        }
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(templateRef, this.context);
        return (/** @type {?} */ ((/** @type {?} */ (this.viewRef))));
    }
    /**
     * @return {?}
     */
    markForCheck() {
        if (this.viewRef) {
            this.viewRef.markForCheck();
        }
    }
    /**
     * @return {?}
     */
    detectChanges() {
        if (this.viewRef) {
            this.viewRef.detectChanges();
        }
    }
    /**
     * @param {?} update
     * @return {?}
     */
    updateContext(update) {
        /** @type {?} */
        const parent = this.getHydratedParentContext();
        update(this.context, parent);
        this.markForCheck();
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.destroy();
        }
        this.viewRef = null;
    }
    /**
     * @private
     * @return {?}
     */
    getParentTemplateRefs() {
        if (this.templateRefs) {
            return this.templateRefs;
        }
        /** @type {?} */
        const view = ((/** @type {?} */ (this.viewContainerRef.injector))).view;
        /** @type {?} */
        const context = findParentContext(view);
        return context[PARENT_CONTEXT_TOKEN];
    }
    /**
     * @private
     * @return {?}
     */
    getHydratedParentContext() {
        /** @type {?} */
        const view = ((/** @type {?} */ (this.viewContainerRef.injector))).view;
        return omit(findParentContext(view), [PARENT_CONTEXT_TOKEN, 'children']);
    }
}
if (false) {
    /** @type {?} */
    ComposedView.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.templateRefs;
}
/**
 * @param {?} view
 * @return {?}
 */
function findParentContext(view) {
    /** @type {?} */
    const context = view.context;
    if (isParentContext(context)) {
        return context;
    }
    return findParentContext(view.parent);
}
/**
 * @param {?} context
 * @return {?}
 */
function isParentContext(context) {
    return context && PARENT_CONTEXT_TOKEN in context;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/compose.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ComposeContext() { }
if (false) {
    /** @type {?} */
    ComposeContext.prototype.$implicit;
    /** @type {?} */
    ComposeContext.prototype.compose;
}
class ComposeDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, compose: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('compose' in changes) {
            this.onTemplateRefsDidChanged(this.compose, changes.compose.previousValue);
        }
        if ('composeOf' in changes) {
            this.onTemplateRefsDidChanged(this.composeOf, changes.composeOf.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    onTemplateRefsDidChanged(current, previous) {
        if (!this.viewRef) {
            return this.create(current);
        }
        if (this.viewRef.destroyed || current !== previous) {
            this.destroy();
            return this.onTemplateRefsDidChanged(current, null);
        }
    }
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    create(templateRefs) {
        this.context.compose = this.context.$implicit = this.createComposeFn(templateRefs);
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.destroy();
        }
        this.viewRef = null;
    }
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    createComposeFn(templateRefs) {
        return (/**
         * @param {?} templateRef
         * @return {?}
         */
        (templateRef) => {
            return new ComposedView(this.viewContainerRef, [...templateRefs, templateRef]);
        });
    }
}
ComposeDirective.decorators = [
    { type: Directive, args: [{ selector: '[compose]' },] }
];
/** @nocollapse */
ComposeDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
ComposeDirective.propDecorators = {
    compose: [{ type: Input }],
    composeOf: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ComposeDirective.prototype.compose;
    /** @type {?} */
    ComposeDirective.prototype.composeOf;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/cookies.tools.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CookieOptionsArgs() { }
if (false) {
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.path;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.domain;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.expires;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.secure;
}
/**
 * @record
 */
function ICookies() { }
/**
 * @record
 */
function ICookieService() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    ICookieService.prototype.get = function (key) { };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    ICookieService.prototype.set = function (key, value, options) { };
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    ICookieService.prototype.remove = function (key, options) { };
}
class CookieOptions {
    /**
     * @param {?=} __0
     */
    constructor({ path, domain, expires, secure } = {}) {
        this.path = this.isPresent(path) ? path : null;
        this.domain = this.isPresent(domain) ? domain : null;
        this.expires = this.isPresent(expires) ? expires : null;
        this.secure = this.isPresent(secure) ? secure : false;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    merge(options) {
        return new CookieOptions((/** @type {?} */ ({
            path: this.isPresent(options) && this.isPresent(options.path) ? options.path : this.path,
            domain: this.isPresent(options) && this.isPresent(options.domain) ? options.domain : this.domain,
            expires: this.isPresent(options) && this.isPresent(options.expires) ? options.expires : this.expires,
            secure: this.isPresent(options) && this.isPresent(options.secure) ? options.secure : this.secure,
        })));
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
}
if (false) {
    /** @type {?} */
    CookieOptions.prototype.path;
    /** @type {?} */
    CookieOptions.prototype.domain;
    /** @type {?} */
    CookieOptions.prototype.expires;
    /** @type {?} */
    CookieOptions.prototype.secure;
}
class BaseCookieOptions extends CookieOptions {
    /**
     * @param {?} baseHref
     */
    constructor(baseHref) {
        super({ path: baseHref || '/' });
        this.baseHref = baseHref;
    }
}
BaseCookieOptions.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
BaseCookieOptions.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [APP_BASE_HREF,] }] }
];
/** @nocollapse */ BaseCookieOptions.ɵprov = ɵɵdefineInjectable({ factory: function BaseCookieOptions_Factory() { return new BaseCookieOptions(ɵɵinject(APP_BASE_HREF, 8)); }, token: BaseCookieOptions, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    BaseCookieOptions.prototype.baseHref;
}
class CookiesService {
    /**
     * @param {?=} defaultOptions
     */
    constructor(defaultOptions) {
        this.defaultOptions = defaultOptions;
    }
    /**
     * @protected
     * @return {?}
     */
    get cookieString() {
        return document.cookie || '';
    }
    /**
     * @protected
     * @param {?} val
     * @return {?}
     */
    set cookieString(val) {
        document.cookie = val;
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    cookieReader(key) {
        /** @type {?} */
        const currentCookieString = this.cookieString;
        if (currentCookieString) {
            /** @type {?} */
            const cookieArray = currentCookieString.split('; ');
            return cookieArray.reduce((/**
             * @param {?} cookies
             * @param {?} current
             * @return {?}
             */
            (cookies, current) => {
                /** @type {?} */
                const cookie = current.split('=');
                return Object.assign(Object.assign({}, cookies), { [cookie[0]]: decodeURIComponent(cookie[1]) });
            }), {})[key];
        }
    }
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    cookieWriter(name, value, options) {
        this.cookieString = this.buildCookieString(name, value, options);
    }
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    buildCookieString(name, value, options) {
        /** @type {?} */
        const defaultOpts = this.defaultOptions || new CookieOptions((/** @type {?} */ ({ path: '/' })));
        /** @type {?} */
        const opts = this.mergeOptions(defaultOpts, options);
        /** @type {?} */
        let expires = opts.expires;
        if (!value) {
            expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
            value = '';
        }
        if (typeof expires === 'string') {
            expires = new Date(expires);
        }
        /** @type {?} */
        let str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
        str += opts.path ? `;path=${opts.path}` : '';
        str += opts.domain ? `;domain=${opts.domain}` : '';
        str += expires ? `;expires=${expires.toUTCString()}` : '';
        str += opts.secure ? ';secure' : '';
        /** @type {?} */
        const cookieLength = str.length + 1;
        if (cookieLength > 4096) {
            console.log(`Cookie \'${name}\' possibly not set or overflowed because it was too large (${cookieLength} > 4096 bytes)!`);
        }
        return str;
    }
    /**
     * @private
     * @param {?} defaultOpts
     * @param {?=} providedOpts
     * @return {?}
     */
    mergeOptions(defaultOpts, providedOpts) {
        /** @type {?} */
        const newOpts = defaultOpts;
        if (providedOpts) {
            return newOpts.merge(new CookieOptions(providedOpts));
        }
        return newOpts;
    }
    /**
     * @param {?} key
     * @return {?}
     */
    get(key) {
        return this.cookieReader(key);
    }
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    set(key, value, options) {
        this.cookieWriter(key, value, options);
    }
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    remove(key, options) {
        this.cookieWriter(key, undefined, options);
    }
}
CookiesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CookiesService.ctorParameters = () => [
    { type: CookieOptions, decorators: [{ type: Optional }] }
];
/** @nocollapse */ CookiesService.ɵprov = ɵɵdefineInjectable({ factory: function CookiesService_Factory() { return new CookiesService(ɵɵinject(CookieOptions, 8)); }, token: CookiesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookiesService.prototype.defaultOptions;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/cookies.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const CookiesStrategies = {
    GET: "get",
    SET: "set",
    REMOVE: "remove",
};
/**
 * @record
 */
function CookiesContext() { }
if (false) {
    /** @type {?} */
    CookiesContext.prototype.$implicit;
    /** @type {?} */
    CookiesContext.prototype.data;
}
/**
 * @record
 */
function CookiesStrategy() { }
if (false) {
    /** @type {?} */
    CookiesStrategy.prototype.type;
    /** @type {?} */
    CookiesStrategy.prototype.changes;
    /** @type {?} */
    CookiesStrategy.prototype.require;
}
/** @type {?} */
const COOKIES_CONFIG = [
    {
        type: CookiesStrategies.GET,
        changes: ['cookiesGet'],
        require: ['cookiesGet']
    },
    {
        type: CookiesStrategies.SET,
        changes: [
            'cookiesSet',
            'cookiesValue',
            'cookiesPath',
            'cookiesDomain',
            'cookiesExpires',
            'cookiesSecure'
        ],
        require: ['cookiesSet']
    },
    {
        type: CookiesStrategies.REMOVE,
        changes: ['cookiesRemove', 'cookiesPath', 'cookiesDomain'],
        require: ['cookiesRemove']
    }
];
class CookiesDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     * @param {?} cookiesService
     */
    constructor(templateRef, viewContainerRef, cookiesService) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.cookiesService = cookiesService;
        this.context = {
            $implicit: null,
            /**
             * @return {?}
             */
            get data() { return this.$implicit; }
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const strategy = this.findStrategy(changes);
        if (strategy) {
            this.execute(strategy);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    findStrategy(changes) {
        return COOKIES_CONFIG.find((/**
         * @param {?} strategy
         * @return {?}
         */
        (strategy) => {
            return strategy.changes.some((/**
             * @param {?} field
             * @return {?}
             */
            field => !!changes[field]))
                && strategy.require.every((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => !!this[field]));
        }));
    }
    /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    execute(strategy) {
        /** @type {?} */
        const options = strategy.changes.map((/**
         * @param {?} field
         * @return {?}
         */
        field => this[field]));
        this.action(strategy.type, ...options);
    }
    /**
     * @private
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    action(type, ...options) {
        /** @type {?} */
        const name = options[0];
        /** @type {?} */
        const value = options[1];
        /** @type {?} */
        const cookieOptions = {
            path: options[2],
            domain: options[3],
            expires: options[4],
            secure: !!options[5]
        };
        if (CookiesStrategies.GET === type) {
            this.context.$implicit = this.getCookie(name);
        }
        if (CookiesStrategies.SET === type) {
            this.setCookie(name, value, cookieOptions);
            this.context.$implicit = value;
        }
        if (CookiesStrategies.REMOVE === type) {
            this.removeCookie(name, cookieOptions);
            this.context.$implicit = null;
        }
        this.viewRef.markForCheck();
    }
    /**
     * @private
     * @param {?} name
     * @return {?}
     */
    getCookie(name) {
        return this.cookiesService.get(name);
    }
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    setCookie(name, value, options) {
        this.cookiesService.set(name, value, options);
    }
    /**
     * @private
     * @param {?} name
     * @param {?=} options
     * @return {?}
     */
    removeCookie(name, options) {
        this.cookiesService.remove(name, options);
    }
}
CookiesDirective.decorators = [
    { type: Directive, args: [{ selector: '[cookies]' },] }
];
/** @nocollapse */
CookiesDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: CookiesService }
];
CookiesDirective.propDecorators = {
    cookiesGet: [{ type: Input }],
    cookiesSet: [{ type: Input }],
    cookiesRemove: [{ type: Input }],
    cookiesValue: [{ type: Input }],
    cookiesPath: [{ type: Input }],
    cookiesDomain: [{ type: Input }],
    cookiesExpires: [{ type: Input }],
    cookiesSecure: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesGet;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesSet;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesRemove;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesValue;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesPath;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesDomain;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesExpires;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesSecure;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/http.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
const HttpStrategies = {
    DELETE: "delete",
    GET: "get",
    HEAD: "head",
    JSONP: "jsonp",
    OPTIONS: "options",
    PATCH: "patch",
    POST: "post",
    PUT: "put",
};
/**
 * @record
 */
function HttpContext() { }
if (false) {
    /** @type {?} */
    HttpContext.prototype.$implicit;
    /** @type {?} */
    HttpContext.prototype.data;
}
/**
 * @record
 */
function HttpStrategy() { }
if (false) {
    /** @type {?} */
    HttpStrategy.prototype.type;
    /** @type {?} */
    HttpStrategy.prototype.changes;
    /** @type {?} */
    HttpStrategy.prototype.require;
}
/** @type {?} */
const HTTP_CONFIG = [
    {
        type: HttpStrategies.DELETE,
        changes: ['httpDelete', 'httpWith'],
        require: ['httpDelete']
    },
    {
        type: HttpStrategies.GET,
        changes: ['httpGet', 'httpWith'],
        require: ['httpGet']
    },
    {
        type: HttpStrategies.HEAD,
        changes: ['httpHead', 'httpWith'],
        require: ['httpHead']
    },
    {
        type: HttpStrategies.JSONP,
        changes: ['httpJsonp', 'httpCallback'],
        require: ['httpJsonp', 'httpCallback']
    },
    {
        type: HttpStrategies.OPTIONS,
        changes: ['httpOptions', 'httpWith'],
        require: ['httpOptions']
    },
    {
        type: HttpStrategies.PATCH,
        changes: ['httpPatch', 'httpSend', 'httpWith'],
        require: ['httpPatch']
    },
    {
        type: HttpStrategies.POST,
        changes: ['httpPost', 'httpSend', 'httpWith'],
        require: ['httpPost']
    },
    {
        type: HttpStrategies.PUT,
        changes: ['httpPut', 'httpSend', 'httpWith'],
        require: ['httpPut']
    }
];
class HttpDirective {
    /**
     * @param {?} http
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(http, templateRef, viewContainerRef) {
        this.http = http;
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null,
            /**
             * @return {?}
             */
            get data() { return this.$implicit; }
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const strategy = this.findStrategy(changes);
        if (strategy) {
            this.execute(strategy);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose();
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    findStrategy(changes) {
        return HTTP_CONFIG.find((/**
         * @param {?} strategy
         * @return {?}
         */
        (strategy) => {
            return strategy.changes.some((/**
             * @param {?} field
             * @return {?}
             */
            field => !!changes[field]))
                && strategy.require.every((/**
                 * @param {?} field
                 * @return {?}
                 */
                field => !!this[field]));
        }));
    }
    /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    execute(strategy) {
        /** @type {?} */
        const params = strategy.changes.map((/**
         * @param {?} field
         * @return {?}
         */
        field => this[field]));
        this.request(strategy.type, ...params);
    }
    /**
     * @private
     * @param {?} method
     * @param {...?} params
     * @return {?}
     */
    request(method, ...params) {
        this.dispose();
        this.subscription = this.http[method](...params)
            .pipe(catchError((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            console.error(e);
            return of(null);
        })))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            this.context.$implicit = data;
            this.viewRef.markForCheck();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    dispose() {
        if (this.subscription && !this.subscription.closed) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
}
HttpDirective.decorators = [
    { type: Directive, args: [{ selector: '[http]' },] }
];
/** @nocollapse */
HttpDirective.ctorParameters = () => [
    { type: HttpClient },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
HttpDirective.propDecorators = {
    httpDelete: [{ type: Input }],
    httpGet: [{ type: Input }],
    httpHead: [{ type: Input }],
    httpJsonp: [{ type: Input }],
    httpOptions: [{ type: Input }],
    httpPatch: [{ type: Input }],
    httpPost: [{ type: Input }],
    httpPut: [{ type: Input }],
    httpSend: [{ type: Input }],
    httpCallback: [{ type: Input }],
    httpWith: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    HttpDirective.prototype.httpDelete;
    /** @type {?} */
    HttpDirective.prototype.httpGet;
    /** @type {?} */
    HttpDirective.prototype.httpHead;
    /** @type {?} */
    HttpDirective.prototype.httpJsonp;
    /** @type {?} */
    HttpDirective.prototype.httpOptions;
    /** @type {?} */
    HttpDirective.prototype.httpPatch;
    /** @type {?} */
    HttpDirective.prototype.httpPost;
    /** @type {?} */
    HttpDirective.prototype.httpPut;
    /** @type {?} */
    HttpDirective.prototype.httpSend;
    /** @type {?} */
    HttpDirective.prototype.httpCallback;
    /** @type {?} */
    HttpDirective.prototype.httpWith;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.http;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/init.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function InitContext() { }
if (false) {
    /** @type {?} */
    InitContext.prototype.$implicit;
    /** @type {?} */
    InitContext.prototype.init;
}
/**
 * @template T
 */
class InitDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     */
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.context = { $implicit: null, init: null };
        this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set init(value) {
        this.setValue(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set initOf(value) {
        this.setValue(value);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.viewContainer.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    setValue(value) {
        this.context.$implicit = this.context.init = value;
        if (this.viewRef) {
            this.viewRef.markForCheck();
        }
    }
}
InitDirective.decorators = [
    { type: Directive, args: [{ selector: '[init]' },] }
];
/** @nocollapse */
InitDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
InitDirective.propDecorators = {
    init: [{ type: Input }],
    initOf: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.viewContainer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/is-dev-mode.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DevModeService {
    constructor() {
    }
    /**
     * @return {?}
     */
    isDevMode() {
        return isDevMode();
    }
}
DevModeService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
DevModeService.ctorParameters = () => [];
/** @nocollapse */ DevModeService.ɵprov = ɵɵdefineInjectable({ factory: function DevModeService_Factory() { return new DevModeService(); }, token: DevModeService, providedIn: "root" });
class IsDevModeDirective {
    /**
     * @param {?} devModeService
     * @param {?} viewContainerRef
     * @param {?} templateRef
     */
    constructor(devModeService, viewContainerRef, templateRef) {
        if (devModeService.isDevMode()) {
            viewContainerRef.createEmbeddedView(templateRef);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
IsDevModeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[isDevMode]'
            },] }
];
/** @nocollapse */
IsDevModeDirective.ctorParameters = () => [
    { type: DevModeService },
    { type: ViewContainerRef },
    { type: TemplateRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IsDevModeDirective.prototype.viewRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/keep-alive.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const KeepAliveFlags = {
    Detached: 0,
    Attached: 1,
};
class ViewRefAttachable {
    /**
     * @param {?} viewRef
     */
    constructor(viewRef) {
        this.flag = 0 /* Detached */;
        this.viewRef = viewRef;
    }
    /**
     * @return {?}
     */
    get attached() {
        return this.flag === 1 /* Attached */;
    }
    /**
     * @return {?}
     */
    get detached() {
        return this.flag === 0 /* Detached */;
    }
    /**
     * @param {?} viewContainer
     * @return {?}
     */
    attachToViewContainerRef(viewContainer) {
        if (this.viewContainerRef || this.attached) {
            throw new TypeError(`You can't use *keepAlive with *ngFor:
  <ng-container *ngFor="...">
    <!-- Wrong! -->
    <ng-container *keepAlive></ng-container>
  </ng-container>

viewRef already attached to viewContainerRef`);
        }
        this.flag = 1 /* Attached */;
        (this.viewContainerRef = viewContainer).insert(this.viewRef);
    }
    /**
     * @return {?}
     */
    detachFromViewContainerRef() {
        if (!this.viewContainerRef || this.detached) {
            throw new TypeError('viewRef already detached from viewContainerRef');
        }
        this.flag = 0 /* Detached */;
        this.viewContainerRef.detach(this.viewContainerRef.indexOf(this.viewRef));
        delete this.viewContainerRef;
    }
    /**
     * @return {?}
     */
    destroy() {
        this.viewRef.destroy();
    }
}
if (false) {
    /** @type {?} */
    ViewRefAttachable.prototype.viewRef;
    /** @type {?} */
    ViewRefAttachable.prototype.flag;
    /** @type {?} */
    ViewRefAttachable.prototype.viewContainerRef;
}
class KeepAliveConfig {
    constructor() {
        this.limit = 50;
    }
}
KeepAliveConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ KeepAliveConfig.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveConfig_Factory() { return new KeepAliveConfig(); }, token: KeepAliveConfig, providedIn: "root" });
if (false) {
    /** @type {?} */
    KeepAliveConfig.prototype.limit;
}
class KeepAliveGC {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * @param {?} viewRefs
     * @return {?}
     */
    collect(viewRefs) {
        /** @type {?} */
        const limit = this.config.limit > 0 ? this.config.limit : Number.MAX_SAFE_INTEGER;
        for (const [templateDef, viewRefAttachable] of Array.from(viewRefs.entries())) {
            if (viewRefs.size <= limit) {
                break;
            }
            if (viewRefAttachable.flag === 0 /* Detached */) {
                viewRefAttachable.destroy();
                viewRefs.delete(templateDef);
                console.log('Collect', viewRefAttachable);
            }
        }
    }
}
KeepAliveGC.decorators = [
    { type: Injectable, args: [{ providedIn: 'root', },] }
];
/** @nocollapse */
KeepAliveGC.ctorParameters = () => [
    { type: KeepAliveConfig }
];
/** @nocollapse */ KeepAliveGC.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveGC_Factory() { return new KeepAliveGC(ɵɵinject(KeepAliveConfig)); }, token: KeepAliveGC, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveGC.prototype.config;
}
class KeepAliveViewRefs {
    /**
     * @param {?} gc
     */
    constructor(gc) {
        this.gc = gc;
        this.viewRefs = new Map();
    }
    /**
     * @param {?} templateRef
     * @param {?} viewRef
     * @return {?}
     */
    add(templateRef, viewRef) {
        /** @type {?} */
        const templateDef = this.getTemplateDef(templateRef);
        if (this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef already exists in viewRefs');
        }
        /** @type {?} */
        const viewRefAttachable = new ViewRefAttachable(viewRef);
        this.viewRefs.set(templateDef, viewRefAttachable);
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    has(templateRef) {
        /** @type {?} */
        const templateDef = this.getTemplateDef(templateRef);
        return this.viewRefs.has(templateDef);
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    get(templateRef) {
        /** @type {?} */
        const templateDef = this.getTemplateDef(templateRef);
        if (!this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef not exists in viewRefs');
        }
        return this.viewRefs.get(templateDef);
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    delete(templateRef) {
        /** @type {?} */
        const templateDef = this.getTemplateDef(templateRef);
        if (!this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef not exists in viewRefs');
        }
        this.viewRefs.get(templateRef).viewRef.destroy();
        return this.viewRefs.delete(templateDef);
    }
    /**
     * @param {?} templateRef
     * @return {?}
     */
    reattach(templateRef) {
        /** @type {?} */
        const templateDef = this.getTemplateDef(templateRef);
        /** @type {?} */
        const viewRefAttachable = this.get(templateRef);
        this.viewRefs.set(templateDef, viewRefAttachable);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.viewRefs.forEach((/**
         * @param {?} viewRefAttachable
         * @return {?}
         */
        (viewRefAttachable) => viewRefAttachable.viewRef.destroy()));
        this.viewRefs.clear();
    }
    /**
     * @return {?}
     */
    collect() {
        this.gc.collect(this.viewRefs);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    forEach(fn) {
        this.viewRefs.forEach(fn);
    }
    /**
     * @private
     * @param {?} templateRef
     * @return {?}
     */
    getTemplateDef(templateRef) {
        return templateRef['_def'];
    }
}
KeepAliveViewRefs.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
KeepAliveViewRefs.ctorParameters = () => [
    { type: KeepAliveGC }
];
/** @nocollapse */ KeepAliveViewRefs.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveViewRefs_Factory() { return new KeepAliveViewRefs(ɵɵinject(KeepAliveGC)); }, token: KeepAliveViewRefs, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveViewRefs.prototype.viewRefs;
    /**
     * @type {?}
     * @private
     */
    KeepAliveViewRefs.prototype.gc;
}
class KeepAliveManager {
    /**
     * @param {?} viewRefs
     */
    constructor(viewRefs) {
        this.viewRefs = viewRefs;
    }
    /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    attach(viewContainerRef, templateRef) {
        if (!this.viewRefs.has(templateRef)) {
            /** @type {?} */
            const viewRef = templateRef.createEmbeddedView({});
            this.viewRefs.add(templateRef, viewRef);
        }
        else {
            this.viewRefs.reattach(templateRef);
        }
        this.patchClear(viewContainerRef);
        /** @type {?} */
        const viewRefAttachable = this.viewRefs.get(templateRef);
        viewRefAttachable.attachToViewContainerRef(viewContainerRef);
        this.viewRefs.collect();
    }
    /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    detach(viewContainerRef, templateRef) {
        /** @type {?} */
        const viewRefAttachable = this.viewRefs.get(templateRef);
        viewRefAttachable.detachFromViewContainerRef();
        this.viewRefs.collect();
    }
    /**
     * @private
     * @param {?} viewContainerRef
     * @return {?}
     */
    patchClear(viewContainerRef) {
        if (!viewContainerRef[KeepAliveManager.patched]) {
            /** @type {?} */
            const clear = Object.getPrototypeOf(viewContainerRef).clear;
            /** @type {?} */
            const viewRefs = this.viewRefs;
            Object.getPrototypeOf(viewContainerRef).clear = (/**
             * @this {?}
             * @return {?}
             */
            function () {
                viewRefs.forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => { v.viewRef['_view'].state |= (1 << 7); }));
                clear.call(this);
                viewRefs.forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => { v.viewRef['_view'].state &= ~(1 << 7); }));
            });
            Object.defineProperty(viewContainerRef, KeepAliveManager.patched, { get: (/**
                 * @return {?}
                 */
                () => true) });
        }
    }
}
KeepAliveManager.patched = Symbol('Already Patched ViewContainerRef Token');
KeepAliveManager.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
KeepAliveManager.ctorParameters = () => [
    { type: KeepAliveViewRefs }
];
/** @nocollapse */ KeepAliveManager.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveManager_Factory() { return new KeepAliveManager(ɵɵinject(KeepAliveViewRefs)); }, token: KeepAliveManager, providedIn: "root" });
if (false) {
    /** @type {?} */
    KeepAliveManager.patched;
    /**
     * @type {?}
     * @private
     */
    KeepAliveManager.prototype.viewRefs;
}
class KeepAliveDirective {
    /**
     * @param {?} manager
     * @param {?} viewContainerRef
     * @param {?} templateRef
     */
    constructor(manager, viewContainerRef, templateRef) {
        this.manager = manager;
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        manager.attach(viewContainerRef, templateRef);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.manager.detach(this.viewContainerRef, this.templateRef);
    }
}
KeepAliveDirective.decorators = [
    { type: Directive, args: [{
                selector: '[keepAlive]'
            },] }
];
/** @nocollapse */
KeepAliveDirective.ctorParameters = () => [
    { type: KeepAliveManager },
    { type: ViewContainerRef },
    { type: TemplateRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.manager;
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.templateRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/lazy.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LazyContext() { }
if (false) {
    /** @type {?} */
    LazyContext.prototype.$implicit;
}
/** @type {?} */
const LAZY_COMPONENT_TOKEN = new InjectionToken('Lazy Component Token');
class LazyDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     * @param {?} loader
     * @param {?} injector
     */
    constructor(templateRef, viewContainer, loader, injector) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.loader = loader;
        this.injector = injector;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.context = {
            $implicit: null
        };
        this.embeddedViewRef = this.templateRef.createEmbeddedView(this.context);
    }
    /**
     * @private
     * @return {?}
     */
    get component() {
        if (this.componentRef) {
            return this.componentRef.instance;
        }
    }
    /**
     * @private
     * @return {?}
     */
    get projectableNodes() {
        return [this.templateRef.createEmbeddedView(this.context).rootNodes];
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('lazy' in changes) {
            this.onLazyDidChanged(this.lazy, changes.lazy.previousValue);
        }
        if ('lazyLoadChildren' in changes) {
            this.onLazyDidChanged(this.lazyLoadChildren, changes.lazyLoadChildren.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose();
        if (this.embeddedViewRef) {
            this.embeddedViewRef.destroy();
            this.embeddedViewRef = null;
        }
    }
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    onLazyDidChanged(current, previous) {
        if (!this.ngModuleRef) {
            return current && this.loadAndRender(current);
        }
        if (current !== previous) {
            this.dispose();
            return this.onLazyDidChanged(current, null);
        }
    }
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    loadAndRender(path) {
        this.subscription = this.load(path).pipe(tap((/**
         * @param {?} ngModuleFactory
         * @return {?}
         */
        (ngModuleFactory) => {
            this.ngModuleRef = ngModuleFactory.create(this.injector);
            /** @type {?} */
            const component = this.ngModuleRef.injector.get(LAZY_COMPONENT_TOKEN);
            /** @type {?} */
            const componentFactory = this.ngModuleRef.componentFactoryResolver.resolveComponentFactory(component);
            this.componentRef = this.viewContainer.createComponent(componentFactory, this.viewContainer.length, this.injector, this.projectableNodes, this.ngModuleRef);
        })), finalize((/**
         * @return {?}
         */
        () => this.onActivate(this.component)))).subscribe();
    }
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    load(path) {
        /** @type {?} */
        const pathProduction = path.split('#').join('.ts#');
        return from(this.loader.load(pathProduction)).pipe(catchError((/**
         * @return {?}
         */
        () => from(this.loader.load(path)))));
    }
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    onActivate(component) {
        this.activate.emit(component);
        if (isFunction$1(this.lazyActivate)) {
            this.lazyActivate(component);
        }
        this.context.$implicit = component;
        this.embeddedViewRef.markForCheck();
    }
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    onDeactivate(component) {
        this.deactivate.emit(component);
        if (isFunction$1(this.lazyDeactivate)) {
            this.lazyDeactivate(component);
        }
        this.context.$implicit = null;
        this.embeddedViewRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    dispose() {
        if (this.componentRef) {
            /** @type {?} */
            const c = this.component;
            this.componentRef.destroy();
            this.componentRef = null;
            this.onDeactivate(c);
        }
        if (this.ngModuleRef) {
            this.ngModuleRef.destroy();
            this.ngModuleRef = null;
        }
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    }
}
LazyDirective.decorators = [
    { type: Directive, args: [{ selector: '[lazy]' },] }
];
/** @nocollapse */
LazyDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: NgModuleFactoryLoader },
    { type: Injector }
];
LazyDirective.propDecorators = {
    lazy: [{ type: Input }],
    lazyLoadChildren: [{ type: Input }],
    lazyActivate: [{ type: Input }],
    lazyDeactivate: [{ type: Input }],
    activate: [{ type: Output }],
    deactivate: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    LazyDirective.prototype.lazy;
    /** @type {?} */
    LazyDirective.prototype.lazyLoadChildren;
    /** @type {?} */
    LazyDirective.prototype.lazyActivate;
    /** @type {?} */
    LazyDirective.prototype.lazyDeactivate;
    /** @type {?} */
    LazyDirective.prototype.activate;
    /** @type {?} */
    LazyDirective.prototype.deactivate;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.componentRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.ngModuleRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.injector;
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction$1(value) {
    return typeof value === 'function';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/nest.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NestContext() { }
if (false) {
    /** @type {?} */
    NestContext.prototype.$implicit;
    /** @type {?} */
    NestContext.prototype.nest;
}
class NestDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, nest: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('nest' in changes) {
            this.onTemplatesDidChanged(this.nest, changes.nest.previousValue);
        }
        if ('nestOf' in changes) {
            this.onTemplatesDidChanged(this.nestOf, changes.nestOf.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    onTemplatesDidChanged(current, previous) {
        if (!this.context.$implicit) {
            return current && this.create(current);
        }
        if (current !== previous) {
            this.destroy();
            this.onTemplatesDidChanged(current, null);
        }
    }
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    create(templateRefs) {
        this.context.$implicit = this.context.nest = new ComposedView(this.viewContainerRef, templateRefs);
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    update(templateRefs) {
        this.context.$implicit = this.context.nest = new ComposedView(this.viewContainerRef, templateRefs);
        this.viewRef.markForCheck();
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
NestDirective.decorators = [
    { type: Directive, args: [{ selector: '[nest]' },] }
];
/** @nocollapse */
NestDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
NestDirective.propDecorators = {
    nest: [{ type: Input }],
    nestOf: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NestDirective.prototype.nest;
    /** @type {?} */
    NestDirective.prototype.nestOf;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/rename-prop.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function RenamePropContext() { }
if (false) {
    /** @type {?} */
    RenamePropContext.prototype.$implicit;
}
class RenamePropDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('renameProp' in changes && 'renamePropTo' in changes) {
            this.onRenameDidChanged(this.renameProp, this.renamePropTo, changes.renameProp.previousValue, changes.renamePropTo.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @param {?} fromPrevious
     * @param {?} toPrevious
     * @return {?}
     */
    onRenameDidChanged(from, to, fromPrevious, toPrevious) {
        if (!this.composedView) {
            this.create();
        }
        if (from !== fromPrevious || to !== toPrevious) {
            this.rename(from, to);
        }
    }
    /**
     * @private
     * @return {?}
     */
    create() {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
    }
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    rename(from, to) {
        this.composedView.updateContext((/**
         * @param {?} context
         * @param {?} parent
         * @return {?}
         */
        (context, parent) => {
            return Object.assign(context, omit(parent, [from]), { [to]: parent[from] });
        }));
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        this.viewContainerRef.clear();
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    }
}
RenamePropDirective.decorators = [
    { type: Directive, args: [{ selector: '[renameProp]' },] }
];
/** @nocollapse */
RenamePropDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
RenamePropDirective.propDecorators = {
    renameProp: [{ type: Input }],
    renamePropTo: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    RenamePropDirective.prototype.renameProp;
    /** @type {?} */
    RenamePropDirective.prototype.renamePropTo;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/repeat.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RepeatContext {
}
if (false) {
    /** @type {?} */
    RepeatContext.prototype.$implicit;
    /** @type {?} */
    RepeatContext.prototype.repeat;
    /** @type {?} */
    RepeatContext.prototype.index;
}
class RepeatDirective {
    /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     */
    constructor(viewContainerRef, templateRef) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
    }
    /**
     * @return {?}
     */
    get count() {
        /** @type {?} */
        const count = isNumber(this.repeat) ? this.repeat :
            isNumber(this.repeatOf) ? this.repeatOf : 0;
        return Math.max(count, 0);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('repeat' in changes || 'repeatOf' in changes) {
            this.onRepeatChanged(this.count);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.viewContainerRef.clear();
    }
    /**
     * @private
     * @param {?} count
     * @return {?}
     */
    onRepeatChanged(count) {
        /** When we need to create new items */
        for (let i = this.viewContainerRef.length; i < count; i++) {
            this.viewContainerRef.createEmbeddedView(this.templateRef, {
                $implicit: i, index: i, repeat: i
            }, i);
        }
        /** When we need to remove old items */
        for (let i = this.viewContainerRef.length; i > count; i--) {
            this.viewContainerRef.remove(i - 1);
        }
    }
}
RepeatDirective.decorators = [
    { type: Directive, args: [{ selector: '[repeat]' },] }
];
/** @nocollapse */
RepeatDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef }
];
RepeatDirective.propDecorators = {
    repeat: [{ type: Input }],
    repeatOf: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    RepeatDirective.prototype.repeat;
    /** @type {?} */
    RepeatDirective.prototype.repeatOf;
    /**
     * @type {?}
     * @private
     */
    RepeatDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    RepeatDirective.prototype.templateRef;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber(value) {
    return typeof value === 'number';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/return.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ReturnContext() { }
if (false) {
    /** @type {?} */
    ReturnContext.prototype.$implicit;
}
class ReturnDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('return' in changes) {
            if (!this.composedView) {
                this.create();
            }
            else {
                this.update();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    create() {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
        this.update();
    }
    /**
     * @private
     * @return {?}
     */
    update() {
        this.composedView.updateContext((/**
         * @param {?} context
         * @return {?}
         */
        (context) => {
            return Object.assign(context, this.return);
        }));
    }
}
ReturnDirective.decorators = [
    { type: Directive, args: [{ selector: '[return]' },] }
];
/** @nocollapse */
ReturnDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
ReturnDirective.propDecorators = {
    return: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    ReturnDirective.prototype.return;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/route.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function RouteContext() { }
if (false) {
    /** @type {?} */
    RouteContext.prototype.$implicit;
    /** @type {?} */
    RouteContext.prototype.snapshot;
    /** @type {?} */
    RouteContext.prototype.url;
    /** @type {?} */
    RouteContext.prototype.params;
    /** @type {?} */
    RouteContext.prototype.queryParams;
    /** @type {?} */
    RouteContext.prototype.fragment;
    /** @type {?} */
    RouteContext.prototype.data;
    /** @type {?} */
    RouteContext.prototype.outlet;
    /** @type {?} */
    RouteContext.prototype.component;
    /** @type {?} */
    RouteContext.prototype.routeConfig;
    /** @type {?} */
    RouteContext.prototype.root;
    /** @type {?} */
    RouteContext.prototype.parent;
    /** @type {?} */
    RouteContext.prototype.firstChild;
    /** @type {?} */
    RouteContext.prototype.children;
    /** @type {?} */
    RouteContext.prototype.pathFromRoot;
    /** @type {?} */
    RouteContext.prototype.paramMap;
    /** @type {?} */
    RouteContext.prototype.queryParamMap;
}
/** @type {?} */
const ASYNC_FIELDS = ['url', 'params', 'queryParams', 'fragment', 'data', 'paramMap', 'queryParamMap'];
class RouteDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     * @param {?} route
     */
    constructor(templateRef, viewContainerRef, route) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.route = route;
        this.context = {
            $implicit: this.route,
            /**
             * @return {?}
             */
            get snapshot() { return this.route.snapshot; },
            url: [],
            params: {},
            queryParams: {},
            fragment: null,
            data: null,
            /**
             * @return {?}
             */
            get outlet() { return this.route.outlet; },
            /**
             * @return {?}
             */
            get component() { return this.route.component; },
            /**
             * @return {?}
             */
            get routeConfig() { return this.route.routeConfig; },
            /**
             * @return {?}
             */
            get root() { return this.route.root; },
            /**
             * @return {?}
             */
            get parent() { return this.route.parent; },
            /**
             * @return {?}
             */
            get firstChild() { return this.route.firstChild; },
            /**
             * @return {?}
             */
            get children() { return this.route.children; },
            /**
             * @return {?}
             */
            get pathFromRoot() { return this.route.pathFromRoot; },
            paramMap: convertToParamMap({}),
            queryParamMap: convertToParamMap({})
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
        this.subscriptions = this.attachFields(ASYNC_FIELDS);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        (subscription) => {
            subscription.unsubscribe();
        }));
        this.subscriptions = null;
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
    /**
     * @private
     * @param {?} asyncFields
     * @return {?}
     */
    attachFields(asyncFields) {
        return asyncFields.map((/**
         * @param {?} field
         * @return {?}
         */
        field => this.asyncAttach(field)));
    }
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    asyncAttach(field) {
        return this.route[field]
            .pipe(distinctUntilChanged())
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.context[field] = value;
            this.viewRef.markForCheck();
        }));
    }
}
RouteDirective.decorators = [
    { type: Directive, args: [{ selector: '[route]' },] }
];
/** @nocollapse */
RouteDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ActivatedRoute }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.route;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/set-props.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SetPropsContext() { }
if (false) {
    /** @type {?} */
    SetPropsContext.prototype.$implicit;
    /** @type {?} */
    SetPropsContext.prototype.setProps;
}
class SetPropsDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, setProps: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('setProps' in changes) {
            this.onPropsDidChanged(this.setProps, changes.setProps.previousValue);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    onPropsDidChanged(current, previous) {
        if (!this.context.$implicit) {
            return current && this.create(current);
        }
        if (current !== previous) {
            this.destroy();
            return this.onPropsDidChanged(current, null);
        }
    }
    /**
     * @private
     * @param {?} props
     * @return {?}
     */
    create(props) {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
        this.composedView.updateContext((/**
         * @param {?} context
         * @param {?} parent
         * @return {?}
         */
        (context, parent) => {
            return Object.assign(context, parent, props);
        }));
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        this.viewContainerRef.clear();
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    }
}
SetPropsDirective.decorators = [
    { type: Directive, args: [{ selector: '[setProps]' },] }
];
/** @nocollapse */
SetPropsDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
SetPropsDirective.propDecorators = {
    setProps: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    SetPropsDirective.prototype.setProps;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/timeout.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimeoutDirective {
    /**
     * @param {?} templateRef
     * @param {?} viewContainerRef
     */
    constructor(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    set timeout(milliseconds) {
        this.dispose();
        if (isNumber$1(milliseconds)) {
            this.create(milliseconds);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dispose();
        this.viewContainerRef.clear();
    }
    /**
     * @private
     * @param {?} milliseconds
     * @return {?}
     */
    create(milliseconds) {
        this.timeoutId = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.viewContainerRef) {
                this.viewContainerRef.createEmbeddedView(this.templateRef);
            }
        }), milliseconds);
    }
    /**
     * @private
     * @return {?}
     */
    dispose() {
        this.viewContainerRef.clear();
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }
}
TimeoutDirective.decorators = [
    { type: Directive, args: [{ selector: '[timeout]' },] }
];
/** @nocollapse */
TimeoutDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
TimeoutDirective.propDecorators = {
    timeout: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.timeoutId;
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.viewContainerRef;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber$1(value) {
    return typeof value === 'number';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/track-by-key.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class NgForTrackByKeyDirective {
    /**
     * @param {?} ngFor
     * @param {?} viewContainerRef
     */
    constructor(ngFor, viewContainerRef) {
        this.ngFor = ngFor;
        this.viewContainerRef = viewContainerRef;
        if (!ngFor) {
            throw new Error('TrackByKey should use with *ngFor!');
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('ngForTrackByKey' in changes) {
            /** @type {?} */
            const key = this.ngForTrackByKey;
            if (key) {
                this.ngFor.ngForTrackBy = (/**
                 * @param {?} index
                 * @param {?} item
                 * @return {?}
                 */
                (index, item) => item[key]);
            }
            else {
                this.ngFor.ngForTrackBy = undefined;
            }
            this.ngFor['_differ'] = null;
            this.ngFor['_ngForOfDirty'] = true;
            this.viewContainerRef.clear();
            this.ngFor.ngDoCheck();
        }
    }
}
NgForTrackByKeyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngForTrackByKey]'
            },] }
];
/** @nocollapse */
NgForTrackByKeyDirective.ctorParameters = () => [
    { type: NgForOf, decorators: [{ type: Host }, { type: Optional }] },
    { type: ViewContainerRef }
];
NgForTrackByKeyDirective.propDecorators = {
    ngForTrackByKey: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgForTrackByKeyDirective.prototype.ngForTrackByKey;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.ngFor;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-effect.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class UseEffectDirective {
    /**
     * @param {?} templateRef
     * @param {?} vcr
     */
    constructor(templateRef, vcr) {
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = {};
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useEffect && this.useEffect) {
            this.destroy();
            this.init();
        }
        else if (changes.useEffectOn) {
            if (Array.isArray(this.useEffectOn)) {
                /** @type {?} */
                const previous = changes.useEffectOn.previousValue || [];
                /** @type {?} */
                const current = changes.useEffectOn.currentValue || [];
                /** @type {?} */
                const isChanged = !previous.every((/**
                 * @param {?} item
                 * @param {?} index
                 * @return {?}
                 */
                (item, index) => current[index] === item));
                if (isChanged) {
                    this.destroy();
                    this.init();
                }
            }
            else {
                this.destroy();
                this.init();
            }
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!Array.isArray(this.useEffectOn)) {
            this.destroy();
            this.init();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        this.viewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
        if (this.useEffect) {
            this.onDestroyCallback = this.useEffect();
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.onDestroyCallback) {
            this.onDestroyCallback();
            this.onDestroyCallback = null;
        }
        this.vcr.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
UseEffectDirective.decorators = [
    { type: Directive, args: [{
                selector: '[useEffect]'
            },] }
];
/** @nocollapse */
UseEffectDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
UseEffectDirective.propDecorators = {
    useEffect: [{ type: Input }],
    useEffectOn: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.context;
    /** @type {?} */
    UseEffectDirective.prototype.useEffect;
    /** @type {?} */
    UseEffectDirective.prototype.useEffectOn;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.onDestroyCallback;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-reducer.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Action() { }
if (false) {
    /** @type {?} */
    Action.prototype.type;
    /** @type {?} */
    Action.prototype.payload;
}
/**
 * @record
 * @template T
 */
function UseReducerImplicitContext() { }
if (false) {
    /** @type {?} */
    UseReducerImplicitContext.prototype.state;
    /** @type {?} */
    UseReducerImplicitContext.prototype.dispatch;
    /** @type {?} */
    UseReducerImplicitContext.prototype.reducer;
    /** @type {?} */
    UseReducerImplicitContext.prototype.detectChanges;
}
/**
 * @record
 * @template T
 */
function UseReducerContext() { }
if (false) {
    /** @type {?} */
    UseReducerContext.prototype.$implicit;
}
class UseReducerDirective {
    /**
     * @param {?} templateRef
     * @param {?} vcr
     */
    constructor(templateRef, vcr) {
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = {
            $implicit: {
                state: null,
                /**
                 * @param {?} action
                 * @return {?}
                 */
                dispatch(action) {
                    this.state = this.reducer(this.state, action);
                    this.detectChanges();
                },
                reducer: ((/**
                 * @return {?}
                 */
                () => { })),
                detectChanges: (/**
                 * @return {?}
                 */
                () => {
                    this.embeddedViewRef.detectChanges();
                })
            }
        };
        this.embeddedViewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useReducerInit && typeof this.useReducerInit === 'function') {
            this.context.$implicit.reducer = this.useReducerInit;
            this.context.$implicit.state = this.useReducerWith;
            if (this.useReducerAnd) {
                this.context.$implicit.dispatch(this.useReducerAnd);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.vcr.clear();
        this.embeddedViewRef.destroy();
        this.embeddedViewRef = null;
    }
}
UseReducerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[useReducer]'
            },] }
];
/** @nocollapse */
UseReducerDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
UseReducerDirective.propDecorators = {
    useReducerInit: [{ type: Input }],
    useReducerWith: [{ type: Input }],
    useReducerAnd: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    UseReducerDirective.prototype.useReducerInit;
    /** @type {?} */
    UseReducerDirective.prototype.useReducerWith;
    /** @type {?} */
    UseReducerDirective.prototype.useReducerAnd;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-state.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function UseStateContext() { }
if (false) {
    /** @type {?} */
    UseStateContext.prototype.$implicit;
}
class UseStateDirective {
    /**
     * @param {?} templateRef
     * @param {?} vcr
     */
    constructor(templateRef, vcr) {
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = (/** @type {?} */ ({}));
        Object.defineProperty(this.context, '$implicit', {
            get: (/**
             * @return {?}
             */
            () => this.value),
            set: (/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.value = value;
                if (this.embeddedViewRef) {
                    this.embeddedViewRef.detectChanges();
                }
            })
        });
        this.embeddedViewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useStateDefault) {
            this.value = this.useStateDefault;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.vcr.clear();
        this.embeddedViewRef.destroy();
        this.embeddedViewRef = null;
    }
}
UseStateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[useState]'
            },] }
];
/** @nocollapse */
UseStateDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
UseStateDirective.propDecorators = {
    useStateDefault: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    UseStateDirective.prototype.useStateDefault;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.value;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/virtual.handler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualHandler {
    constructor() {
        this.elementLink = new Map();
        this.observer = new IntersectionObserver((/**
         * @param {?} entries
         * @return {?}
         */
        entries => {
            entries.forEach((/**
             * @param {?} entry
             * @return {?}
             */
            entry => {
                /** @type {?} */
                const cd = this.elementLink.get((/** @type {?} */ (entry.target)));
                entry.isIntersecting ? attachCD(cd) : detachCD(cd);
            }));
        }));
    }
    /**
     * @param {?} element
     * @param {?} cd
     * @return {?}
     */
    register(element, cd) {
        this.elementLink.set(element, cd);
        this.observer.observe(element);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    unregister(element) {
        this.elementLink.delete(element);
        this.observer.unobserve(element);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.elementLink.forEach((/**
         * @param {?} cd
         * @param {?} e
         * @return {?}
         */
        (cd, e) => this.observer.unobserve(e)));
        this.elementLink.clear();
    }
}
VirtualHandler.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ VirtualHandler.ɵprov = ɵɵdefineInjectable({ factory: function VirtualHandler_Factory() { return new VirtualHandler(); }, token: VirtualHandler, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    VirtualHandler.prototype.elementLink;
    /**
     * @type {?}
     * @private
     */
    VirtualHandler.prototype.observer;
}
/**
 * @param {?} cd
 * @return {?}
 */
function attachCD(cd) {
    cd.reattach();
    cd.detectChanges();
}
/**
 * @param {?} cd
 * @return {?}
 */
function detachCD(cd) {
    cd.detach();
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/virtual.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VirtualDirective {
    /**
     * @param {?} handler
     * @param {?} elementRef
     * @param {?} cd
     */
    constructor(handler, elementRef, cd) {
        this.handler = handler;
        this.elementRef = elementRef;
        this.cd = cd;
        this.handler.register(this.elementRef.nativeElement, cd);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.handler.unregister(this.elementRef.nativeElement);
    }
}
VirtualDirective.decorators = [
    { type: Directive, args: [{ selector: '[virtual]' },] }
];
/** @nocollapse */
VirtualDirective.ctorParameters = () => [
    { type: VirtualHandler },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
VirtualDirective.propDecorators = {
    virtual: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    VirtualDirective.prototype.virtual;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.handler;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/call.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template C
 */
class CallPipe {
    // with Ivy you can inject EmbeddedViewRef directly
    /**
     * @param {?} cd
     */
    constructor(cd) {
        this.cd = cd;
        this.context = ((/** @type {?} */ (this.cd))).context;
    }
    /**
     * @template M
     * @param {?} param
     * @param {?} fn
     * @param {...?} params
     * @return {?}
     */
    transform(param, fn, ...params) {
        return fn.apply(this.context, [param, ...params]);
    }
}
CallPipe.decorators = [
    { type: Pipe, args: [{ name: 'call' },] }
];
/** @nocollapse */
CallPipe.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    CallPipe.prototype.context;
    /**
     * @type {?}
     * @private
     */
    CallPipe.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/console.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function consoleFactory() {
    return console;
}
/** @type {?} */
const CONSOLE = new InjectionToken('Console', {
    providedIn: 'root',
    factory: consoleFactory
});
/** @type {?} */
const skipValueOperators = [
    'count',
    'markTimeline',
    'time',
    'timeEnd',
    'profile',
    'profileEnd',
    'timeline',
    'timelineEnd',
    'timeStamp',
    'group',
    'groupCollapsed'
];
class ConsolePipe {
    /**
     * @param {?} console
     */
    constructor(console) {
        this.console = console;
    }
    /**
     * @template T
     * @param {?} message
     * @param {?=} logLevel
     * @param {...?} optionalParams
     * @return {?}
     */
    transform(message, logLevel = 'log', ...optionalParams) {
        /** @type {?} */
        let params;
        if (skipValueOperators.includes(logLevel)) {
            if (optionalParams.length > 0) {
                params = optionalParams;
            }
            else {
                params = [message];
            }
        }
        else {
            params = [message, ...optionalParams];
        }
        this.console[logLevel](...params);
        return message;
    }
}
ConsolePipe.decorators = [
    { type: Pipe, args: [{
                name: 'console'
            },] }
];
/** @nocollapse */
ConsolePipe.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONSOLE,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConsolePipe.prototype.console;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-effect.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const noop = (/**
 * @return {?}
 */
() => { });
const ɵ0 = noop;
/**
 * @param {?} effect
 * @param {?=} affectedKeys
 * @return {?}
 */
function UseEffect(effect, affectedKeys) {
    /** @type {?} */
    const destroyEffectsMap = new WeakMap();
    /**
     * @return {?}
     */
    function init() {
        /** @type {?} */
        const destroyEffect = effect.call(this);
        destroyEffectsMap.set(this, destroyEffect);
    }
    /**
     * @return {?}
     */
    function destroy() {
        if (destroyEffectsMap.has(this)) {
            /** @type {?} */
            const destroyEffect = destroyEffectsMap.get(this);
            if (destroyEffect) {
                destroyEffect();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    function isChanged(changes) {
        if (!affectedKeys) {
            return true;
        }
        if (affectedKeys.length === 0) {
            return false;
        }
        return affectedKeys.every((/**
         * @param {?} affectedKey
         * @return {?}
         */
        (affectedKey) => affectedKey in changes));
    }
    return (/**
     * @param {?} def
     * @return {?}
     */
    (def) => {
        /** @type {?} */
        const originalOnInit = def.ngComponentDef.onInit || noop;
        def.ngComponentDef.onInit = (/**
         * @return {?}
         */
        function onInit() {
            originalOnInit();
            init.call(this);
        });
        /** @type {?} */
        const originalOnChanges = def.ngComponentDef.onChanges || noop;
        def.ngComponentDef.onChanges = (/**
         * @param {?} changes
         * @return {?}
         */
        function onChanges(changes) {
            originalOnChanges(changes);
            if (isChanged(changes)) {
                destroy.call(this);
                init.call(this);
            }
        });
        /** @type {?} */
        const originalOnDestroy = def.ngComponentDef.onDestroy || noop;
        def.ngComponentDef.onDestroy = (/**
         * @return {?}
         */
        function onDestroy() {
            originalOnDestroy();
            destroy.call(this);
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-reducer.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} __0
 * @param {?} reducer
 * @param {?=} initialValue
 * @return {?}
 */
function UseReducer([stateKey, dispatchKey], reducer, initialValue) {
    return (/**
     * @param {?} def
     * @return {?}
     */
    (def) => {
        /** @type {?} */
        const originalFactory = def.ngComponentDef.factory;
        def.ngComponentDef.factory = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const cmp = originalFactory(def.ngComponentDef.type);
            cmp[stateKey] = initialValue;
            cmp[dispatchKey] = (/**
             * @param {?} action
             * @return {?}
             */
            (action) => cmp[stateKey] = reducer(cmp[stateKey], action));
            return cmp;
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-state.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} __0
 * @param {?=} initialValue
 * @return {?}
 */
function UseState([stateKey, setStateKey], initialValue) {
    return (/**
     * @param {?} def
     * @return {?}
     */
    (def) => {
        /** @type {?} */
        const originalFactory = def.ngComponentDef.factory;
        def.ngComponentDef.factory = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const cmp = originalFactory(def.ngComponentDef.type);
            cmp[stateKey] = initialValue;
            cmp[setStateKey] = (/**
             * @param {?} value
             * @return {?}
             */
            (value) => cmp[stateKey] = value);
            return cmp;
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/platform.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DIRECTIVES = [
    AsyncDirective,
    ComposeDirective,
    CookiesDirective,
    HttpDirective,
    LazyDirective,
    InitDirective,
    IsDevModeDirective,
    KeepAliveDirective,
    NestDirective,
    RenamePropDirective,
    RepeatDirective,
    ReturnDirective,
    RouteDirective,
    SetPropsDirective,
    TimeoutDirective,
    NgForTrackByKeyDirective,
    UseReducerDirective,
    UseStateDirective,
    UseEffectDirective,
    VirtualDirective
];
/** @type {?} */
const PIPES = [
    CallPipe,
    ConsolePipe
];
class NgxfModule {
    /**
     * @param {?} component
     * @return {?}
     */
    static forLazy(component) {
        return {
            ngModule: NgxfModule,
            providers: [
                { provide: LAZY_COMPONENT_TOKEN, useValue: component },
                { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: component, multi: true }
            ]
        };
    }
    /**
     * @param {?} keepAliveConfig
     * @return {?}
     */
    static forKeepAlive(keepAliveConfig) {
        return {
            ngModule: NgxfModule,
            providers: [
                { provide: KeepAliveConfig, useValue: keepAliveConfig }
            ]
        };
    }
}
NgxfModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [DIRECTIVES, PIPES],
                exports: [DIRECTIVES, PIPES]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngxf-platform.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AsyncDirective, CallPipe, ComposeDirective, ConsolePipe, CookiesDirective, HttpDirective, InitDirective, IsDevModeDirective, KeepAliveConfig, KeepAliveDirective, KeepAliveGC, LAZY_COMPONENT_TOKEN, LazyDirective, NestDirective, NgForTrackByKeyDirective, NgxfModule, RenamePropDirective, RepeatDirective, ReturnDirective, RouteDirective, SetPropsDirective, TimeoutDirective, UseEffect, UseEffectDirective, UseReducer, UseReducerDirective, UseState, UseStateDirective, VirtualDirective, DevModeService as ɵa, KeepAliveViewRefs as ɵb, KeepAliveManager as ɵc, RepeatContext as ɵd, consoleFactory as ɵe, CONSOLE as ɵf, CookieOptions as ɵg, CookiesService as ɵh, VirtualHandler as ɵi };
//# sourceMappingURL=ngxf-platform.js.map
