/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/track-by-key.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NgForOf } from '@angular/common';
import { Directive, Host, Input, Optional, ViewContainerRef } from '@angular/core';
/**
 * @template T
 */
var NgForTrackByKeyDirective = /** @class */ (function () {
    function NgForTrackByKeyDirective(ngFor, viewContainerRef) {
        this.ngFor = ngFor;
        this.viewContainerRef = viewContainerRef;
        if (!ngFor) {
            throw new Error('TrackByKey should use with *ngFor!');
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgForTrackByKeyDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('ngForTrackByKey' in changes) {
            /** @type {?} */
            var key_1 = this.ngForTrackByKey;
            if (key_1) {
                this.ngFor.ngForTrackBy = (/**
                 * @param {?} index
                 * @param {?} item
                 * @return {?}
                 */
                function (index, item) { return item[key_1]; });
            }
            else {
                this.ngFor.ngForTrackBy = undefined;
            }
            this.ngFor['_differ'] = null;
            this.ngFor['_ngForOfDirty'] = true;
            this.viewContainerRef.clear();
            this.ngFor.ngDoCheck();
        }
    };
    NgForTrackByKeyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngForTrackByKey]'
                },] }
    ];
    /** @nocollapse */
    NgForTrackByKeyDirective.ctorParameters = function () { return [
        { type: NgForOf, decorators: [{ type: Host }, { type: Optional }] },
        { type: ViewContainerRef }
    ]; };
    NgForTrackByKeyDirective.propDecorators = {
        ngForTrackByKey: [{ type: Input }]
    };
    return NgForTrackByKeyDirective;
}());
export { NgForTrackByKeyDirective };
if (false) {
    /** @type {?} */
    NgForTrackByKeyDirective.prototype.ngForTrackByKey;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.ngFor;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.viewContainerRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhY2stYnkta2V5LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hmL3BsYXRmb3JtLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdHJhY2stYnkta2V5LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxQyxPQUFPLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQWEsUUFBUSxFQUFpQixnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQUU3RztJQU9FLGtDQUF3QyxLQUFpQixFQUFVLGdCQUFrQztRQUE3RCxVQUFLLEdBQUwsS0FBSyxDQUFZO1FBQVUscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNuRyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1NBQ3ZEO0lBQ0gsQ0FBQzs7Ozs7SUFFRCw4Q0FBVzs7OztJQUFYLFVBQVksT0FBc0I7UUFDaEMsSUFBSSxpQkFBaUIsSUFBSSxPQUFPLEVBQUU7O2dCQUMxQixLQUFHLEdBQUcsSUFBSSxDQUFDLGVBQWU7WUFDaEMsSUFBSSxLQUFHLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZOzs7OztnQkFBRyxVQUFDLEtBQWEsRUFBRSxJQUFPLElBQWlCLE9BQUEsSUFBSSxDQUFFLEtBQUcsQ0FBRSxFQUFYLENBQVcsQ0FBQSxDQUFDO2FBQy9FO2lCQUFNO2dCQUNMLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQzthQUNyQztZQUVELElBQUksQ0FBQyxLQUFLLENBQUUsU0FBUyxDQUFFLEdBQUcsSUFBSSxDQUFDO1lBQy9CLElBQUksQ0FBQyxLQUFLLENBQUUsZUFBZSxDQUFFLEdBQUcsSUFBSSxDQUFDO1lBQ3JDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUM5QixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQ3hCO0lBQ0gsQ0FBQzs7Z0JBM0JGLFNBQVMsU0FBQztvQkFDVCxRQUFRLEVBQUUsbUJBQW1CO2lCQUM5Qjs7OztnQkFMUSxPQUFPLHVCQVVELElBQUksWUFBSSxRQUFRO2dCQVRzQyxnQkFBZ0I7OztrQ0FPbEYsS0FBSzs7SUF3QlIsK0JBQUM7Q0FBQSxBQTdCRCxJQTZCQztTQTFCWSx3QkFBd0I7OztJQUVuQyxtREFBa0M7Ozs7O0lBRXRCLHlDQUE2Qzs7Ozs7SUFBRSxvREFBMEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ0Zvck9mIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdCwgSW5wdXQsIE9uQ2hhbmdlcywgT3B0aW9uYWwsIFNpbXBsZUNoYW5nZXMsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW25nRm9yVHJhY2tCeUtleV0nXG59KVxuZXhwb3J0IGNsYXNzIE5nRm9yVHJhY2tCeUtleURpcmVjdGl2ZTxUPiBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgQElucHV0KCkgbmdGb3JUcmFja0J5S2V5OiBrZXlvZiBUO1xuXG4gIGNvbnN0cnVjdG9yKEBIb3N0KCkgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuZ0ZvcjogTmdGb3JPZjxUPiwgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7XG4gICAgaWYgKCFuZ0Zvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFja0J5S2V5IHNob3VsZCB1c2Ugd2l0aCAqbmdGb3IhJyk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgIGlmICgnbmdGb3JUcmFja0J5S2V5JyBpbiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLm5nRm9yVHJhY2tCeUtleTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdGhpcy5uZ0Zvci5uZ0ZvclRyYWNrQnkgPSAoaW5kZXg6IG51bWJlciwgaXRlbTogVCk6IFRba2V5b2YgVF0gPT4gaXRlbVsga2V5IF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5nRm9yLm5nRm9yVHJhY2tCeSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZ0ZvclsgJ19kaWZmZXInIF0gPSBudWxsO1xuICAgICAgdGhpcy5uZ0ZvclsgJ19uZ0Zvck9mRGlydHknIF0gPSB0cnVlO1xuICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XG4gICAgICB0aGlzLm5nRm9yLm5nRG9DaGVjaygpO1xuICAgIH1cbiAgfVxuXG59XG4iXX0=