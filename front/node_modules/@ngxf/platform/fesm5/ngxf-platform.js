import { EventEmitter, Directive, TemplateRef, ViewContainerRef, ChangeDetectorRef, Input, Output, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, isDevMode, InjectionToken, NgModuleFactoryLoader, Injector, Host, ElementRef, Pipe, ANALYZE_FOR_ENTRY_COMPONENTS, NgModule } from '@angular/core';
import { isObservable, of, from } from 'rxjs';
import { __assign, __read, __spread, __extends, __values } from 'tslib';
import { APP_BASE_HREF, NgForOf } from '@angular/common';
import { HttpClient } from '@angular/common/http';
import { catchError, tap, finalize, distinctUntilChanged } from 'rxjs/operators';
import { convertToParamMap, ActivatedRoute } from '@angular/router';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/async.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function AsyncContext() { }
if (false) {
    /** @type {?} */
    AsyncContext.prototype.$implicit;
}
/**
 * @record
 */
function SubscriptionStrategy() { }
if (false) {
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    SubscriptionStrategy.prototype.createSubscription = function (async, next, error, complete) { };
    /**
     * @param {?} subscription
     * @return {?}
     */
    SubscriptionStrategy.prototype.dispose = function (subscription) { };
}
var ObservableStrategy = /** @class */ (function () {
    function ObservableStrategy() {
    }
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    ObservableStrategy.prototype.createSubscription = /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    function (async, next, error, complete) {
        return async.subscribe(next, error, complete);
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    ObservableStrategy.prototype.dispose = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription) {
            subscription.unsubscribe();
        }
    };
    return ObservableStrategy;
}());
var PromiseStrategy = /** @class */ (function () {
    function PromiseStrategy() {
    }
    /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    PromiseStrategy.prototype.createSubscription = /**
     * @param {?} async
     * @param {?} next
     * @param {?} error
     * @param {?} complete
     * @return {?}
     */
    function (async, next, error, complete) {
        /** @type {?} */
        var promise = async.then(next, error);
        if ('finally' in promise) {
            return ((/** @type {?} */ (promise))).finally(complete);
        }
        return promise;
    };
    /**
     * @param {?} subscription
     * @return {?}
     */
    PromiseStrategy.prototype.dispose = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) { };
    return PromiseStrategy;
}());
/** @type {?} */
var observableStrategy = new ObservableStrategy();
/** @type {?} */
var promiseStrategy = new PromiseStrategy();
/**
 * @param {?} async
 * @return {?}
 */
function resolveStrategy(async) {
    if (isObservable(async)) {
        return observableStrategy;
    }
    if (isPromise(async)) {
        return promiseStrategy;
    }
    throw new Error("InvalidDirectiveArgument: 'async' for directive 'async'");
}
var AsyncDirective = /** @class */ (function () {
    function AsyncDirective(templateRef, viewContainer, cd) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.cd = cd;
        this.next = new EventEmitter();
        this.error = new EventEmitter();
        this.complete = new EventEmitter();
        this.context = { $implicit: null };
        this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.context);
        this.componentInstance = ((/** @type {?} */ (cd))).context;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    AsyncDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('async' in changes) {
            this.onAsyncDidChanged(this.async, changes.async.previousValue);
        }
        if ('asyncFrom' in changes) {
            this.onAsyncDidChanged(this.asyncFrom, changes.asyncFrom.previousValue);
        }
    };
    /**
     * @return {?}
     */
    AsyncDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dispose();
        this.viewContainer.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    AsyncDirective.prototype.onAsyncDidChanged = /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    function (current, previous) {
        if (!this.subscription) {
            return current && this.subscribe(current);
        }
        if (current !== previous) {
            this.dispose();
            return this.onAsyncDidChanged(current, null);
        }
    };
    /**
     * @private
     * @param {?} async
     * @return {?}
     */
    AsyncDirective.prototype.subscribe = /**
     * @private
     * @param {?} async
     * @return {?}
     */
    function (async) {
        var _this = this;
        this.strategy = resolveStrategy(async);
        this.subscription = this.strategy.createSubscription(async, (/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return _this.onNext(value); }), (/**
         * @param {?} error
         * @return {?}
         */
        function (error) { return _this.onError(error); }), (/**
         * @return {?}
         */
        function () { return _this.onComplete(); }));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    AsyncDirective.prototype.onNext = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.context.$implicit = value;
        this.next.emit(value);
        if (isFunction(this.asyncNext)) {
            this.asyncNext.call(this.componentInstance, value);
        }
        this.viewRef.markForCheck();
    };
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    AsyncDirective.prototype.onError = /**
     * @private
     * @param {?} error
     * @return {?}
     */
    function (error) {
        this.error.emit(error);
        if (isFunction(this.asyncError)) {
            this.asyncError.call(this.componentInstance, error);
        }
    };
    /**
     * @private
     * @return {?}
     */
    AsyncDirective.prototype.onComplete = /**
     * @private
     * @return {?}
     */
    function () {
        this.complete.next();
        if (isFunction(this.asyncComplete)) {
            this.asyncComplete.call(this.componentInstance);
        }
    };
    /**
     * @private
     * @return {?}
     */
    AsyncDirective.prototype.dispose = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.strategy) {
            this.strategy.dispose(this.subscription);
            this.subscription = null;
            this.strategy = null;
        }
    };
    AsyncDirective.decorators = [
        { type: Directive, args: [{ selector: '[async]' },] }
    ];
    /** @nocollapse */
    AsyncDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: ChangeDetectorRef }
    ]; };
    AsyncDirective.propDecorators = {
        async: [{ type: Input }],
        asyncFrom: [{ type: Input }],
        asyncNext: [{ type: Input }],
        asyncError: [{ type: Input }],
        asyncComplete: [{ type: Input }],
        next: [{ type: Output }],
        error: [{ type: Output }],
        complete: [{ type: Output }]
    };
    return AsyncDirective;
}());
if (false) {
    /** @type {?} */
    AsyncDirective.prototype.async;
    /** @type {?} */
    AsyncDirective.prototype.asyncFrom;
    /** @type {?} */
    AsyncDirective.prototype.asyncNext;
    /** @type {?} */
    AsyncDirective.prototype.asyncError;
    /** @type {?} */
    AsyncDirective.prototype.asyncComplete;
    /** @type {?} */
    AsyncDirective.prototype.next;
    /** @type {?} */
    AsyncDirective.prototype.error;
    /** @type {?} */
    AsyncDirective.prototype.complete;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.componentInstance;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.strategy;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    AsyncDirective.prototype.cd;
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * @template T
 * @param {?} value
 * @return {?}
 */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @param {?} fields
 * @return {?}
 */
function omit(obj, fields) {
    /** @type {?} */
    var shallowCopy = __assign({}, obj);
    for (var i = 0; i < fields.length; i++) {
        /** @type {?} */
        var key = fields[i];
        delete shallowCopy[key];
    }
    return shallowCopy;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/recompose/composed.view.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var PARENT_CONTEXT_TOKEN = Symbol('[PARENT_CONTEXT_TOKEN]');
/**
 * @record
 */
function ComposedContext() { }
if (false) {
    /* Skipping unnamed member:
    [ PARENT_CONTEXT_TOKEN ]: TemplateRef<ComposedContext>[];*/
    /** @type {?} */
    ComposedContext.prototype.children;
    /* Skipping unhandled member: [ key: string ]: any;*/
}
/**
 * @template C
 */
var /**
 * @template C
 */
ComposedView = /** @class */ (function () {
    function ComposedView(viewContainerRef, templateRefs) {
        this.viewContainerRef = viewContainerRef;
        this.templateRefs = templateRefs;
    }
    /**
     * @param {?} context
     * @return {?}
     */
    ComposedView.prototype.createEmbeddedView = /**
     * @param {?} context
     * @return {?}
     */
    function (context) {
        var _a = __read(this.getParentTemplateRefs()), templateRef = _a[0], tail = _a.slice(1);
        this.context = (/** @type {?} */ ((/** @type {?} */ (context))));
        if (tail.length > 0) {
            this.elementRef = templateRef.elementRef;
            this.context[PARENT_CONTEXT_TOKEN] = tail;
            this.context.children = new ComposedView(this.viewContainerRef, tail);
        }
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(templateRef, this.context);
        return (/** @type {?} */ ((/** @type {?} */ (this.viewRef))));
    };
    /**
     * @return {?}
     */
    ComposedView.prototype.markForCheck = /**
     * @return {?}
     */
    function () {
        if (this.viewRef) {
            this.viewRef.markForCheck();
        }
    };
    /**
     * @return {?}
     */
    ComposedView.prototype.detectChanges = /**
     * @return {?}
     */
    function () {
        if (this.viewRef) {
            this.viewRef.detectChanges();
        }
    };
    /**
     * @param {?} update
     * @return {?}
     */
    ComposedView.prototype.updateContext = /**
     * @param {?} update
     * @return {?}
     */
    function (update) {
        /** @type {?} */
        var parent = this.getHydratedParentContext();
        update(this.context, parent);
        this.markForCheck();
    };
    /**
     * @return {?}
     */
    ComposedView.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.destroy();
        }
        this.viewRef = null;
    };
    /**
     * @private
     * @return {?}
     */
    ComposedView.prototype.getParentTemplateRefs = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.templateRefs) {
            return this.templateRefs;
        }
        /** @type {?} */
        var view = ((/** @type {?} */ (this.viewContainerRef.injector))).view;
        /** @type {?} */
        var context = findParentContext(view);
        return context[PARENT_CONTEXT_TOKEN];
    };
    /**
     * @private
     * @return {?}
     */
    ComposedView.prototype.getHydratedParentContext = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var view = ((/** @type {?} */ (this.viewContainerRef.injector))).view;
        return omit(findParentContext(view), [PARENT_CONTEXT_TOKEN, 'children']);
    };
    return ComposedView;
}());
if (false) {
    /** @type {?} */
    ComposedView.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    ComposedView.prototype.templateRefs;
}
/**
 * @param {?} view
 * @return {?}
 */
function findParentContext(view) {
    /** @type {?} */
    var context = view.context;
    if (isParentContext(context)) {
        return context;
    }
    return findParentContext(view.parent);
}
/**
 * @param {?} context
 * @return {?}
 */
function isParentContext(context) {
    return context && PARENT_CONTEXT_TOKEN in context;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/compose.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ComposeContext() { }
if (false) {
    /** @type {?} */
    ComposeContext.prototype.$implicit;
    /** @type {?} */
    ComposeContext.prototype.compose;
}
var ComposeDirective = /** @class */ (function () {
    function ComposeDirective(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, compose: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ComposeDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('compose' in changes) {
            this.onTemplateRefsDidChanged(this.compose, changes.compose.previousValue);
        }
        if ('composeOf' in changes) {
            this.onTemplateRefsDidChanged(this.composeOf, changes.composeOf.previousValue);
        }
    };
    /**
     * @return {?}
     */
    ComposeDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    ComposeDirective.prototype.onTemplateRefsDidChanged = /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    function (current, previous) {
        if (!this.viewRef) {
            return this.create(current);
        }
        if (this.viewRef.destroyed || current !== previous) {
            this.destroy();
            return this.onTemplateRefsDidChanged(current, null);
        }
    };
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    ComposeDirective.prototype.create = /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    function (templateRefs) {
        this.context.compose = this.context.$implicit = this.createComposeFn(templateRefs);
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    };
    /**
     * @private
     * @return {?}
     */
    ComposeDirective.prototype.destroy = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.viewRef && !this.viewRef.destroyed) {
            this.viewRef.destroy();
        }
        this.viewRef = null;
    };
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    ComposeDirective.prototype.createComposeFn = /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    function (templateRefs) {
        var _this = this;
        return (/**
         * @param {?} templateRef
         * @return {?}
         */
        function (templateRef) {
            return new ComposedView(_this.viewContainerRef, __spread(templateRefs, [templateRef]));
        });
    };
    ComposeDirective.decorators = [
        { type: Directive, args: [{ selector: '[compose]' },] }
    ];
    /** @nocollapse */
    ComposeDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    ComposeDirective.propDecorators = {
        compose: [{ type: Input }],
        composeOf: [{ type: Input }]
    };
    return ComposeDirective;
}());
if (false) {
    /** @type {?} */
    ComposeDirective.prototype.compose;
    /** @type {?} */
    ComposeDirective.prototype.composeOf;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    ComposeDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/cookies.tools.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function CookieOptionsArgs() { }
if (false) {
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.path;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.domain;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.expires;
    /** @type {?|undefined} */
    CookieOptionsArgs.prototype.secure;
}
/**
 * @record
 */
function ICookies() { }
/**
 * @record
 */
function ICookieService() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    ICookieService.prototype.get = function (key) { };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    ICookieService.prototype.set = function (key, value, options) { };
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    ICookieService.prototype.remove = function (key, options) { };
}
var CookieOptions = /** @class */ (function () {
    function CookieOptions(_a) {
        var _b = _a === void 0 ? {} : _a, path = _b.path, domain = _b.domain, expires = _b.expires, secure = _b.secure;
        this.path = this.isPresent(path) ? path : null;
        this.domain = this.isPresent(domain) ? domain : null;
        this.expires = this.isPresent(expires) ? expires : null;
        this.secure = this.isPresent(secure) ? secure : false;
    }
    /**
     * @param {?=} options
     * @return {?}
     */
    CookieOptions.prototype.merge = /**
     * @param {?=} options
     * @return {?}
     */
    function (options) {
        return new CookieOptions((/** @type {?} */ ({
            path: this.isPresent(options) && this.isPresent(options.path) ? options.path : this.path,
            domain: this.isPresent(options) && this.isPresent(options.domain) ? options.domain : this.domain,
            expires: this.isPresent(options) && this.isPresent(options.expires) ? options.expires : this.expires,
            secure: this.isPresent(options) && this.isPresent(options.secure) ? options.secure : this.secure,
        })));
    };
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    CookieOptions.prototype.isPresent = /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return obj !== undefined && obj !== null;
    };
    return CookieOptions;
}());
if (false) {
    /** @type {?} */
    CookieOptions.prototype.path;
    /** @type {?} */
    CookieOptions.prototype.domain;
    /** @type {?} */
    CookieOptions.prototype.expires;
    /** @type {?} */
    CookieOptions.prototype.secure;
}
var BaseCookieOptions = /** @class */ (function (_super) {
    __extends(BaseCookieOptions, _super);
    function BaseCookieOptions(baseHref) {
        var _this = _super.call(this, { path: baseHref || '/' }) || this;
        _this.baseHref = baseHref;
        return _this;
    }
    BaseCookieOptions.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    BaseCookieOptions.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Optional }, { type: Inject, args: [APP_BASE_HREF,] }] }
    ]; };
    /** @nocollapse */ BaseCookieOptions.ɵprov = ɵɵdefineInjectable({ factory: function BaseCookieOptions_Factory() { return new BaseCookieOptions(ɵɵinject(APP_BASE_HREF, 8)); }, token: BaseCookieOptions, providedIn: "root" });
    return BaseCookieOptions;
}(CookieOptions));
if (false) {
    /**
     * @type {?}
     * @private
     */
    BaseCookieOptions.prototype.baseHref;
}
var CookiesService = /** @class */ (function () {
    function CookiesService(defaultOptions) {
        this.defaultOptions = defaultOptions;
    }
    Object.defineProperty(CookiesService.prototype, "cookieString", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return document.cookie || '';
        },
        set: /**
         * @protected
         * @param {?} val
         * @return {?}
         */
        function (val) {
            document.cookie = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    CookiesService.prototype.cookieReader = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        /** @type {?} */
        var currentCookieString = this.cookieString;
        if (currentCookieString) {
            /** @type {?} */
            var cookieArray = currentCookieString.split('; ');
            return cookieArray.reduce((/**
             * @param {?} cookies
             * @param {?} current
             * @return {?}
             */
            function (cookies, current) {
                var _a;
                /** @type {?} */
                var cookie = current.split('=');
                return __assign(__assign({}, cookies), (_a = {}, _a[cookie[0]] = decodeURIComponent(cookie[1]), _a));
            }), {})[key];
        }
    };
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    CookiesService.prototype.cookieWriter = /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (name, value, options) {
        this.cookieString = this.buildCookieString(name, value, options);
    };
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    CookiesService.prototype.buildCookieString = /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (name, value, options) {
        /** @type {?} */
        var defaultOpts = this.defaultOptions || new CookieOptions((/** @type {?} */ ({ path: '/' })));
        /** @type {?} */
        var opts = this.mergeOptions(defaultOpts, options);
        /** @type {?} */
        var expires = opts.expires;
        if (!value) {
            expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
            value = '';
        }
        if (typeof expires === 'string') {
            expires = new Date(expires);
        }
        /** @type {?} */
        var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
        str += opts.path ? ";path=" + opts.path : '';
        str += opts.domain ? ";domain=" + opts.domain : '';
        str += expires ? ";expires=" + expires.toUTCString() : '';
        str += opts.secure ? ';secure' : '';
        /** @type {?} */
        var cookieLength = str.length + 1;
        if (cookieLength > 4096) {
            console.log("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!");
        }
        return str;
    };
    /**
     * @private
     * @param {?} defaultOpts
     * @param {?=} providedOpts
     * @return {?}
     */
    CookiesService.prototype.mergeOptions = /**
     * @private
     * @param {?} defaultOpts
     * @param {?=} providedOpts
     * @return {?}
     */
    function (defaultOpts, providedOpts) {
        /** @type {?} */
        var newOpts = defaultOpts;
        if (providedOpts) {
            return newOpts.merge(new CookieOptions(providedOpts));
        }
        return newOpts;
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CookiesService.prototype.get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.cookieReader(key);
    };
    /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    CookiesService.prototype.set = /**
     * @param {?} key
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (key, value, options) {
        this.cookieWriter(key, value, options);
    };
    /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    CookiesService.prototype.remove = /**
     * @param {?} key
     * @param {?=} options
     * @return {?}
     */
    function (key, options) {
        this.cookieWriter(key, undefined, options);
    };
    CookiesService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CookiesService.ctorParameters = function () { return [
        { type: CookieOptions, decorators: [{ type: Optional }] }
    ]; };
    /** @nocollapse */ CookiesService.ɵprov = ɵɵdefineInjectable({ factory: function CookiesService_Factory() { return new CookiesService(ɵɵinject(CookieOptions, 8)); }, token: CookiesService, providedIn: "root" });
    return CookiesService;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookiesService.prototype.defaultOptions;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/cookies.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var CookiesStrategies = {
    GET: "get",
    SET: "set",
    REMOVE: "remove",
};
/**
 * @record
 */
function CookiesContext() { }
if (false) {
    /** @type {?} */
    CookiesContext.prototype.$implicit;
    /** @type {?} */
    CookiesContext.prototype.data;
}
/**
 * @record
 */
function CookiesStrategy() { }
if (false) {
    /** @type {?} */
    CookiesStrategy.prototype.type;
    /** @type {?} */
    CookiesStrategy.prototype.changes;
    /** @type {?} */
    CookiesStrategy.prototype.require;
}
/** @type {?} */
var COOKIES_CONFIG = [
    {
        type: CookiesStrategies.GET,
        changes: ['cookiesGet'],
        require: ['cookiesGet']
    },
    {
        type: CookiesStrategies.SET,
        changes: [
            'cookiesSet',
            'cookiesValue',
            'cookiesPath',
            'cookiesDomain',
            'cookiesExpires',
            'cookiesSecure'
        ],
        require: ['cookiesSet']
    },
    {
        type: CookiesStrategies.REMOVE,
        changes: ['cookiesRemove', 'cookiesPath', 'cookiesDomain'],
        require: ['cookiesRemove']
    }
];
var CookiesDirective = /** @class */ (function () {
    function CookiesDirective(templateRef, viewContainerRef, cookiesService) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.cookiesService = cookiesService;
        this.context = {
            $implicit: null,
            /**
             * @return {?}
             */
            get data() { return this.$implicit; }
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    CookiesDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var strategy = this.findStrategy(changes);
        if (strategy) {
            this.execute(strategy);
        }
    };
    /**
     * @return {?}
     */
    CookiesDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    CookiesDirective.prototype.findStrategy = /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        return COOKIES_CONFIG.find((/**
         * @param {?} strategy
         * @return {?}
         */
        function (strategy) {
            return strategy.changes.some((/**
             * @param {?} field
             * @return {?}
             */
            function (field) { return !!changes[field]; }))
                && strategy.require.every((/**
                 * @param {?} field
                 * @return {?}
                 */
                function (field) { return !!_this[field]; }));
        }));
    };
    /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    CookiesDirective.prototype.execute = /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        var _this = this;
        /** @type {?} */
        var options = strategy.changes.map((/**
         * @param {?} field
         * @return {?}
         */
        function (field) { return _this[field]; }));
        this.action.apply(this, __spread([strategy.type], options));
    };
    /**
     * @private
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    CookiesDirective.prototype.action = /**
     * @private
     * @param {?} type
     * @param {...?} options
     * @return {?}
     */
    function (type) {
        var options = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            options[_i - 1] = arguments[_i];
        }
        /** @type {?} */
        var name = options[0];
        /** @type {?} */
        var value = options[1];
        /** @type {?} */
        var cookieOptions = {
            path: options[2],
            domain: options[3],
            expires: options[4],
            secure: !!options[5]
        };
        if (CookiesStrategies.GET === type) {
            this.context.$implicit = this.getCookie(name);
        }
        if (CookiesStrategies.SET === type) {
            this.setCookie(name, value, cookieOptions);
            this.context.$implicit = value;
        }
        if (CookiesStrategies.REMOVE === type) {
            this.removeCookie(name, cookieOptions);
            this.context.$implicit = null;
        }
        this.viewRef.markForCheck();
    };
    /**
     * @private
     * @param {?} name
     * @return {?}
     */
    CookiesDirective.prototype.getCookie = /**
     * @private
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.cookiesService.get(name);
    };
    /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    CookiesDirective.prototype.setCookie = /**
     * @private
     * @param {?} name
     * @param {?} value
     * @param {?=} options
     * @return {?}
     */
    function (name, value, options) {
        this.cookiesService.set(name, value, options);
    };
    /**
     * @private
     * @param {?} name
     * @param {?=} options
     * @return {?}
     */
    CookiesDirective.prototype.removeCookie = /**
     * @private
     * @param {?} name
     * @param {?=} options
     * @return {?}
     */
    function (name, options) {
        this.cookiesService.remove(name, options);
    };
    CookiesDirective.decorators = [
        { type: Directive, args: [{ selector: '[cookies]' },] }
    ];
    /** @nocollapse */
    CookiesDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: CookiesService }
    ]; };
    CookiesDirective.propDecorators = {
        cookiesGet: [{ type: Input }],
        cookiesSet: [{ type: Input }],
        cookiesRemove: [{ type: Input }],
        cookiesValue: [{ type: Input }],
        cookiesPath: [{ type: Input }],
        cookiesDomain: [{ type: Input }],
        cookiesExpires: [{ type: Input }],
        cookiesSecure: [{ type: Input }]
    };
    return CookiesDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesGet;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesSet;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesRemove;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesValue;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesPath;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesDomain;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesExpires;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesSecure;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    CookiesDirective.prototype.cookiesService;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/http.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var HttpStrategies = {
    DELETE: "delete",
    GET: "get",
    HEAD: "head",
    JSONP: "jsonp",
    OPTIONS: "options",
    PATCH: "patch",
    POST: "post",
    PUT: "put",
};
/**
 * @record
 */
function HttpContext() { }
if (false) {
    /** @type {?} */
    HttpContext.prototype.$implicit;
    /** @type {?} */
    HttpContext.prototype.data;
}
/**
 * @record
 */
function HttpStrategy() { }
if (false) {
    /** @type {?} */
    HttpStrategy.prototype.type;
    /** @type {?} */
    HttpStrategy.prototype.changes;
    /** @type {?} */
    HttpStrategy.prototype.require;
}
/** @type {?} */
var HTTP_CONFIG = [
    {
        type: HttpStrategies.DELETE,
        changes: ['httpDelete', 'httpWith'],
        require: ['httpDelete']
    },
    {
        type: HttpStrategies.GET,
        changes: ['httpGet', 'httpWith'],
        require: ['httpGet']
    },
    {
        type: HttpStrategies.HEAD,
        changes: ['httpHead', 'httpWith'],
        require: ['httpHead']
    },
    {
        type: HttpStrategies.JSONP,
        changes: ['httpJsonp', 'httpCallback'],
        require: ['httpJsonp', 'httpCallback']
    },
    {
        type: HttpStrategies.OPTIONS,
        changes: ['httpOptions', 'httpWith'],
        require: ['httpOptions']
    },
    {
        type: HttpStrategies.PATCH,
        changes: ['httpPatch', 'httpSend', 'httpWith'],
        require: ['httpPatch']
    },
    {
        type: HttpStrategies.POST,
        changes: ['httpPost', 'httpSend', 'httpWith'],
        require: ['httpPost']
    },
    {
        type: HttpStrategies.PUT,
        changes: ['httpPut', 'httpSend', 'httpWith'],
        require: ['httpPut']
    }
];
var HttpDirective = /** @class */ (function () {
    function HttpDirective(http, templateRef, viewContainerRef) {
        this.http = http;
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null,
            /**
             * @return {?}
             */
            get data() { return this.$implicit; }
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    HttpDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var strategy = this.findStrategy(changes);
        if (strategy) {
            this.execute(strategy);
        }
    };
    /**
     * @return {?}
     */
    HttpDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dispose();
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    HttpDirective.prototype.findStrategy = /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        return HTTP_CONFIG.find((/**
         * @param {?} strategy
         * @return {?}
         */
        function (strategy) {
            return strategy.changes.some((/**
             * @param {?} field
             * @return {?}
             */
            function (field) { return !!changes[field]; }))
                && strategy.require.every((/**
                 * @param {?} field
                 * @return {?}
                 */
                function (field) { return !!_this[field]; }));
        }));
    };
    /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    HttpDirective.prototype.execute = /**
     * @private
     * @param {?} strategy
     * @return {?}
     */
    function (strategy) {
        var _this = this;
        /** @type {?} */
        var params = strategy.changes.map((/**
         * @param {?} field
         * @return {?}
         */
        function (field) { return _this[field]; }));
        this.request.apply(this, __spread([strategy.type], params));
    };
    /**
     * @private
     * @param {?} method
     * @param {...?} params
     * @return {?}
     */
    HttpDirective.prototype.request = /**
     * @private
     * @param {?} method
     * @param {...?} params
     * @return {?}
     */
    function (method) {
        var _a;
        var _this = this;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        this.dispose();
        this.subscription = (_a = this.http)[method].apply(_a, __spread(params)).pipe(catchError((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            console.error(e);
            return of(null);
        })))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            _this.context.$implicit = data;
            _this.viewRef.markForCheck();
        }));
    };
    /**
     * @private
     * @return {?}
     */
    HttpDirective.prototype.dispose = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.subscription && !this.subscription.closed) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    };
    HttpDirective.decorators = [
        { type: Directive, args: [{ selector: '[http]' },] }
    ];
    /** @nocollapse */
    HttpDirective.ctorParameters = function () { return [
        { type: HttpClient },
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    HttpDirective.propDecorators = {
        httpDelete: [{ type: Input }],
        httpGet: [{ type: Input }],
        httpHead: [{ type: Input }],
        httpJsonp: [{ type: Input }],
        httpOptions: [{ type: Input }],
        httpPatch: [{ type: Input }],
        httpPost: [{ type: Input }],
        httpPut: [{ type: Input }],
        httpSend: [{ type: Input }],
        httpCallback: [{ type: Input }],
        httpWith: [{ type: Input }]
    };
    return HttpDirective;
}());
if (false) {
    /** @type {?} */
    HttpDirective.prototype.httpDelete;
    /** @type {?} */
    HttpDirective.prototype.httpGet;
    /** @type {?} */
    HttpDirective.prototype.httpHead;
    /** @type {?} */
    HttpDirective.prototype.httpJsonp;
    /** @type {?} */
    HttpDirective.prototype.httpOptions;
    /** @type {?} */
    HttpDirective.prototype.httpPatch;
    /** @type {?} */
    HttpDirective.prototype.httpPost;
    /** @type {?} */
    HttpDirective.prototype.httpPut;
    /** @type {?} */
    HttpDirective.prototype.httpSend;
    /** @type {?} */
    HttpDirective.prototype.httpCallback;
    /** @type {?} */
    HttpDirective.prototype.httpWith;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.http;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    HttpDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/init.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function InitContext() { }
if (false) {
    /** @type {?} */
    InitContext.prototype.$implicit;
    /** @type {?} */
    InitContext.prototype.init;
}
/**
 * @template T
 */
var InitDirective = /** @class */ (function () {
    function InitDirective(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.context = { $implicit: null, init: null };
        this.viewRef = this.viewContainer.createEmbeddedView(this.templateRef, this.context);
    }
    Object.defineProperty(InitDirective.prototype, "init", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InitDirective.prototype, "initOf", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InitDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.viewContainer.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    InitDirective.prototype.setValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.context.$implicit = this.context.init = value;
        if (this.viewRef) {
            this.viewRef.markForCheck();
        }
    };
    InitDirective.decorators = [
        { type: Directive, args: [{ selector: '[init]' },] }
    ];
    /** @nocollapse */
    InitDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    InitDirective.propDecorators = {
        init: [{ type: Input }],
        initOf: [{ type: Input }]
    };
    return InitDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    InitDirective.prototype.viewContainer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/is-dev-mode.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DevModeService = /** @class */ (function () {
    function DevModeService() {
    }
    /**
     * @return {?}
     */
    DevModeService.prototype.isDevMode = /**
     * @return {?}
     */
    function () {
        return isDevMode();
    };
    DevModeService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    DevModeService.ctorParameters = function () { return []; };
    /** @nocollapse */ DevModeService.ɵprov = ɵɵdefineInjectable({ factory: function DevModeService_Factory() { return new DevModeService(); }, token: DevModeService, providedIn: "root" });
    return DevModeService;
}());
var IsDevModeDirective = /** @class */ (function () {
    function IsDevModeDirective(devModeService, viewContainerRef, templateRef) {
        if (devModeService.isDevMode()) {
            viewContainerRef.createEmbeddedView(templateRef);
        }
    }
    /**
     * @return {?}
     */
    IsDevModeDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    IsDevModeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[isDevMode]'
                },] }
    ];
    /** @nocollapse */
    IsDevModeDirective.ctorParameters = function () { return [
        { type: DevModeService },
        { type: ViewContainerRef },
        { type: TemplateRef }
    ]; };
    return IsDevModeDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    IsDevModeDirective.prototype.viewRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/keep-alive.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var KeepAliveFlags = {
    Detached: 0,
    Attached: 1,
};
var ViewRefAttachable = /** @class */ (function () {
    function ViewRefAttachable(viewRef) {
        this.flag = 0 /* Detached */;
        this.viewRef = viewRef;
    }
    Object.defineProperty(ViewRefAttachable.prototype, "attached", {
        get: /**
         * @return {?}
         */
        function () {
            return this.flag === 1 /* Attached */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewRefAttachable.prototype, "detached", {
        get: /**
         * @return {?}
         */
        function () {
            return this.flag === 0 /* Detached */;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} viewContainer
     * @return {?}
     */
    ViewRefAttachable.prototype.attachToViewContainerRef = /**
     * @param {?} viewContainer
     * @return {?}
     */
    function (viewContainer) {
        if (this.viewContainerRef || this.attached) {
            throw new TypeError("You can't use *keepAlive with *ngFor:\n  <ng-container *ngFor=\"...\">\n    <!-- Wrong! -->\n    <ng-container *keepAlive></ng-container>\n  </ng-container>\n\nviewRef already attached to viewContainerRef");
        }
        this.flag = 1 /* Attached */;
        (this.viewContainerRef = viewContainer).insert(this.viewRef);
    };
    /**
     * @return {?}
     */
    ViewRefAttachable.prototype.detachFromViewContainerRef = /**
     * @return {?}
     */
    function () {
        if (!this.viewContainerRef || this.detached) {
            throw new TypeError('viewRef already detached from viewContainerRef');
        }
        this.flag = 0 /* Detached */;
        this.viewContainerRef.detach(this.viewContainerRef.indexOf(this.viewRef));
        delete this.viewContainerRef;
    };
    /**
     * @return {?}
     */
    ViewRefAttachable.prototype.destroy = /**
     * @return {?}
     */
    function () {
        this.viewRef.destroy();
    };
    return ViewRefAttachable;
}());
if (false) {
    /** @type {?} */
    ViewRefAttachable.prototype.viewRef;
    /** @type {?} */
    ViewRefAttachable.prototype.flag;
    /** @type {?} */
    ViewRefAttachable.prototype.viewContainerRef;
}
var KeepAliveConfig = /** @class */ (function () {
    function KeepAliveConfig() {
        this.limit = 50;
    }
    KeepAliveConfig.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ KeepAliveConfig.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveConfig_Factory() { return new KeepAliveConfig(); }, token: KeepAliveConfig, providedIn: "root" });
    return KeepAliveConfig;
}());
if (false) {
    /** @type {?} */
    KeepAliveConfig.prototype.limit;
}
var KeepAliveGC = /** @class */ (function () {
    function KeepAliveGC(config) {
        this.config = config;
    }
    /**
     * @param {?} viewRefs
     * @return {?}
     */
    KeepAliveGC.prototype.collect = /**
     * @param {?} viewRefs
     * @return {?}
     */
    function (viewRefs) {
        var e_1, _a;
        /** @type {?} */
        var limit = this.config.limit > 0 ? this.config.limit : Number.MAX_SAFE_INTEGER;
        try {
            for (var _b = __values(Array.from(viewRefs.entries())), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), templateDef = _d[0], viewRefAttachable = _d[1];
                if (viewRefs.size <= limit) {
                    break;
                }
                if (viewRefAttachable.flag === 0 /* Detached */) {
                    viewRefAttachable.destroy();
                    viewRefs.delete(templateDef);
                    console.log('Collect', viewRefAttachable);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    KeepAliveGC.decorators = [
        { type: Injectable, args: [{ providedIn: 'root', },] }
    ];
    /** @nocollapse */
    KeepAliveGC.ctorParameters = function () { return [
        { type: KeepAliveConfig }
    ]; };
    /** @nocollapse */ KeepAliveGC.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveGC_Factory() { return new KeepAliveGC(ɵɵinject(KeepAliveConfig)); }, token: KeepAliveGC, providedIn: "root" });
    return KeepAliveGC;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveGC.prototype.config;
}
var KeepAliveViewRefs = /** @class */ (function () {
    function KeepAliveViewRefs(gc) {
        this.gc = gc;
        this.viewRefs = new Map();
    }
    /**
     * @param {?} templateRef
     * @param {?} viewRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.add = /**
     * @param {?} templateRef
     * @param {?} viewRef
     * @return {?}
     */
    function (templateRef, viewRef) {
        /** @type {?} */
        var templateDef = this.getTemplateDef(templateRef);
        if (this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef already exists in viewRefs');
        }
        /** @type {?} */
        var viewRefAttachable = new ViewRefAttachable(viewRef);
        this.viewRefs.set(templateDef, viewRefAttachable);
    };
    /**
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.has = /**
     * @param {?} templateRef
     * @return {?}
     */
    function (templateRef) {
        /** @type {?} */
        var templateDef = this.getTemplateDef(templateRef);
        return this.viewRefs.has(templateDef);
    };
    /**
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.get = /**
     * @param {?} templateRef
     * @return {?}
     */
    function (templateRef) {
        /** @type {?} */
        var templateDef = this.getTemplateDef(templateRef);
        if (!this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef not exists in viewRefs');
        }
        return this.viewRefs.get(templateDef);
    };
    /**
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.delete = /**
     * @param {?} templateRef
     * @return {?}
     */
    function (templateRef) {
        /** @type {?} */
        var templateDef = this.getTemplateDef(templateRef);
        if (!this.viewRefs.has(templateDef)) {
            throw new TypeError('templateRef not exists in viewRefs');
        }
        this.viewRefs.get(templateRef).viewRef.destroy();
        return this.viewRefs.delete(templateDef);
    };
    /**
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.reattach = /**
     * @param {?} templateRef
     * @return {?}
     */
    function (templateRef) {
        /** @type {?} */
        var templateDef = this.getTemplateDef(templateRef);
        /** @type {?} */
        var viewRefAttachable = this.get(templateRef);
        this.viewRefs.set(templateDef, viewRefAttachable);
    };
    /**
     * @return {?}
     */
    KeepAliveViewRefs.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.viewRefs.forEach((/**
         * @param {?} viewRefAttachable
         * @return {?}
         */
        function (viewRefAttachable) {
            return viewRefAttachable.viewRef.destroy();
        }));
        this.viewRefs.clear();
    };
    /**
     * @return {?}
     */
    KeepAliveViewRefs.prototype.collect = /**
     * @return {?}
     */
    function () {
        this.gc.collect(this.viewRefs);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    KeepAliveViewRefs.prototype.forEach = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.viewRefs.forEach(fn);
    };
    /**
     * @private
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveViewRefs.prototype.getTemplateDef = /**
     * @private
     * @param {?} templateRef
     * @return {?}
     */
    function (templateRef) {
        return templateRef['_def'];
    };
    KeepAliveViewRefs.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    KeepAliveViewRefs.ctorParameters = function () { return [
        { type: KeepAliveGC }
    ]; };
    /** @nocollapse */ KeepAliveViewRefs.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveViewRefs_Factory() { return new KeepAliveViewRefs(ɵɵinject(KeepAliveGC)); }, token: KeepAliveViewRefs, providedIn: "root" });
    return KeepAliveViewRefs;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveViewRefs.prototype.viewRefs;
    /**
     * @type {?}
     * @private
     */
    KeepAliveViewRefs.prototype.gc;
}
var KeepAliveManager = /** @class */ (function () {
    function KeepAliveManager(viewRefs) {
        this.viewRefs = viewRefs;
    }
    /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveManager.prototype.attach = /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    function (viewContainerRef, templateRef) {
        if (!this.viewRefs.has(templateRef)) {
            /** @type {?} */
            var viewRef = templateRef.createEmbeddedView({});
            this.viewRefs.add(templateRef, viewRef);
        }
        else {
            this.viewRefs.reattach(templateRef);
        }
        this.patchClear(viewContainerRef);
        /** @type {?} */
        var viewRefAttachable = this.viewRefs.get(templateRef);
        viewRefAttachable.attachToViewContainerRef(viewContainerRef);
        this.viewRefs.collect();
    };
    /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    KeepAliveManager.prototype.detach = /**
     * @param {?} viewContainerRef
     * @param {?} templateRef
     * @return {?}
     */
    function (viewContainerRef, templateRef) {
        /** @type {?} */
        var viewRefAttachable = this.viewRefs.get(templateRef);
        viewRefAttachable.detachFromViewContainerRef();
        this.viewRefs.collect();
    };
    /**
     * @private
     * @param {?} viewContainerRef
     * @return {?}
     */
    KeepAliveManager.prototype.patchClear = /**
     * @private
     * @param {?} viewContainerRef
     * @return {?}
     */
    function (viewContainerRef) {
        if (!viewContainerRef[KeepAliveManager.patched]) {
            /** @type {?} */
            var clear_1 = Object.getPrototypeOf(viewContainerRef).clear;
            /** @type {?} */
            var viewRefs_1 = this.viewRefs;
            Object.getPrototypeOf(viewContainerRef).clear = (/**
             * @this {?}
             * @return {?}
             */
            function () {
                viewRefs_1.forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) { v.viewRef['_view'].state |= (1 << 7); }));
                clear_1.call(this);
                viewRefs_1.forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                function (v) { v.viewRef['_view'].state &= ~(1 << 7); }));
            });
            Object.defineProperty(viewContainerRef, KeepAliveManager.patched, { get: (/**
                 * @return {?}
                 */
                function () { return true; }) });
        }
    };
    KeepAliveManager.patched = Symbol('Already Patched ViewContainerRef Token');
    KeepAliveManager.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    KeepAliveManager.ctorParameters = function () { return [
        { type: KeepAliveViewRefs }
    ]; };
    /** @nocollapse */ KeepAliveManager.ɵprov = ɵɵdefineInjectable({ factory: function KeepAliveManager_Factory() { return new KeepAliveManager(ɵɵinject(KeepAliveViewRefs)); }, token: KeepAliveManager, providedIn: "root" });
    return KeepAliveManager;
}());
if (false) {
    /** @type {?} */
    KeepAliveManager.patched;
    /**
     * @type {?}
     * @private
     */
    KeepAliveManager.prototype.viewRefs;
}
var KeepAliveDirective = /** @class */ (function () {
    function KeepAliveDirective(manager, viewContainerRef, templateRef) {
        this.manager = manager;
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        manager.attach(viewContainerRef, templateRef);
    }
    /**
     * @return {?}
     */
    KeepAliveDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.manager.detach(this.viewContainerRef, this.templateRef);
    };
    KeepAliveDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[keepAlive]'
                },] }
    ];
    /** @nocollapse */
    KeepAliveDirective.ctorParameters = function () { return [
        { type: KeepAliveManager },
        { type: ViewContainerRef },
        { type: TemplateRef }
    ]; };
    return KeepAliveDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.manager;
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    KeepAliveDirective.prototype.templateRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/lazy.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LazyContext() { }
if (false) {
    /** @type {?} */
    LazyContext.prototype.$implicit;
}
/** @type {?} */
var LAZY_COMPONENT_TOKEN = new InjectionToken('Lazy Component Token');
var LazyDirective = /** @class */ (function () {
    function LazyDirective(templateRef, viewContainer, loader, injector) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.loader = loader;
        this.injector = injector;
        this.activate = new EventEmitter();
        this.deactivate = new EventEmitter();
        this.context = {
            $implicit: null
        };
        this.embeddedViewRef = this.templateRef.createEmbeddedView(this.context);
    }
    Object.defineProperty(LazyDirective.prototype, "component", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            if (this.componentRef) {
                return this.componentRef.instance;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LazyDirective.prototype, "projectableNodes", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return [this.templateRef.createEmbeddedView(this.context).rootNodes];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    LazyDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('lazy' in changes) {
            this.onLazyDidChanged(this.lazy, changes.lazy.previousValue);
        }
        if ('lazyLoadChildren' in changes) {
            this.onLazyDidChanged(this.lazyLoadChildren, changes.lazyLoadChildren.previousValue);
        }
    };
    /**
     * @return {?}
     */
    LazyDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dispose();
        if (this.embeddedViewRef) {
            this.embeddedViewRef.destroy();
            this.embeddedViewRef = null;
        }
    };
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    LazyDirective.prototype.onLazyDidChanged = /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    function (current, previous) {
        if (!this.ngModuleRef) {
            return current && this.loadAndRender(current);
        }
        if (current !== previous) {
            this.dispose();
            return this.onLazyDidChanged(current, null);
        }
    };
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    LazyDirective.prototype.loadAndRender = /**
     * @private
     * @param {?} path
     * @return {?}
     */
    function (path) {
        var _this = this;
        this.subscription = this.load(path).pipe(tap((/**
         * @param {?} ngModuleFactory
         * @return {?}
         */
        function (ngModuleFactory) {
            _this.ngModuleRef = ngModuleFactory.create(_this.injector);
            /** @type {?} */
            var component = _this.ngModuleRef.injector.get(LAZY_COMPONENT_TOKEN);
            /** @type {?} */
            var componentFactory = _this.ngModuleRef.componentFactoryResolver.resolveComponentFactory(component);
            _this.componentRef = _this.viewContainer.createComponent(componentFactory, _this.viewContainer.length, _this.injector, _this.projectableNodes, _this.ngModuleRef);
        })), finalize((/**
         * @return {?}
         */
        function () { return _this.onActivate(_this.component); }))).subscribe();
    };
    /**
     * @private
     * @param {?} path
     * @return {?}
     */
    LazyDirective.prototype.load = /**
     * @private
     * @param {?} path
     * @return {?}
     */
    function (path) {
        var _this = this;
        /** @type {?} */
        var pathProduction = path.split('#').join('.ts#');
        return from(this.loader.load(pathProduction)).pipe(catchError((/**
         * @return {?}
         */
        function () { return from(_this.loader.load(path)); })));
    };
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    LazyDirective.prototype.onActivate = /**
     * @private
     * @param {?} component
     * @return {?}
     */
    function (component) {
        this.activate.emit(component);
        if (isFunction$1(this.lazyActivate)) {
            this.lazyActivate(component);
        }
        this.context.$implicit = component;
        this.embeddedViewRef.markForCheck();
    };
    /**
     * @private
     * @param {?} component
     * @return {?}
     */
    LazyDirective.prototype.onDeactivate = /**
     * @private
     * @param {?} component
     * @return {?}
     */
    function (component) {
        this.deactivate.emit(component);
        if (isFunction$1(this.lazyDeactivate)) {
            this.lazyDeactivate(component);
        }
        this.context.$implicit = null;
        this.embeddedViewRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    LazyDirective.prototype.dispose = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.componentRef) {
            /** @type {?} */
            var c = this.component;
            this.componentRef.destroy();
            this.componentRef = null;
            this.onDeactivate(c);
        }
        if (this.ngModuleRef) {
            this.ngModuleRef.destroy();
            this.ngModuleRef = null;
        }
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
    };
    LazyDirective.decorators = [
        { type: Directive, args: [{ selector: '[lazy]' },] }
    ];
    /** @nocollapse */
    LazyDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: NgModuleFactoryLoader },
        { type: Injector }
    ]; };
    LazyDirective.propDecorators = {
        lazy: [{ type: Input }],
        lazyLoadChildren: [{ type: Input }],
        lazyActivate: [{ type: Input }],
        lazyDeactivate: [{ type: Input }],
        activate: [{ type: Output }],
        deactivate: [{ type: Output }]
    };
    return LazyDirective;
}());
if (false) {
    /** @type {?} */
    LazyDirective.prototype.lazy;
    /** @type {?} */
    LazyDirective.prototype.lazyLoadChildren;
    /** @type {?} */
    LazyDirective.prototype.lazyActivate;
    /** @type {?} */
    LazyDirective.prototype.lazyDeactivate;
    /** @type {?} */
    LazyDirective.prototype.activate;
    /** @type {?} */
    LazyDirective.prototype.deactivate;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.componentRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.ngModuleRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    LazyDirective.prototype.injector;
}
/**
 * @param {?} value
 * @return {?}
 */
function isFunction$1(value) {
    return typeof value === 'function';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/nest.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NestContext() { }
if (false) {
    /** @type {?} */
    NestContext.prototype.$implicit;
    /** @type {?} */
    NestContext.prototype.nest;
}
var NestDirective = /** @class */ (function () {
    function NestDirective(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, nest: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NestDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('nest' in changes) {
            this.onTemplatesDidChanged(this.nest, changes.nest.previousValue);
        }
        if ('nestOf' in changes) {
            this.onTemplatesDidChanged(this.nestOf, changes.nestOf.previousValue);
        }
    };
    /**
     * @return {?}
     */
    NestDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    NestDirective.prototype.onTemplatesDidChanged = /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    function (current, previous) {
        if (!this.context.$implicit) {
            return current && this.create(current);
        }
        if (current !== previous) {
            this.destroy();
            this.onTemplatesDidChanged(current, null);
        }
    };
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    NestDirective.prototype.create = /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    function (templateRefs) {
        this.context.$implicit = this.context.nest = new ComposedView(this.viewContainerRef, templateRefs);
        this.viewRef =
            this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
    };
    /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    NestDirective.prototype.update = /**
     * @private
     * @param {?} templateRefs
     * @return {?}
     */
    function (templateRefs) {
        this.context.$implicit = this.context.nest = new ComposedView(this.viewContainerRef, templateRefs);
        this.viewRef.markForCheck();
    };
    /**
     * @private
     * @return {?}
     */
    NestDirective.prototype.destroy = /**
     * @private
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    NestDirective.decorators = [
        { type: Directive, args: [{ selector: '[nest]' },] }
    ];
    /** @nocollapse */
    NestDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    NestDirective.propDecorators = {
        nest: [{ type: Input }],
        nestOf: [{ type: Input }]
    };
    return NestDirective;
}());
if (false) {
    /** @type {?} */
    NestDirective.prototype.nest;
    /** @type {?} */
    NestDirective.prototype.nestOf;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    NestDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/rename-prop.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function RenamePropContext() { }
if (false) {
    /** @type {?} */
    RenamePropContext.prototype.$implicit;
}
var RenamePropDirective = /** @class */ (function () {
    function RenamePropDirective(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    RenamePropDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('renameProp' in changes && 'renamePropTo' in changes) {
            this.onRenameDidChanged(this.renameProp, this.renamePropTo, changes.renameProp.previousValue, changes.renamePropTo.previousValue);
        }
    };
    /**
     * @return {?}
     */
    RenamePropDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @param {?} fromPrevious
     * @param {?} toPrevious
     * @return {?}
     */
    RenamePropDirective.prototype.onRenameDidChanged = /**
     * @private
     * @param {?} from
     * @param {?} to
     * @param {?} fromPrevious
     * @param {?} toPrevious
     * @return {?}
     */
    function (from, to, fromPrevious, toPrevious) {
        if (!this.composedView) {
            this.create();
        }
        if (from !== fromPrevious || to !== toPrevious) {
            this.rename(from, to);
        }
    };
    /**
     * @private
     * @return {?}
     */
    RenamePropDirective.prototype.create = /**
     * @private
     * @return {?}
     */
    function () {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
    };
    /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    RenamePropDirective.prototype.rename = /**
     * @private
     * @param {?} from
     * @param {?} to
     * @return {?}
     */
    function (from, to) {
        this.composedView.updateContext((/**
         * @param {?} context
         * @param {?} parent
         * @return {?}
         */
        function (context, parent) {
            var _a;
            return Object.assign(context, omit(parent, [from]), (_a = {}, _a[to] = parent[from], _a));
        }));
    };
    /**
     * @private
     * @return {?}
     */
    RenamePropDirective.prototype.destroy = /**
     * @private
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    };
    RenamePropDirective.decorators = [
        { type: Directive, args: [{ selector: '[renameProp]' },] }
    ];
    /** @nocollapse */
    RenamePropDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    RenamePropDirective.propDecorators = {
        renameProp: [{ type: Input }],
        renamePropTo: [{ type: Input }]
    };
    return RenamePropDirective;
}());
if (false) {
    /** @type {?} */
    RenamePropDirective.prototype.renameProp;
    /** @type {?} */
    RenamePropDirective.prototype.renamePropTo;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    RenamePropDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/repeat.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var RepeatContext = /** @class */ (function () {
    function RepeatContext() {
    }
    return RepeatContext;
}());
if (false) {
    /** @type {?} */
    RepeatContext.prototype.$implicit;
    /** @type {?} */
    RepeatContext.prototype.repeat;
    /** @type {?} */
    RepeatContext.prototype.index;
}
var RepeatDirective = /** @class */ (function () {
    function RepeatDirective(viewContainerRef, templateRef) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
    }
    Object.defineProperty(RepeatDirective.prototype, "count", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var count = isNumber(this.repeat) ? this.repeat :
                isNumber(this.repeatOf) ? this.repeatOf : 0;
            return Math.max(count, 0);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    RepeatDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('repeat' in changes || 'repeatOf' in changes) {
            this.onRepeatChanged(this.count);
        }
    };
    /**
     * @return {?}
     */
    RepeatDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
    };
    /**
     * @private
     * @param {?} count
     * @return {?}
     */
    RepeatDirective.prototype.onRepeatChanged = /**
     * @private
     * @param {?} count
     * @return {?}
     */
    function (count) {
        /** When we need to create new items */
        for (var i = this.viewContainerRef.length; i < count; i++) {
            this.viewContainerRef.createEmbeddedView(this.templateRef, {
                $implicit: i, index: i, repeat: i
            }, i);
        }
        /** When we need to remove old items */
        for (var i = this.viewContainerRef.length; i > count; i--) {
            this.viewContainerRef.remove(i - 1);
        }
    };
    RepeatDirective.decorators = [
        { type: Directive, args: [{ selector: '[repeat]' },] }
    ];
    /** @nocollapse */
    RepeatDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef }
    ]; };
    RepeatDirective.propDecorators = {
        repeat: [{ type: Input }],
        repeatOf: [{ type: Input }]
    };
    return RepeatDirective;
}());
if (false) {
    /** @type {?} */
    RepeatDirective.prototype.repeat;
    /** @type {?} */
    RepeatDirective.prototype.repeatOf;
    /**
     * @type {?}
     * @private
     */
    RepeatDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    RepeatDirective.prototype.templateRef;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber(value) {
    return typeof value === 'number';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/return.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ReturnContext() { }
if (false) {
    /** @type {?} */
    ReturnContext.prototype.$implicit;
}
var ReturnDirective = /** @class */ (function () {
    function ReturnDirective(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        this.context = {
            $implicit: null
        };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ReturnDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('return' in changes) {
            if (!this.composedView) {
                this.create();
            }
            else {
                this.update();
            }
        }
    };
    /**
     * @return {?}
     */
    ReturnDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    ReturnDirective.prototype.create = /**
     * @private
     * @return {?}
     */
    function () {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
        this.update();
    };
    /**
     * @private
     * @return {?}
     */
    ReturnDirective.prototype.update = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.composedView.updateContext((/**
         * @param {?} context
         * @return {?}
         */
        function (context) {
            return Object.assign(context, _this.return);
        }));
    };
    ReturnDirective.decorators = [
        { type: Directive, args: [{ selector: '[return]' },] }
    ];
    /** @nocollapse */
    ReturnDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    ReturnDirective.propDecorators = {
        return: [{ type: Input }]
    };
    return ReturnDirective;
}());
if (false) {
    /** @type {?} */
    ReturnDirective.prototype.return;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    ReturnDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/route.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function RouteContext() { }
if (false) {
    /** @type {?} */
    RouteContext.prototype.$implicit;
    /** @type {?} */
    RouteContext.prototype.snapshot;
    /** @type {?} */
    RouteContext.prototype.url;
    /** @type {?} */
    RouteContext.prototype.params;
    /** @type {?} */
    RouteContext.prototype.queryParams;
    /** @type {?} */
    RouteContext.prototype.fragment;
    /** @type {?} */
    RouteContext.prototype.data;
    /** @type {?} */
    RouteContext.prototype.outlet;
    /** @type {?} */
    RouteContext.prototype.component;
    /** @type {?} */
    RouteContext.prototype.routeConfig;
    /** @type {?} */
    RouteContext.prototype.root;
    /** @type {?} */
    RouteContext.prototype.parent;
    /** @type {?} */
    RouteContext.prototype.firstChild;
    /** @type {?} */
    RouteContext.prototype.children;
    /** @type {?} */
    RouteContext.prototype.pathFromRoot;
    /** @type {?} */
    RouteContext.prototype.paramMap;
    /** @type {?} */
    RouteContext.prototype.queryParamMap;
}
/** @type {?} */
var ASYNC_FIELDS = ['url', 'params', 'queryParams', 'fragment', 'data', 'paramMap', 'queryParamMap'];
var RouteDirective = /** @class */ (function () {
    function RouteDirective(templateRef, viewContainerRef, route) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.route = route;
        this.context = {
            $implicit: this.route,
            /**
             * @return {?}
             */
            get snapshot() { return this.route.snapshot; },
            url: [],
            params: {},
            queryParams: {},
            fragment: null,
            data: null,
            /**
             * @return {?}
             */
            get outlet() { return this.route.outlet; },
            /**
             * @return {?}
             */
            get component() { return this.route.component; },
            /**
             * @return {?}
             */
            get routeConfig() { return this.route.routeConfig; },
            /**
             * @return {?}
             */
            get root() { return this.route.root; },
            /**
             * @return {?}
             */
            get parent() { return this.route.parent; },
            /**
             * @return {?}
             */
            get firstChild() { return this.route.firstChild; },
            /**
             * @return {?}
             */
            get children() { return this.route.children; },
            /**
             * @return {?}
             */
            get pathFromRoot() { return this.route.pathFromRoot; },
            paramMap: convertToParamMap({}),
            queryParamMap: convertToParamMap({})
        };
        this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this.context);
        this.subscriptions = this.attachFields(ASYNC_FIELDS);
    }
    /**
     * @return {?}
     */
    RouteDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach((/**
         * @param {?} subscription
         * @return {?}
         */
        function (subscription) {
            subscription.unsubscribe();
        }));
        this.subscriptions = null;
        this.viewContainerRef.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    /**
     * @private
     * @param {?} asyncFields
     * @return {?}
     */
    RouteDirective.prototype.attachFields = /**
     * @private
     * @param {?} asyncFields
     * @return {?}
     */
    function (asyncFields) {
        var _this = this;
        return asyncFields.map((/**
         * @param {?} field
         * @return {?}
         */
        function (field) { return _this.asyncAttach(field); }));
    };
    /**
     * @private
     * @param {?} field
     * @return {?}
     */
    RouteDirective.prototype.asyncAttach = /**
     * @private
     * @param {?} field
     * @return {?}
     */
    function (field) {
        var _this = this;
        return this.route[field]
            .pipe(distinctUntilChanged())
            .subscribe((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            _this.context[field] = value;
            _this.viewRef.markForCheck();
        }));
    };
    RouteDirective.decorators = [
        { type: Directive, args: [{ selector: '[route]' },] }
    ];
    /** @nocollapse */
    RouteDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: ActivatedRoute }
    ]; };
    return RouteDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.subscriptions;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    RouteDirective.prototype.route;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/set-props.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function SetPropsContext() { }
if (false) {
    /** @type {?} */
    SetPropsContext.prototype.$implicit;
    /** @type {?} */
    SetPropsContext.prototype.setProps;
}
var SetPropsDirective = /** @class */ (function () {
    function SetPropsDirective(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.context = { $implicit: null, setProps: null };
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    SetPropsDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('setProps' in changes) {
            this.onPropsDidChanged(this.setProps, changes.setProps.previousValue);
        }
    };
    /**
     * @return {?}
     */
    SetPropsDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    SetPropsDirective.prototype.onPropsDidChanged = /**
     * @private
     * @param {?} current
     * @param {?} previous
     * @return {?}
     */
    function (current, previous) {
        if (!this.context.$implicit) {
            return current && this.create(current);
        }
        if (current !== previous) {
            this.destroy();
            return this.onPropsDidChanged(current, null);
        }
    };
    /**
     * @private
     * @param {?} props
     * @return {?}
     */
    SetPropsDirective.prototype.create = /**
     * @private
     * @param {?} props
     * @return {?}
     */
    function (props) {
        this.composedView = new ComposedView(this.viewContainerRef);
        this.composedView.createEmbeddedView(this.context);
        this.composedView.updateContext((/**
         * @param {?} context
         * @param {?} parent
         * @return {?}
         */
        function (context, parent) {
            return Object.assign(context, parent, props);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    SetPropsDirective.prototype.destroy = /**
     * @private
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        if (this.composedView) {
            this.composedView.destroy();
            this.composedView = null;
        }
    };
    SetPropsDirective.decorators = [
        { type: Directive, args: [{ selector: '[setProps]' },] }
    ];
    /** @nocollapse */
    SetPropsDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    SetPropsDirective.propDecorators = {
        setProps: [{ type: Input }]
    };
    return SetPropsDirective;
}());
if (false) {
    /** @type {?} */
    SetPropsDirective.prototype.setProps;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.composedView;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    SetPropsDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/timeout.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TimeoutDirective = /** @class */ (function () {
    function TimeoutDirective(templateRef, viewContainerRef) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
    }
    Object.defineProperty(TimeoutDirective.prototype, "timeout", {
        set: /**
         * @param {?} milliseconds
         * @return {?}
         */
        function (milliseconds) {
            this.dispose();
            if (isNumber$1(milliseconds)) {
                this.create(milliseconds);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TimeoutDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dispose();
        this.viewContainerRef.clear();
    };
    /**
     * @private
     * @param {?} milliseconds
     * @return {?}
     */
    TimeoutDirective.prototype.create = /**
     * @private
     * @param {?} milliseconds
     * @return {?}
     */
    function (milliseconds) {
        var _this = this;
        this.timeoutId = setTimeout((/**
         * @return {?}
         */
        function () {
            if (_this.viewContainerRef) {
                _this.viewContainerRef.createEmbeddedView(_this.templateRef);
            }
        }), milliseconds);
    };
    /**
     * @private
     * @return {?}
     */
    TimeoutDirective.prototype.dispose = /**
     * @private
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        if (this.timeoutId) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    };
    TimeoutDirective.decorators = [
        { type: Directive, args: [{ selector: '[timeout]' },] }
    ];
    /** @nocollapse */
    TimeoutDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    TimeoutDirective.propDecorators = {
        timeout: [{ type: Input }]
    };
    return TimeoutDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.timeoutId;
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    TimeoutDirective.prototype.viewContainerRef;
}
/**
 * @param {?} value
 * @return {?}
 */
function isNumber$1(value) {
    return typeof value === 'number';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/track-by-key.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var NgForTrackByKeyDirective = /** @class */ (function () {
    function NgForTrackByKeyDirective(ngFor, viewContainerRef) {
        this.ngFor = ngFor;
        this.viewContainerRef = viewContainerRef;
        if (!ngFor) {
            throw new Error('TrackByKey should use with *ngFor!');
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    NgForTrackByKeyDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if ('ngForTrackByKey' in changes) {
            /** @type {?} */
            var key_1 = this.ngForTrackByKey;
            if (key_1) {
                this.ngFor.ngForTrackBy = (/**
                 * @param {?} index
                 * @param {?} item
                 * @return {?}
                 */
                function (index, item) { return item[key_1]; });
            }
            else {
                this.ngFor.ngForTrackBy = undefined;
            }
            this.ngFor['_differ'] = null;
            this.ngFor['_ngForOfDirty'] = true;
            this.viewContainerRef.clear();
            this.ngFor.ngDoCheck();
        }
    };
    NgForTrackByKeyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngForTrackByKey]'
                },] }
    ];
    /** @nocollapse */
    NgForTrackByKeyDirective.ctorParameters = function () { return [
        { type: NgForOf, decorators: [{ type: Host }, { type: Optional }] },
        { type: ViewContainerRef }
    ]; };
    NgForTrackByKeyDirective.propDecorators = {
        ngForTrackByKey: [{ type: Input }]
    };
    return NgForTrackByKeyDirective;
}());
if (false) {
    /** @type {?} */
    NgForTrackByKeyDirective.prototype.ngForTrackByKey;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.ngFor;
    /**
     * @type {?}
     * @private
     */
    NgForTrackByKeyDirective.prototype.viewContainerRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-effect.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var UseEffectDirective = /** @class */ (function () {
    function UseEffectDirective(templateRef, vcr) {
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = {};
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    UseEffectDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.useEffect && this.useEffect) {
            this.destroy();
            this.init();
        }
        else if (changes.useEffectOn) {
            if (Array.isArray(this.useEffectOn)) {
                /** @type {?} */
                var previous = changes.useEffectOn.previousValue || [];
                /** @type {?} */
                var current_1 = changes.useEffectOn.currentValue || [];
                /** @type {?} */
                var isChanged = !previous.every((/**
                 * @param {?} item
                 * @param {?} index
                 * @return {?}
                 */
                function (item, index) { return current_1[index] === item; }));
                if (isChanged) {
                    this.destroy();
                    this.init();
                }
            }
            else {
                this.destroy();
                this.init();
            }
        }
    };
    /**
     * @return {?}
     */
    UseEffectDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (!Array.isArray(this.useEffectOn)) {
            this.destroy();
            this.init();
        }
    };
    /**
     * @return {?}
     */
    UseEffectDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy();
    };
    /**
     * @private
     * @return {?}
     */
    UseEffectDirective.prototype.init = /**
     * @private
     * @return {?}
     */
    function () {
        this.viewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
        if (this.useEffect) {
            this.onDestroyCallback = this.useEffect();
        }
    };
    /**
     * @private
     * @return {?}
     */
    UseEffectDirective.prototype.destroy = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.onDestroyCallback) {
            this.onDestroyCallback();
            this.onDestroyCallback = null;
        }
        this.vcr.clear();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    };
    UseEffectDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[useEffect]'
                },] }
    ];
    /** @nocollapse */
    UseEffectDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    UseEffectDirective.propDecorators = {
        useEffect: [{ type: Input }],
        useEffectOn: [{ type: Input }]
    };
    return UseEffectDirective;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.context;
    /** @type {?} */
    UseEffectDirective.prototype.useEffect;
    /** @type {?} */
    UseEffectDirective.prototype.useEffectOn;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.onDestroyCallback;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.viewRef;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseEffectDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-reducer.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function Action() { }
if (false) {
    /** @type {?} */
    Action.prototype.type;
    /** @type {?} */
    Action.prototype.payload;
}
/**
 * @record
 * @template T
 */
function UseReducerImplicitContext() { }
if (false) {
    /** @type {?} */
    UseReducerImplicitContext.prototype.state;
    /** @type {?} */
    UseReducerImplicitContext.prototype.dispatch;
    /** @type {?} */
    UseReducerImplicitContext.prototype.reducer;
    /** @type {?} */
    UseReducerImplicitContext.prototype.detectChanges;
}
/**
 * @record
 * @template T
 */
function UseReducerContext() { }
if (false) {
    /** @type {?} */
    UseReducerContext.prototype.$implicit;
}
var UseReducerDirective = /** @class */ (function () {
    function UseReducerDirective(templateRef, vcr) {
        var _this = this;
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = {
            $implicit: {
                state: null,
                dispatch: /**
                 * @param {?} action
                 * @return {?}
                 */
                function (action) {
                    this.state = this.reducer(this.state, action);
                    this.detectChanges();
                },
                reducer: ((/**
                 * @return {?}
                 */
                function () { })),
                detectChanges: (/**
                 * @return {?}
                 */
                function () {
                    _this.embeddedViewRef.detectChanges();
                })
            }
        };
        this.embeddedViewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    UseReducerDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.useReducerInit && typeof this.useReducerInit === 'function') {
            this.context.$implicit.reducer = this.useReducerInit;
            this.context.$implicit.state = this.useReducerWith;
            if (this.useReducerAnd) {
                this.context.$implicit.dispatch(this.useReducerAnd);
            }
        }
    };
    /**
     * @return {?}
     */
    UseReducerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.vcr.clear();
        this.embeddedViewRef.destroy();
        this.embeddedViewRef = null;
    };
    UseReducerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[useReducer]'
                },] }
    ];
    /** @nocollapse */
    UseReducerDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    UseReducerDirective.propDecorators = {
        useReducerInit: [{ type: Input }],
        useReducerWith: [{ type: Input }],
        useReducerAnd: [{ type: Input }]
    };
    return UseReducerDirective;
}());
if (false) {
    /** @type {?} */
    UseReducerDirective.prototype.useReducerInit;
    /** @type {?} */
    UseReducerDirective.prototype.useReducerWith;
    /** @type {?} */
    UseReducerDirective.prototype.useReducerAnd;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseReducerDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/use-state.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template T
 */
function UseStateContext() { }
if (false) {
    /** @type {?} */
    UseStateContext.prototype.$implicit;
}
var UseStateDirective = /** @class */ (function () {
    function UseStateDirective(templateRef, vcr) {
        var _this = this;
        this.templateRef = templateRef;
        this.vcr = vcr;
        this.context = (/** @type {?} */ ({}));
        Object.defineProperty(this.context, '$implicit', {
            get: (/**
             * @return {?}
             */
            function () { return _this.value; }),
            set: (/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this.value = value;
                if (_this.embeddedViewRef) {
                    _this.embeddedViewRef.detectChanges();
                }
            })
        });
        this.embeddedViewRef = this.vcr.createEmbeddedView(this.templateRef, this.context);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    UseStateDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.useStateDefault) {
            this.value = this.useStateDefault;
        }
    };
    /**
     * @return {?}
     */
    UseStateDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.vcr.clear();
        this.embeddedViewRef.destroy();
        this.embeddedViewRef = null;
    };
    UseStateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[useState]'
                },] }
    ];
    /** @nocollapse */
    UseStateDirective.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    UseStateDirective.propDecorators = {
        useStateDefault: [{ type: Input }]
    };
    return UseStateDirective;
}());
if (false) {
    /** @type {?} */
    UseStateDirective.prototype.useStateDefault;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.context;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.embeddedViewRef;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.value;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    UseStateDirective.prototype.vcr;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tools/virtual.handler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VirtualHandler = /** @class */ (function () {
    function VirtualHandler() {
        var _this = this;
        this.elementLink = new Map();
        this.observer = new IntersectionObserver((/**
         * @param {?} entries
         * @return {?}
         */
        function (entries) {
            entries.forEach((/**
             * @param {?} entry
             * @return {?}
             */
            function (entry) {
                /** @type {?} */
                var cd = _this.elementLink.get((/** @type {?} */ (entry.target)));
                entry.isIntersecting ? attachCD(cd) : detachCD(cd);
            }));
        }));
    }
    /**
     * @param {?} element
     * @param {?} cd
     * @return {?}
     */
    VirtualHandler.prototype.register = /**
     * @param {?} element
     * @param {?} cd
     * @return {?}
     */
    function (element, cd) {
        this.elementLink.set(element, cd);
        this.observer.observe(element);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    VirtualHandler.prototype.unregister = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this.elementLink.delete(element);
        this.observer.unobserve(element);
    };
    /**
     * @return {?}
     */
    VirtualHandler.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.elementLink.forEach((/**
         * @param {?} cd
         * @param {?} e
         * @return {?}
         */
        function (cd, e) { return _this.observer.unobserve(e); }));
        this.elementLink.clear();
    };
    VirtualHandler.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ VirtualHandler.ɵprov = ɵɵdefineInjectable({ factory: function VirtualHandler_Factory() { return new VirtualHandler(); }, token: VirtualHandler, providedIn: "root" });
    return VirtualHandler;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    VirtualHandler.prototype.elementLink;
    /**
     * @type {?}
     * @private
     */
    VirtualHandler.prototype.observer;
}
/**
 * @param {?} cd
 * @return {?}
 */
function attachCD(cd) {
    cd.reattach();
    cd.detectChanges();
}
/**
 * @param {?} cd
 * @return {?}
 */
function detachCD(cd) {
    cd.detach();
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/virtual.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VirtualDirective = /** @class */ (function () {
    function VirtualDirective(handler, elementRef, cd) {
        this.handler = handler;
        this.elementRef = elementRef;
        this.cd = cd;
        this.handler.register(this.elementRef.nativeElement, cd);
    }
    /**
     * @return {?}
     */
    VirtualDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.handler.unregister(this.elementRef.nativeElement);
    };
    VirtualDirective.decorators = [
        { type: Directive, args: [{ selector: '[virtual]' },] }
    ];
    /** @nocollapse */
    VirtualDirective.ctorParameters = function () { return [
        { type: VirtualHandler },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    VirtualDirective.propDecorators = {
        virtual: [{ type: Input }]
    };
    return VirtualDirective;
}());
if (false) {
    /** @type {?} */
    VirtualDirective.prototype.virtual;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.handler;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    VirtualDirective.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/call.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template C
 */
var CallPipe = /** @class */ (function () {
    // with Ivy you can inject EmbeddedViewRef directly
    function CallPipe(cd) {
        this.cd = cd;
        this.context = ((/** @type {?} */ (this.cd))).context;
    }
    /**
     * @template M
     * @param {?} param
     * @param {?} fn
     * @param {...?} params
     * @return {?}
     */
    CallPipe.prototype.transform = /**
     * @template M
     * @param {?} param
     * @param {?} fn
     * @param {...?} params
     * @return {?}
     */
    function (param, fn) {
        var params = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            params[_i - 2] = arguments[_i];
        }
        return fn.apply(this.context, __spread([param], params));
    };
    CallPipe.decorators = [
        { type: Pipe, args: [{ name: 'call' },] }
    ];
    /** @nocollapse */
    CallPipe.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    return CallPipe;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    CallPipe.prototype.context;
    /**
     * @type {?}
     * @private
     */
    CallPipe.prototype.cd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/pipes/console.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function consoleFactory() {
    return console;
}
/** @type {?} */
var CONSOLE = new InjectionToken('Console', {
    providedIn: 'root',
    factory: consoleFactory
});
/** @type {?} */
var skipValueOperators = [
    'count',
    'markTimeline',
    'time',
    'timeEnd',
    'profile',
    'profileEnd',
    'timeline',
    'timelineEnd',
    'timeStamp',
    'group',
    'groupCollapsed'
];
var ConsolePipe = /** @class */ (function () {
    function ConsolePipe(console) {
        this.console = console;
    }
    /**
     * @template T
     * @param {?} message
     * @param {?=} logLevel
     * @param {...?} optionalParams
     * @return {?}
     */
    ConsolePipe.prototype.transform = /**
     * @template T
     * @param {?} message
     * @param {?=} logLevel
     * @param {...?} optionalParams
     * @return {?}
     */
    function (message, logLevel) {
        var _a;
        if (logLevel === void 0) { logLevel = 'log'; }
        var optionalParams = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            optionalParams[_i - 2] = arguments[_i];
        }
        /** @type {?} */
        var params;
        if (skipValueOperators.includes(logLevel)) {
            if (optionalParams.length > 0) {
                params = optionalParams;
            }
            else {
                params = [message];
            }
        }
        else {
            params = __spread([message], optionalParams);
        }
        (_a = this.console)[logLevel].apply(_a, __spread(params));
        return message;
    };
    ConsolePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'console'
                },] }
    ];
    /** @nocollapse */
    ConsolePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [CONSOLE,] }] }
    ]; };
    return ConsolePipe;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConsolePipe.prototype.console;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-effect.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var noop = (/**
 * @return {?}
 */
function () { });
var ɵ0 = noop;
/**
 * @param {?} effect
 * @param {?=} affectedKeys
 * @return {?}
 */
function UseEffect(effect, affectedKeys) {
    /** @type {?} */
    var destroyEffectsMap = new WeakMap();
    /**
     * @return {?}
     */
    function init() {
        /** @type {?} */
        var destroyEffect = effect.call(this);
        destroyEffectsMap.set(this, destroyEffect);
    }
    /**
     * @return {?}
     */
    function destroy() {
        if (destroyEffectsMap.has(this)) {
            /** @type {?} */
            var destroyEffect = destroyEffectsMap.get(this);
            if (destroyEffect) {
                destroyEffect();
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    function isChanged(changes) {
        if (!affectedKeys) {
            return true;
        }
        if (affectedKeys.length === 0) {
            return false;
        }
        return affectedKeys.every((/**
         * @param {?} affectedKey
         * @return {?}
         */
        function (affectedKey) { return affectedKey in changes; }));
    }
    return (/**
     * @param {?} def
     * @return {?}
     */
    function (def) {
        /** @type {?} */
        var originalOnInit = def.ngComponentDef.onInit || noop;
        def.ngComponentDef.onInit = (/**
         * @return {?}
         */
        function onInit() {
            originalOnInit();
            init.call(this);
        });
        /** @type {?} */
        var originalOnChanges = def.ngComponentDef.onChanges || noop;
        def.ngComponentDef.onChanges = (/**
         * @param {?} changes
         * @return {?}
         */
        function onChanges(changes) {
            originalOnChanges(changes);
            if (isChanged(changes)) {
                destroy.call(this);
                init.call(this);
            }
        });
        /** @type {?} */
        var originalOnDestroy = def.ngComponentDef.onDestroy || noop;
        def.ngComponentDef.onDestroy = (/**
         * @return {?}
         */
        function onDestroy() {
            originalOnDestroy();
            destroy.call(this);
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-reducer.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} __0
 * @param {?} reducer
 * @param {?=} initialValue
 * @return {?}
 */
function UseReducer(_a, reducer, initialValue) {
    var _b = __read(_a, 2), stateKey = _b[0], dispatchKey = _b[1];
    return (/**
     * @param {?} def
     * @return {?}
     */
    function (def) {
        /** @type {?} */
        var originalFactory = def.ngComponentDef.factory;
        def.ngComponentDef.factory = (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var cmp = originalFactory(def.ngComponentDef.type);
            cmp[stateKey] = initialValue;
            cmp[dispatchKey] = (/**
             * @param {?} action
             * @return {?}
             */
            function (action) { return cmp[stateKey] = reducer(cmp[stateKey], action); });
            return cmp;
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ivy-hooks/use-state.hook.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} __0
 * @param {?=} initialValue
 * @return {?}
 */
function UseState(_a, initialValue) {
    var _b = __read(_a, 2), stateKey = _b[0], setStateKey = _b[1];
    return (/**
     * @param {?} def
     * @return {?}
     */
    function (def) {
        /** @type {?} */
        var originalFactory = def.ngComponentDef.factory;
        def.ngComponentDef.factory = (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var cmp = originalFactory(def.ngComponentDef.type);
            cmp[stateKey] = initialValue;
            cmp[setStateKey] = (/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return cmp[stateKey] = value; });
            return cmp;
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/platform.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DIRECTIVES = [
    AsyncDirective,
    ComposeDirective,
    CookiesDirective,
    HttpDirective,
    LazyDirective,
    InitDirective,
    IsDevModeDirective,
    KeepAliveDirective,
    NestDirective,
    RenamePropDirective,
    RepeatDirective,
    ReturnDirective,
    RouteDirective,
    SetPropsDirective,
    TimeoutDirective,
    NgForTrackByKeyDirective,
    UseReducerDirective,
    UseStateDirective,
    UseEffectDirective,
    VirtualDirective
];
/** @type {?} */
var PIPES = [
    CallPipe,
    ConsolePipe
];
var NgxfModule = /** @class */ (function () {
    function NgxfModule() {
    }
    /**
     * @param {?} component
     * @return {?}
     */
    NgxfModule.forLazy = /**
     * @param {?} component
     * @return {?}
     */
    function (component) {
        return {
            ngModule: NgxfModule,
            providers: [
                { provide: LAZY_COMPONENT_TOKEN, useValue: component },
                { provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: component, multi: true }
            ]
        };
    };
    /**
     * @param {?} keepAliveConfig
     * @return {?}
     */
    NgxfModule.forKeepAlive = /**
     * @param {?} keepAliveConfig
     * @return {?}
     */
    function (keepAliveConfig) {
        return {
            ngModule: NgxfModule,
            providers: [
                { provide: KeepAliveConfig, useValue: keepAliveConfig }
            ]
        };
    };
    NgxfModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    declarations: [DIRECTIVES, PIPES],
                    exports: [DIRECTIVES, PIPES]
                },] }
    ];
    return NgxfModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngxf-platform.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AsyncDirective, CallPipe, ComposeDirective, ConsolePipe, CookiesDirective, HttpDirective, InitDirective, IsDevModeDirective, KeepAliveConfig, KeepAliveDirective, KeepAliveGC, LAZY_COMPONENT_TOKEN, LazyDirective, NestDirective, NgForTrackByKeyDirective, NgxfModule, RenamePropDirective, RepeatDirective, ReturnDirective, RouteDirective, SetPropsDirective, TimeoutDirective, UseEffect, UseEffectDirective, UseReducer, UseReducerDirective, UseState, UseStateDirective, VirtualDirective, DevModeService as ɵa, KeepAliveViewRefs as ɵb, KeepAliveManager as ɵc, RepeatContext as ɵd, consoleFactory as ɵe, CONSOLE as ɵf, CookieOptions as ɵg, CookiesService as ɵh, VirtualHandler as ɵi };
//# sourceMappingURL=ngxf-platform.js.map
